name: CI Publish Packages

# This workflow handles versioning, building, and publishing packages to NPM for both
# production (main branch) and pre-release (next branch) deployments.
#
# REQUIRED SECRETS:
# 1. WORKFLOW_PAT: Personal Access Token with 'repo' and 'workflow' scopes
#    - Required to push version commits and tags back to the repository
#    - Create at: GitHub Settings > Developer settings > Personal access tokens
# 2. ANTHROPIC_API_KEY: API key for AI-powered changelog generation
#    - Required to generate intelligent release changelogs
#    - Create at: https://console.anthropic.com/settings/keys
# 3. SLACK_WEBHOOK_URL: Incoming webhook URL for release notifications
#    - Required to send notifications to #ai-internal Slack channel
#    - Create at: https://api.slack.com/apps > Incoming Webhooks
# 4. NODE_AUTH_TOKEN: NPM authentication token
#    - Required to publish packages to NPM registry
#    - Create at: https://www.npmjs.com/settings/your-username/tokens
#
# WORKFLOW BEHAVIOR:
# - Triggered on push to 'main' or 'next' branches
# - Can be manually triggered with optional dry-run mode
# - Versions packages based on conventional commits
# - Publishes to NPM with appropriate tags (latest for main, next for next branch)
# - Generates AI-powered changelog for release notes
# - Sends Slack notification with changelog
# - Syncs 'next' branch with 'main' after production releases
#
# ARCHITECTURE:
# This workflow uses a multi-job orchestration pattern:
# 1. detect: Determines affected packages using Nx
# 2. publish: Calls _publish-core.yml to build, version, and publish packages
# 3. generate-changelog: Generates AI-powered changelog using reusable workflow
# 4. notify-release: Sends Slack notification with changelog using reusable workflow
# 5. sync-next: Syncs 'next' branch with 'main' after production releases
#
# The publish logic is extracted to _publish-core.yml for reusability
# across this workflow and force-publish-packages.yml.

on:
  push:
    branches:
      - main
      - next
  workflow_dispatch:
    inputs:
      dryRun:
        description: 'Perform a dry run without publishing'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

# Ensure only one publish workflow runs at a time per branch
# If a new run is triggered while one is in progress, it will be queued
# Setting cancel-in-progress to false ensures queued runs execute sequentially
concurrency:
  group: publish-${{ github.ref }}
  cancel-in-progress: false

jobs:
  detect:
    name: Detect affected packages
    runs-on: ubuntu-24.04
    environment: ${{ github.event_name == 'push' && 'Production' || null }}
    outputs:
      has_affected: ${{ steps.affected.outputs.has_affected }}
      projects: ${{ steps.affected.outputs.projects }}
      packages: ${{ steps.affected.outputs.packages }}
      base_sha: ${{ steps.base-sha.outputs.base }}
      npm_tag: ${{ steps.npm-tag.outputs.tag }}
      version_strategy: ${{ steps.version-strategy.outputs.strategy }}
      is_dry_run: ${{ steps.check-dry-run.outputs.is_dry_run }}
    # Skip the workflow if the commit is a version bump (to prevent loops)
    # Allow workflow to run for merge commits from update-production workflow
    # Skip workflow for branch sync commits
    if: ${{ !startsWith(github.event.head_commit.message, 'chore(release):') && !startsWith(github.event.head_commit.message, 'chore(sync):') }}

    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@2028fbc5c25fe9cf00d9f06a71cc4710d4507903 # v6.0.0
        with:
          node-version: ${{ vars.NODE_VERSION }}

      - name: Install npm
        run: npm install -g npm@${{ vars.NPM_VERSION }}

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Check if dry run
        id: check-dry-run
        env:
          DRY_RUN_INPUT: ${{ github.event.inputs.dryRun }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          # Dry run is true if:
          # 1. User explicitly selected dry run
          # 2. This is a manual workflow_dispatch (always preview for manual triggers)
          if [[ "$DRY_RUN_INPUT" == "true" ]] || [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
            echo "is_dry_run=true" >> $GITHUB_OUTPUT
            echo "Running in dry-run mode"
          else
            echo "is_dry_run=false" >> $GITHUB_OUTPUT
            echo "Running in live mode"
          fi

      - name: Determine npm tag
        id: npm-tag
        env:
          BRANCH_NAME: ${{ github.ref_name }}
        run: |
          if [[ "$BRANCH_NAME" == "next" ]]; then
            echo "tag=next" >> $GITHUB_OUTPUT
            echo "Using 'next' tag for npm publish"
          else
            echo "tag=latest" >> $GITHUB_OUTPUT
            echo "Using 'latest' tag for npm publish"
          fi

      - name: Determine version strategy
        id: version-strategy
        env:
          BRANCH_NAME: ${{ github.ref_name }}
        run: |
          if [[ "$BRANCH_NAME" == "next" ]]; then
            echo "strategy=prerelease" >> $GITHUB_OUTPUT
            echo "Using prerelease versioning for next branch"
          else
            echo "strategy=conventional" >> $GITHUB_OUTPUT
            echo "Using conventional commits to determine version bump for main branch"
          fi

      - name: Determine base SHA for affected detection
        id: base-sha
        env:
          EVENT_NAME: ${{ github.event_name }}
          BEFORE_SHA: ${{ github.event.before }}
        run: |
          # For push events, use the commit before the push
          # For manual triggers, fall back to HEAD~1
          if [[ "$EVENT_NAME" == "push" ]]; then
            BASE_SHA="$BEFORE_SHA"

            # Handle edge case: first push to a new branch (null SHA)
            if [[ "$BASE_SHA" == "0000000000000000000000000000000000000000" ]]; then
              echo "First push to branch - using HEAD~1 as base"
              echo "base=HEAD~1" >> $GITHUB_OUTPUT
            else
              echo "Using commit before push: $BASE_SHA"
              echo "base=$BASE_SHA" >> $GITHUB_OUTPUT
            fi
          else
            # Manual workflow dispatch - use previous commit
            echo "Manual trigger - using HEAD~1 as base"
            echo "base=HEAD~1" >> $GITHUB_OUTPUT
          fi

      - name: Determine affected packages
        id: affected
        env:
          BASE_SHA: ${{ steps.base-sha.outputs.base }}
        run: |
          # Get affected projects using Nx
          echo "Running: npx nx show projects --affected --base=$BASE_SHA --head=HEAD --type=lib --json"

          # Capture output and check if it's valid JSON
          # Suppress Node.js deprecation warnings and npm warnings to avoid polluting JSON output
          RAW_OUTPUT=$(NODE_NO_WARNINGS=1 npx nx show projects --affected --base="$BASE_SHA" --head=HEAD --type=lib --json 2>&1 || echo "[]")

          # Filter out npm warnings (lines starting with "npm warn")
          AFFECTED_OUTPUT=$(echo "$RAW_OUTPUT" | grep -v '^npm warn' || echo "[]")

          echo "AFFECTED_OUTPUT: $AFFECTED_OUTPUT"

          # Check if output is valid JSON
          if echo "$AFFECTED_OUTPUT" | jq empty 2>/dev/null; then
            AFFECTED_JSON="$AFFECTED_OUTPUT"
          else
            echo "‚ö†Ô∏è  Nx output is not valid JSON. Output:"
            echo "$AFFECTED_OUTPUT"
            echo "Using empty array as fallback"
            AFFECTED_JSON="[]"
          fi

          # Extract project names and filter out private packages
          # Read each project and check if it has "private": true in package.json
          echo "Filtering out private packages..."
          PUBLISHABLE_PROJECTS=()
          PACKAGE_NAMES=()

          for project in $(echo "$AFFECTED_JSON" | jq -r '.[]'); do
            # Find the package.json for this project
            # Use nx show project to get the project root
            PROJECT_ROOT=$(npx nx show project "$project" --json 2>/dev/null | jq -r '.root' || echo "")

            if [ -n "$PROJECT_ROOT" ] && [ -f "$PROJECT_ROOT/package.json" ]; then
              # Check if package is private
              IS_PRIVATE=$(jq -r '.private // false' "$PROJECT_ROOT/package.json")

              if [ "$IS_PRIVATE" = "true" ]; then
                echo "  ‚è≠Ô∏è  Skipping $project (private: true)"
              else
                PACKAGE_NAME=$(jq -r '.name // ""' "$PROJECT_ROOT/package.json")
                if [ -n "$PACKAGE_NAME" ]; then
                  echo "  ‚úÖ Including $project ‚Üí $PACKAGE_NAME (publishable)"
                  PUBLISHABLE_PROJECTS+=("$project")  # Store Nx project name
                  PACKAGE_NAMES+=("$PACKAGE_NAME")    # Store npm package name
                else
                  echo "  ‚ö†Ô∏è  Skipping $project (no package name found)"
                fi
              fi
            else
              echo "  ‚ö†Ô∏è  Skipping $project (no package.json found)"
            fi
          done

          # Join arrays with commas
          AFFECTED_PROJECTS=$(IFS=,; echo "${PUBLISHABLE_PROJECTS[*]}")
          AFFECTED_PACKAGES=$(IFS=,; echo "${PACKAGE_NAMES[*]}")

          echo "Publishable affected projects (Nx names): $AFFECTED_PROJECTS"
          echo "Publishable affected packages (npm names): $AFFECTED_PACKAGES"

          echo "projects=$AFFECTED_PROJECTS" >> $GITHUB_OUTPUT
          echo "packages=$AFFECTED_PACKAGES" >> $GITHUB_OUTPUT

          # Set a flag indicating if any packages are affected
          if [ -z "$AFFECTED_PROJECTS" ] || [ "$AFFECTED_PROJECTS" = "null" ]; then
            echo "has_affected=false" >> $GITHUB_OUTPUT
            echo "No publishable affected packages found - skipping release"
          else
            echo "has_affected=true" >> $GITHUB_OUTPUT
            echo "Found ${#PUBLISHABLE_PROJECTS[@]} publishable package(s)"
          fi

  publish:
    name: Build and publish packages
    needs: detect
    if: needs.detect.outputs.has_affected == 'true'
    uses: ./.github/workflows/__publish-packages.yml
    with:
      projects: ${{ needs.detect.outputs.projects }}
      packages: ${{ needs.detect.outputs.packages }}
      npm_tag: ${{ needs.detect.outputs.npm_tag }}
      version_strategy: ${{ needs.detect.outputs.version_strategy }}
      preid: 'next'
      branch: ${{ github.ref_name }}
      dry_run: ${{ needs.detect.outputs.is_dry_run == 'true' }}
      clean_orphaned_tags: true
      base_sha: ${{ needs.detect.outputs.base_sha }}
      is_prerelease: ${{ github.ref_name == 'next' }}
    secrets:
      WORKFLOW_PAT: ${{ secrets.WORKFLOW_PAT }}
      NODE_AUTH_TOKEN: ${{ secrets.NODE_AUTH_TOKEN }}
      SERVICE_ACCOUNT_GPG_PRIVATE_KEY: ${{ secrets.SERVICE_ACCOUNT_GPG_PRIVATE_KEY }}

  generate-changelog:
    name: Generate AI-powered changelog
    needs: [detect, publish]
    if: needs.detect.outputs.is_dry_run != 'true' && needs.publish.outputs.has_successes == 'true'
    uses: ./.github/workflows/_generate-changelog.yml
    with:
      from_ref: ${{ github.event.before }}
      to_ref: ${{ github.sha }}
      output_formats: 'slack,markdown'
      custom_prompt_text: |
        # Release Changelog Generation Prompt

        You are a changelog generator. Based on the following git changes, create a concise, human-readable changelog summary.

        ${{ needs.publish.outputs.has_failures == 'true' && format('**IMPORTANT**: This is a PARTIAL release. Some packages failed to publish.

        **Successfully published packages**:
        {0}

        **Failed packages** (not published):
        {1}

        Focus your changelog ONLY on the successfully published packages. Add a note at the end about which packages failed to publish.

        ', join(fromJSON(needs.publish.outputs.successful_packages), ', '), join(fromJSON(needs.publish.outputs.failed_packages), ', ')) || format('All packages were successfully published.

        **Published packages**:
        {0}

        ', join(fromJSON(needs.publish.outputs.successful_packages), ', ')) }}

        Focus on:
        - What features were added
        - What bugs were fixed
        - What was changed or improved

        Format requirements:
        - Use bullet points (‚Ä¢ or -) for each item, separated by a newline character
        - Keep it to 3-10 items max
        - Be concise and clear
        - Do NOT include commit hashes unless specifically requested
        - Group related changes together

        Slack formatting requirements (IMPORTANT):
        - DO NOT use markdown headers (no #, ##, ###)
        - Use plain text for section titles followed by a colon (e.g., "Features:")
        - Use _single asterisks_ for bold text (NOT double asterisks)
        - Use _underscores_ for italic text
        - Use simple bullet lists with ‚Ä¢ or - characters
        - Keep formatting minimal and clean
        - DO NOT use standard markdown links [text](url) - just use plain URLs or omit them
      max_tokens: 1024
    secrets:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

  notify-release:
    name: Notify release via Slack
    needs: [detect, publish, generate-changelog]
    if: needs.detect.outputs.is_dry_run != 'true' && needs.publish.outputs.has_successes == 'true'
    uses: ./.github/workflows/_notify-release.yml
    with:
      changelog_slack: ${{ needs.generate-changelog.outputs.changelog_slack }}
      changelog_markdown: ${{ needs.generate-changelog.outputs.changelog_markdown }}
      destinations: 'slack,notion'
      from_ref: ${{ github.event.before }}
      to_ref: ${{ github.sha }}
      branch: ${{ github.ref_name }}
      release_title: ${{ needs.publish.outputs.has_failures == 'true' && format('‚ö†Ô∏è Partial Release - {0} ({1} succeeded, {2} failed)', github.ref_name, needs.publish.outputs.successful_count, needs.publish.outputs.failed_count) || '' }}
    secrets:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      NOTION_API_KEY: ${{ secrets.NOTION_API_KEY }}
      RELEASE_NOTES_NOTION_DATABASE_ID: ${{ secrets.RELEASE_NOTES_NOTION_DATABASE_ID }}
      NODE_AUTH_TOKEN: ${{ secrets.NODE_AUTH_TOKEN }}

  sync-next:
    name: Sync next branch with main
    runs-on: ubuntu-24.04
    needs: [detect, publish]
    # Only run when main branch is updated (not on next branch pushes)
    if: github.ref_name == 'main' && github.event_name == 'push' && needs.detect.outputs.is_dry_run != 'true'
    permissions:
      contents: write

    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec # v6
        with:
          gpg_private_key: ${{ secrets.SERVICE_ACCOUNT_GPG_PRIVATE_KEY }}
          git_user_signingkey: true
          git_commit_gpgsign: true
          git_tag_gpgsign: true
          git_config_global: true

      - name: Configure Git identity for service account
        run: |
          git config user.name "Uniswap Labs Service Account"
          git config user.email "hello-happy-puppy@uniswap.org"

      - name: Verify GPG configuration
        run: |
          echo "GPG signing enabled: $(git config commit.gpgsign)"
          echo "GPG signing key: $(git config user.signingkey)"
          echo "Git user name: $(git config user.name)"
          echo "Git user email: $(git config user.email)"

      - name: Install Graphite CLI
        run: |
          # Install Graphite CLI using npm (faster than installing Homebrew)
          npm install -g @withgraphite/graphite-cli

          # Verify installation
          gt --version

      - name: Sync next branch with main
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
        run: |
          echo "Starting sync of next branch with main..."

          # Fetch all remote branches
          git fetch origin

          # Check if next branch exists on remote
          if ! git show-ref --verify --quiet refs/remotes/origin/next; then
            echo "Next branch does not exist on remote. Skipping sync."
            exit 0
          fi

          # Switch to next branch (tracking origin/next)
          git checkout -B next origin/next

          # Attempt to rebase next onto main
          echo "Rebasing next onto main..."

          # Try to rebase onto origin/main
          if git rebase origin/main; then
            echo "‚úÖ Rebase successful!"

            # Create an empty commit to mark this as a sync operation
            # This prevents the publish workflow from triggering on the next branch
            git commit --allow-empty -m "chore(sync): [skip ci] sync next with main"

            # Force push the rebased next branch
            git push origin next --force-with-lease

            echo "‚úÖ Successfully synced next branch with main"

            # Create summary
            echo "## üîÑ Branch Sync Complete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The \`next\` branch has been successfully rebased onto \`main\`." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Main branch**: $(git rev-parse --short origin/main)" >> $GITHUB_STEP_SUMMARY
            echo "- **Next branch**: $(git rev-parse --short next)" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Rebase failed due to conflicts"

            # Abort the rebase
            git rebase --abort

            # Create an issue for manual intervention
            gh issue create \
              --title "Manual intervention required: next branch sync failed" \
              --body "The automatic sync of the \`next\` branch with \`main\` has failed due to conflicts.

              ## Action Required
              Please manually resolve the conflicts by:
              1. Checking out the \`next\` branch locally
              2. Rebasing it onto \`main\`
              3. Resolving any conflicts
              4. Force pushing the resolved branch

              ## Commands
              \`\`\`bash
              git checkout next
              git fetch origin
              git rebase origin/main
              # Resolve conflicts
              git push origin next --force-with-lease
              \`\`\`

              This issue was automatically created by the publish-packages workflow." \
              --label "automated,needs-attention"

            echo "## ‚ö†Ô∏è Branch Sync Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The \`next\` branch could not be automatically rebased onto \`main\` due to conflicts." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "An issue has been created for manual intervention." >> $GITHUB_STEP_SUMMARY

            exit 1
          fi

      - name: Alternative sync with Graphite (if available)
        if: failure()
        continue-on-error: true
        run: |
          echo "Attempting alternative sync method with Graphite CLI..."

          # Initialize Graphite if needed
          gt init --trunk main --no-interactive || true

          # Try to sync using Graphite
          if gt sync --force --no-interactive; then
            echo "‚úÖ Successfully synced using Graphite CLI"
          else
            echo "‚ö†Ô∏è Graphite sync also failed. Manual intervention required."
          fi
