name: "[claude] Claude Code Review"

# Reusable workflow for automated PR code reviews using Claude AI
#
# This workflow provides comprehensive code reviews with:
# - Formal GitHub reviews (APPROVE/REQUEST_CHANGES/COMMENT)
# - Inline comments on specific lines of code (as github-actions[bot])
# - Patch-ID based caching to skip rebases
# - Custom prompt support
#
# ARCHITECTURE:
# This workflow uses a hybrid approach:
# 1. Claude analyzes the PR and outputs structured JSON
# 2. A TypeScript script parses the JSON and posts the review via gh CLI
#
# This ensures all comments appear as `github-actions[bot]` using the official
# Anthropic action without needing a fork.
#
# USAGE:
#   uses: Uniswap/ai-toolkit/.github/workflows/_claude-code-review.yml@main
#   with:
#     pr_number: ${{ github.event.pull_request.number }}
#     base_ref: ${{ github.base_ref }}
#   secrets:
#     ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
#
# FEATURES:
# - Runs on every push but skips rebases (patch-ID detection)
# - Creates inline comments like human reviewers
# - Submits formal reviews for merge protection
# - Supports custom prompts
# - Comment trigger: "@request-claude-review" in any PR comment forces a new review
# - Manual trigger via workflow_dispatch to force a new review
#
# NOTE: Re-requesting a review from github-actions[bot] via the GitHub UI
# does NOT trigger this workflow. GitHub does not fire the review_requested
# event when re-requesting reviews from bot accounts. Use the comment trigger
# or manual workflow_dispatch instead.
#
# PERMISSIONS REQUIRED (calling workflow must grant these):
#   contents: read
#   pull-requests: write
#   issues: read
#   actions: read
#   id-token: write

on:
  workflow_call:
    inputs:
      pr_number:
        description: "Pull request number to review"
        required: true
        type: string

      base_ref:
        description: "Base branch name (e.g., main, master). Optional - if not provided, will be fetched via GitHub API."
        required: false
        type: string
        default: ""

      force_review:
        description: "Force a full review even if the code hasn't changed (bypasses patch-ID cache)"
        required: false
        type: boolean
        default: false

      model:
        description: "Claude model to use for review"
        required: false
        type: string
        default: "claude-sonnet-4-5-20250929"

      max_turns:
        description: "Maximum conversation turns for Claude. Omit to use unlimited turns."
        required: false
        type: number

      timeout_minutes:
        description: "Job timeout in minutes"
        required: false
        type: number
        default: 30

      max_diff_lines:
        description: "Maximum diff lines before skipping Claude review (PR considered too large). Default: 2000"
        required: false
        type: number
        default: 2000

      allowed_tools:
        description: 'Comma-separated list of allowed tools for Claude (e.g., "Read,Grep,Glob"). Leave empty for default read-only set.'
        required: false
        type: string
        default: ""

      toolkit_ref:
        description: "Git ref (branch, tag, or SHA) of ai-toolkit to use for the post-review script. Defaults to 'main'. Use 'next' or a specific SHA to test unreleased changes."
        required: false
        type: string
        default: "main"

      prompt_override_files_to_skip:
        description: |
          Path to a markdown file in the repository that overrides the "Files to Skip" section.
          Example: https://github.com/Uniswap/ai-toolkit/blob/next/.github/prompts/pr-review/overridable/5-files-to-skip.md
        required: false
        type: string
        default: ""

      prompt_override_review_priorities:
        description: |
          Path to a markdown file in the repository that overrides the "Review Priorities" section.
          Example: https://github.com/Uniswap/ai-toolkit/blob/next/.github/prompts/pr-review/overridable/4-review-priorities.md
        required: false
        type: string
        default: ""

      prompt_override_communication_style:
        description: |
          Path to a markdown file in the repository that overrides the "Communication Style" section.
          Example: https://github.com/Uniswap/ai-toolkit/blob/next/.github/prompts/pr-review/overridable/6-communication-style.md
        required: false
        type: string
        default: ""

      prompt_override_pattern_recognition:
        description: |
          Path to a markdown file in the repository that overrides the "Pattern Recognition" section.
          Example: https://github.com/Uniswap/ai-toolkit/blob/next/.github/prompts/pr-review/overridable/7-pattern-recognition.md
        required: false
        type: string
        default: ""

      prompt_override_initial_review_process:
        description: |
          Path to a markdown file in the repository that overrides the "Initial Review Process" section.
          Example: https://github.com/Uniswap/ai-toolkit/blob/next/.github/prompts/pr-review/overridable/8-initial-review-process.md
        required: false
        type: string
        default: ""

      prompt_override_avoid_patterns:
        description: |
          Path to a markdown file in the repository that overrides the "Avoid Patterns" section.
          Example: https://github.com/Uniswap/ai-toolkit/blob/next/.github/prompts/pr-review/overridable/9-avoid-patterns.md
        required: false
        type: string
        default: ""

      prompt_override_verdict_approve:
        description: |
          Path to a markdown file in the repository that overrides the "Verdict: APPROVE" section.
          Example: https://github.com/Uniswap/ai-toolkit/blob/next/.github/prompts/pr-review/overridable/10-verdict-approve.md
        required: false
        type: string
        default: ""

      prompt_override_verdict_request_changes:
        description: |
          Path to a markdown file in the repository that overrides the "Verdict: REQUEST_CHANGES" section.
          Example: https://github.com/Uniswap/ai-toolkit/blob/next/.github/prompts/pr-review/overridable/11-verdict-request-changes.md
        required: false
        type: string
        default: ""

      prompt_override_verdict_comment:
        description: |
          Path to a markdown file in the repository that overrides the "Verdict: COMMENT" section.
          Example: https://github.com/Uniswap/ai-toolkit/blob/next/.github/prompts/pr-review/overridable/12-verdict-comment.md
        required: false
        type: string
        default: ""

      prompt_override_re_review_process:
        description: |
          Path to a markdown file in the repository that overrides the "Re-Review Process" section (for re-reviews).
          Example: https://github.com/Uniswap/ai-toolkit/blob/next/.github/prompts/pr-review/overridable/16-re-review-process.md
        required: false
        type: string
        default: ""

      install_uniswap_plugins:
        description: |
          Whether to install the uniswap-ai-toolkit plugins automatically.

          When true (default): All 5 uniswap-ai-toolkit plugins are installed:
          - development-planning
          - development-pr-workflow
          - development-codebase-tools
          - development-productivity
          - uniswap-integrations

          When false: No uniswap plugins are installed. Use this if you want to
          use only your own plugins via plugin_marketplaces and plugins inputs.
        required: false
        type: boolean
        default: true

      plugin_ref:
        description: |
          Git ref of ai-toolkit to use for the build-plugin-config composite
          action. Must be 'main' (stable) or 'next' (pre-release). Defaults to
          'main'.
        required: false
        type: string
        default: "main"

    secrets:
      ANTHROPIC_API_KEY:
        description: "Anthropic API key for Claude access. Required unless CLAUDE_CODE_OAUTH_TOKEN is provided."
        required: false
      CLAUDE_CODE_OAUTH_TOKEN:
        description: "Claude Code OAuth token for authentication. Alternative to ANTHROPIC_API_KEY. When provided, takes precedence over API key."
        required: false
      WORKFLOW_PAT:
        description: "Personal Access Token with repo scope. Only needed for resolving review threads via GraphQL API (falls back to GITHUB_TOKEN if not provided)."
        required: false

jobs:
  claude-review:
    runs-on: ubuntu-latest
    timeout-minutes: ${{ inputs.timeout_minutes }}
    env:
      MAX_CLAUDE_DIFF_LINES: ${{ inputs.max_diff_lines }} # any PR with a `git diff` larger than this will be considered too large for Claude review
    # Fixed permissions (cannot be overridden by calling workflow)
    permissions:
      id-token: write # Required for OIDC
      contents: read # Required to read repository code
      pull-requests: write # Required to comment and submit reviews
      issues: read # Required to read PR discussions
      actions: read # Required to check CI status

    steps:
      # Security scanning (required for all workflows)
      - name: Security Scan
        uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4
        with:
          egress-policy: audit

      # Checkout required before using local composite actions
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 50

      # Download validate-claude-auth action if caller repo doesn't have it
      # This allows external repos to use this reusable workflow without copying the action
      - name: Ensure validate-claude-auth action exists
        env:
          TOOLKIT_REF: ${{ inputs.toolkit_ref }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ACTION_FILE=".github/actions/validate-claude-auth/action.yml"

          if [ -f "$ACTION_FILE" ]; then
            echo "Using local validate-claude-auth action"
          else
            echo "Downloading validate-claude-auth action from ai-toolkit@${TOOLKIT_REF}..."
            mkdir -p .github/actions/validate-claude-auth

            # Use GitHub API (same pattern as _generate-pr-metadata.yml and _claude-task-worker.yml)
            # Authentication required to avoid GitHub API rate limits on shared runner IPs
            if ! curl -fSs --max-time 30 --max-redirs 3 \
                      -H "Accept: application/vnd.github.v4.raw" \
                      -H "Authorization: Bearer $GITHUB_TOKEN" \
                      -L "https://api.github.com/repos/Uniswap/ai-toolkit/contents/.github/actions/validate-claude-auth/action.yml?ref=${TOOLKIT_REF}" \
                      -o "$ACTION_FILE" 2>&1 | tee /tmp/curl-error.log; then
              echo "::error::Failed to download validate-claude-auth action from ai-toolkit@${TOOLKIT_REF}"
              cat /tmp/curl-error.log
              exit 1
            fi

            # Verify the file was downloaded and has content
            if [ ! -s "$ACTION_FILE" ]; then
              echo "::error::Downloaded action.yml is empty"
              exit 1
            fi

            # Verify it's a valid action file (has 'runs:' section)
            if ! grep -q "^runs:" "$ACTION_FILE"; then
              echo "::error::Downloaded action.yml is invalid (missing 'runs:' section)"
              echo "File contents:"
              cat "$ACTION_FILE"
              exit 1
            fi

            echo "Successfully downloaded validate-claude-auth action from ai-toolkit@${TOOLKIT_REF}"
          fi

      - name: Validate Authentication
        uses: ./.github/actions/validate-claude-auth
        with:
          anthropic-api-key: ${{ secrets.ANTHROPIC_API_KEY }}
          claude-oauth-token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}

      # Fetch PR metadata via API:
      # - head_sha: Checkout the exact PR commit (not GitHub's merge commit)
      # - base_ref: Use provided value or fetch from API (makes base_ref input optional)
      - name: Get PR Info
        id: pr-info
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ inputs.pr_number }}
          INPUT_BASE_REF: ${{ inputs.base_ref }}
        run: |
          echo "â„¹ï¸  Fetching PR #$PR_NUMBER info..."

          # Fetch PR data once
          PR_DATA=$(gh api repos/${{ github.repository }}/pulls/$PR_NUMBER)

          # Extract head SHA (always needed)
          HEAD_SHA=$(echo "$PR_DATA" | jq -r '.head.sha')
          echo "head_sha=$HEAD_SHA" >> $GITHUB_OUTPUT
          echo "ðŸ“ PR head SHA: $HEAD_SHA"

          # Use provided base_ref or fetch from API
          if [ -n "$INPUT_BASE_REF" ]; then
            BASE_REF="$INPUT_BASE_REF"
            echo "ðŸ“ Base ref (from input): $BASE_REF"
          else
            BASE_REF=$(echo "$PR_DATA" | jq -r '.base.ref')
            echo "ðŸ“ Base ref (from API): $BASE_REF"
          fi
          echo "base_ref=$BASE_REF" >> $GITHUB_OUTPUT

          # Calculate merge base - the common ancestor commit where the PR branch
          # diverged from the base branch. This matches what GitHub shows in the
          # PR diff view, which is more accurate than using base.sha (the current
          # HEAD of the base branch) when the base branch has moved forward.
          echo "ðŸ“ Calculating merge base..."
          COMPARE_DATA=$(gh api "repos/${{ github.repository }}/compare/${BASE_REF}...${HEAD_SHA}")
          MERGE_BASE_SHA=$(echo "$COMPARE_DATA" | jq -r '.merge_base_commit.sha')
          echo "merge_base_sha=$MERGE_BASE_SHA" >> $GITHUB_OUTPUT
          echo "ðŸ“ Merge base SHA: $MERGE_BASE_SHA"

          # Also output base_sha for reference (current HEAD of base branch)
          BASE_SHA=$(echo "$PR_DATA" | jq -r '.base.sha')
          echo "base_sha=$BASE_SHA" >> $GITHUB_OUTPUT
          echo "ðŸ“ Base branch HEAD: $BASE_SHA"

          if [ "$MERGE_BASE_SHA" != "$BASE_SHA" ]; then
            echo "â„¹ï¸  Note: Base branch has moved forward since PR was created"
            echo "   Using merge base for accurate diff calculation"
          fi

      # Checkout the exact PR head commit (not GitHub's merge commit)
      - name: Checkout Repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ steps.pr-info.outputs.head_sha }}
          fetch-depth: 0 # Full history needed for accurate diff calculation

      # Setup Node.js early so we can post status updates
      - name: Setup Node.js (Early)
        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af # v4.1.0
        with:
          node-version: "22"

      # Download or use local post-review script (needed for status updates)
      - name: Setup Post Review Script (Early)
        id: setup-script-early
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          TOOLKIT_REF: ${{ inputs.toolkit_ref }}
        run: |
          set -euo pipefail

          # Check if we're running from the ai-toolkit repository
          if [ "$GITHUB_REPOSITORY" = "Uniswap/ai-toolkit" ]; then
            echo "â„¹ï¸  Running from ai-toolkit - using local post-review.ts"
            echo "script_path=.github/scripts/post-review.ts" >> $GITHUB_OUTPUT
          else
            echo "â„¹ï¸  Running from external repository - downloading post-review.ts from Uniswap/ai-toolkit"
            echo "â„¹ï¸  Using toolkit ref: $TOOLKIT_REF"

            # Download the script from ai-toolkit repository
            # Note: Authentication required to avoid GitHub API rate limits on shared runner IPs
            if ! curl -fSs \
                      -H "Accept: application/vnd.github.v4.raw" \
                      -H "Authorization: Bearer $GITHUB_TOKEN" \
                      -L "https://api.github.com/repos/Uniswap/ai-toolkit/contents/.github/scripts/post-review.ts?ref=${TOOLKIT_REF}" \
                      -o /tmp/post-review.ts 2>&1 | tee /tmp/curl-error.log; then
              echo "âŒ Failed to download post-review.ts from Uniswap/ai-toolkit@${TOOLKIT_REF}"
              echo "   Error details:"
              cat /tmp/curl-error.log | head -5
              exit 1
            fi

            echo "âœ… Downloaded post-review.ts from SHA: $TOOLKIT_REF"
            echo "script_path=/tmp/post-review.ts" >> $GITHUB_OUTPUT
          fi

      # Calculate patch-ID (stable hash of code changes, survives rebases)
      # This must run BEFORE posting in-progress so we can check cache first
      - name: Calculate Patch ID
        id: patch-id
        env:
          # Use merge base SHA - the common ancestor where PR branch diverged
          # This matches what GitHub shows in the PR diff view
          MERGE_BASE_SHA: ${{ steps.pr-info.outputs.merge_base_sha }}
        run: |
          # Use the merge base SHA calculated from the compare API
          # This ensures we compare against exactly what GitHub shows in the PR diff
          echo "merge_base_sha=$MERGE_BASE_SHA" >> $GITHUB_OUTPUT
          echo "ðŸ“ Merge base SHA: $MERGE_BASE_SHA"

          # Calculate stable patch-ID (same code = same ID, even after rebase)
          # This diff contains ONLY the PR's changes compared to the merge base
          PATCH_ID=$(git diff ${MERGE_BASE_SHA}..HEAD | git patch-id --stable | cut -d' ' -f1)

          echo "patch_id=$PATCH_ID" >> $GITHUB_OUTPUT
          echo "ðŸ“Š Patch-ID: ${PATCH_ID:0:12}... (first 12 chars)"
          echo "   This ID stays the same across rebases if code hasn't changed"

      # Check cache BEFORE posting in-progress to preserve existing review
      # Skip cache check entirely when force_review is enabled
      - name: Check Review Cache
        id: cache-check
        if: inputs.force_review != true
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: .review-cache
          # Include merge_base_sha in cache key to invalidate when the merge base changes
          # (e.g., when a stacked PR's parent is merged and it rebases to main)
          key: review-pr${{ inputs.pr_number }}-base-${{ steps.patch-id.outputs.merge_base_sha }}-patch-${{ steps.patch-id.outputs.patch_id }}
          lookup-only: true # Just check, don't restore

      # Early exit if we've already reviewed this code (rebase detected)
      # Never skip when force_review is enabled
      # IMPORTANT: This runs BEFORE posting in-progress to preserve existing review content
      - name: Skip Review if No Changes
        if: steps.cache-check.outputs.cache-hit == 'true' && inputs.force_review != true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ inputs.pr_number }}
          POST_REVIEW_SCRIPT: ${{ steps.setup-script-early.outputs.script_path }}
        run: |
          echo "âœ… Skipping review - no actual code changes detected"
          echo ""
          echo "This push appears to be a rebase or merge without new code changes."
          echo "Patch-ID: ${{ steps.patch-id.outputs.patch_id }}"
          echo ""
          echo "We've already reviewed this exact code, so skipping to save API costs."
          echo ""
          echo "ðŸ’¡ To force a new review, use the manual trigger with force_review: true"

          # Add status banner to existing review (preserving full content)
          echo ""
          echo "â„¹ï¸  Adding 'still valid' status banner to existing review..."

          REPO_OWNER=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f1)
          REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2)

          npx tsx "$POST_REVIEW_SCRIPT" \
            --mode skipped \
            --owner "$REPO_OWNER" \
            --repo "$REPO_NAME" \
            --pr-number "$PR_NUMBER"

          echo "âœ… Review preserved with status banner"
          exit 0

      # Log when force review is enabled
      - name: Force Review Enabled
        if: inputs.force_review == true
        run: |
          echo "ðŸ”„ Force review enabled - bypassing cache check"
          echo "   A full review will run regardless of previous reviews for this code"

      # Detect trivial PRs for fast-path review
      # Only runs if we're actually going to do a review (not cached)
      - name: Detect Trivial PR
        id: pr-size
        if: steps.cache-check.outputs.cache-hit != 'true'
        env:
          MERGE_BASE_SHA: ${{ steps.patch-id.outputs.merge_base_sha }}
        run: |
          # Reuse merge base SHA from patch-id step
          echo "ðŸ“ Using merge base SHA: $MERGE_BASE_SHA"

          # Count lines changed (additions + deletions)
          STATS=$(git diff --shortstat ${MERGE_BASE_SHA}..HEAD)

          # Extract insertions and deletions, default to 0 if not present
          INSERTIONS=$(echo "$STATS" | grep -oP '\d+(?= insertion)' || echo "0")
          DELETIONS=$(echo "$STATS" | grep -oP '\d+(?= deletion)' || echo "0")
          TOTAL_CHANGES=$((INSERTIONS + DELETIONS))

          echo "lines_changed=$TOTAL_CHANGES" >> $GITHUB_OUTPUT
          echo "ðŸ“Š Total lines changed: $TOTAL_CHANGES"

          # Determine if this is a trivial PR (< 20 lines changed)
          if [ "$TOTAL_CHANGES" -lt 20 ]; then
            echo "is_trivial=true" >> $GITHUB_OUTPUT
            echo "âœ¨ Trivial PR detected (< 20 lines) - will use fast review mode"
          else
            echo "is_trivial=false" >> $GITHUB_OUTPUT
            echo "ðŸ“ Standard PR - will use comprehensive review mode"
          fi

      # Post "Review in Progress" comment ONLY if we're actually going to review
      # This runs AFTER cache check to preserve existing review on cache hits
      - name: Post Review In Progress
        id: in-progress
        if: steps.cache-check.outputs.cache-hit != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ inputs.pr_number }}
          POST_REVIEW_SCRIPT: ${{ steps.setup-script-early.outputs.script_path }}
        run: |
          set -euo pipefail

          echo "â„¹ï¸  Posting 'review in progress' status..."

          # Parse owner and repo
          REPO_OWNER=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f1)
          REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2)

          # Post in-progress comment (creates or updates the bot's comment)
          npx tsx "$POST_REVIEW_SCRIPT" \
            --mode in-progress \
            --owner "$REPO_OWNER" \
            --repo "$REPO_NAME" \
            --pr-number "$PR_NUMBER"

          echo "âœ… In-progress status posted"

      # Fetch existing review comments for context
      - name: Fetch Existing Review Comments
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: existing-comments
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          echo "â„¹ï¸  Fetching existing review comments for context..."

          # Get existing review comments (for re-review context)
          COMMENTS=$(gh api "/repos/${GITHUB_REPOSITORY}/pulls/${PR_NUMBER}/comments" \
            --jq '[.[] | {id: .id, path: .path, line: .line, body: .body, user: .user.login}]' || echo "[]")

          # Save to file for prompt inclusion
          echo "$COMMENTS" > /tmp/existing-comments.json

          COMMENT_COUNT=$(echo "$COMMENTS" | jq 'length')
          echo "existing_comment_count=$COMMENT_COUNT" >> $GITHUB_OUTPUT

          if [ "$COMMENT_COUNT" -gt 0 ]; then
            echo "â„¹ï¸  Found $COMMENT_COUNT existing review comment(s)"
          else
            echo "â„¹ï¸  No existing review comments found (initial review)"
          fi

      # Generate the PR diff for Claude to review
      # This ensures Claude reviews ONLY the PR's changes, not other commits merged to main
      - name: Generate PR Diff
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: pr-diff
        env:
          MERGE_BASE_SHA: ${{ steps.patch-id.outputs.merge_base_sha }}
        run: |
          set -euo pipefail

          echo "â„¹ï¸  Generating PR diff..."

          # Reuse merge base SHA from patch-id step (calculated via compare API)
          # This ensures we compare against exactly what GitHub shows in the PR diff view
          echo "ðŸ“ Using merge base SHA: $MERGE_BASE_SHA"

          # Define lockfile pattern for grep filtering
          # Note: We use grep -v instead of git pathspec exclusions because pathspec
          # exclusions have inconsistent behavior across different shell environments.
          # The grep approach is more portable and reliable.
          LOCKFILE_PATTERN='(^|/)(package-lock\.json|bun\.lock[b]?|yarn\.lock|pnpm-lock\.yaml|Podfile\.lock|composer\.lock|Gemfile\.lock|Cargo\.lock|poetry\.lock|go\.sum)$'

          # Generate the list of changed files (excluding lockfiles)
          ALL_CHANGED_FILES=$(git diff --name-only ${MERGE_BASE_SHA}..HEAD)
          CHANGED_FILES=$(echo "$ALL_CHANGED_FILES" | grep -vE "$LOCKFILE_PATTERN" || true)
          FILE_COUNT=$(echo "$CHANGED_FILES" | grep -c . || echo "0")
          echo "ðŸ“ Files changed (excluding lockfiles): $FILE_COUNT"

          # Generate the full diff (excluding lockfiles)
          # This is the ONLY diff Claude should review - it contains exactly the PR's changes
          # Pass the filtered file list to git diff to generate diff for only those files
          if [ -n "$CHANGED_FILES" ]; then
            echo "$CHANGED_FILES" | tr '\n' '\0' | xargs -0 git diff ${MERGE_BASE_SHA}..HEAD -- > /tmp/pr-diff.txt
          else
            # No non-lockfile changes - create empty diff
            touch /tmp/pr-diff.txt
          fi

          DIFF_SIZE=$(wc -c < /tmp/pr-diff.txt)
          echo "ðŸ“Š Diff size: $DIFF_SIZE bytes"

          # Save changed files list
          echo "$CHANGED_FILES" > /tmp/changed-files.txt

          echo "âœ… PR diff generated successfully"

      # Upload diff files as artifacts for debugging and inspection
      - name: Upload PR Diff Artifacts
        if: steps.cache-check.outputs.cache-hit != 'true'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: pr-diff-files-pr${{ inputs.pr_number }}
          path: |
            /tmp/changed-files.txt
            /tmp/pr-diff.txt
          retention-days: 7
          if-no-files-found: warn

      # Check if PR diff is too large for Claude review
      - name: Check PR Diff Size
        id: diff-size
        if: steps.cache-check.outputs.cache-hit != 'true'
        run: |
          set -euo pipefail

          # Count lines in the diff
          DIFF_LINES=$(wc -l < /tmp/pr-diff.txt)
          echo "ðŸ“Š Diff line count: $DIFF_LINES"

          # Check if diff is too large for Claude review
          if [ "$DIFF_LINES" -gt "$MAX_CLAUDE_DIFF_LINES" ]; then
            echo "is_too_large=true" >> $GITHUB_OUTPUT
            echo "âš ï¸  PR diff is too large for Claude review (> $MAX_CLAUDE_DIFF_LINES lines)"
          else
            echo "is_too_large=false" >> $GITHUB_OUTPUT
            echo "âœ… PR diff size is acceptable for Claude review"
          fi

          echo "line_count=$DIFF_LINES" >> $GITHUB_OUTPUT

      # Post "PR too large" message and exit if diff exceeds threshold
      - name: Post PR Too Large Message
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ inputs.pr_number }}
          POST_REVIEW_SCRIPT: ${{ steps.setup-script-early.outputs.script_path }}
          DIFF_LINE_COUNT: ${{ steps.diff-size.outputs.line_count }}
        run: |
          set -euo pipefail

          echo "â„¹ï¸  Posting 'PR too large' message..."

          # Parse owner and repo
          REPO_OWNER=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f1)
          REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2)

          # Post message that PR is too large for Claude review
          npx tsx "$POST_REVIEW_SCRIPT" \
            --mode too-large \
            --owner "$REPO_OWNER" \
            --repo "$REPO_NAME" \
            --pr-number "$PR_NUMBER" \
            --line-count "$DIFF_LINE_COUNT" \
            --max-diff-lines "$MAX_CLAUDE_DIFF_LINES"

          echo "âœ… 'PR too large' message posted"
          echo "â­ï¸  Skipping Claude review due to large diff size"
          exit 0

      # Download or use local build-prompt script
      - name: Setup Build Prompt Script
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true'
        id: setup-build-prompt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          TOOLKIT_REF: ${{ inputs.toolkit_ref }}
        run: |
          set -euo pipefail

          if [ "$GITHUB_REPOSITORY" = "Uniswap/ai-toolkit" ]; then
            echo "â„¹ï¸  Running from ai-toolkit - using local build-prompt.ts"
            echo "script_path=.github/scripts/build-prompt.ts" >> $GITHUB_OUTPUT
          else
            echo "â„¹ï¸  Running from external repository - downloading build-prompt.ts"
            if ! curl -fSs \
                      -H "Accept: application/vnd.github.v4.raw" \
                      -H "Authorization: Bearer $GITHUB_TOKEN" \
                      -L "https://api.github.com/repos/Uniswap/ai-toolkit/contents/.github/scripts/build-prompt.ts?ref=${TOOLKIT_REF}" \
                      -o /tmp/build-prompt.ts 2>&1 | tee /tmp/curl-error.log; then
              echo "âŒ Failed to download build-prompt.ts"
              cat /tmp/curl-error.log | head -5
              exit 1
            fi
            echo "âœ… Downloaded build-prompt.ts"
            echo "script_path=/tmp/build-prompt.ts" >> $GITHUB_OUTPUT
          fi

      # Fetch prompt section files for external repos
      - name: Fetch Prompt Section Files
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          TOOLKIT_REF: ${{ inputs.toolkit_ref }}
        run: |
          set -euo pipefail

          PROMPT_DIR="/tmp/pr-review-prompts"
          mkdir -p "$PROMPT_DIR/fixed" "$PROMPT_DIR/overridable"

          # If running from ai-toolkit, just copy local files
          if [ "$GITHUB_REPOSITORY" = "Uniswap/ai-toolkit" ]; then
            echo "â„¹ï¸  Using local prompt section files"
            cp -r .github/prompts/pr-review/fixed/* "$PROMPT_DIR/fixed/" 2>/dev/null || true
            cp -r .github/prompts/pr-review/overridable/* "$PROMPT_DIR/overridable/" 2>/dev/null || true
          else
            echo "â„¹ï¸  Downloading prompt section files from ai-toolkit..."

            # Define all section files to download
            # Section numbering: 1-3 (fixed early), 4-12 (overridable), 13-15 (fixed late),
            # 16-18 (conditional), 19 (fixed final)
            FIXED_SECTIONS=(
              "1-review-context.md"
              "2-diff-instructions.md"
              "3-repository-context.md"
              "13-inline-comment-rules.md"
              "14-important-notes.md"
              "15-comment-examples.md"
              "17-existing-comments.md"
              "18-fast-review-mode.md"
              "19-output-guidance.md"
            )

            OVERRIDABLE_SECTIONS=(
              "4-review-priorities.md"
              "5-files-to-skip.md"
              "6-communication-style.md"
              "7-pattern-recognition.md"
              "8-initial-review-process.md"
              "9-avoid-patterns.md"
              "10-verdict-approve.md"
              "11-verdict-request-changes.md"
              "12-verdict-comment.md"
              "16-re-review-process.md"
            )

            # Download fixed sections
            for section in "${FIXED_SECTIONS[@]}"; do
              curl -fSs \
                -H "Accept: application/vnd.github.v4.raw" \
                -H "Authorization: Bearer $GITHUB_TOKEN" \
                -L "https://api.github.com/repos/Uniswap/ai-toolkit/contents/.github/prompts/pr-review/fixed/${section}?ref=${TOOLKIT_REF}" \
                -o "$PROMPT_DIR/fixed/${section}" 2>/dev/null || echo "::warning::Failed to fetch fixed/${section}"
            done

            # Download overridable sections
            for section in "${OVERRIDABLE_SECTIONS[@]}"; do
              curl -fSs \
                -H "Accept: application/vnd.github.v4.raw" \
                -H "Authorization: Bearer $GITHUB_TOKEN" \
                -L "https://api.github.com/repos/Uniswap/ai-toolkit/contents/.github/prompts/pr-review/overridable/${section}?ref=${TOOLKIT_REF}" \
                -o "$PROMPT_DIR/overridable/${section}" 2>/dev/null || echo "::warning::Failed to fetch overridable/${section}"
            done
          fi

          echo "âœ… Prompt section files ready"
          ls -la "$PROMPT_DIR/fixed/" | head -5
          ls -la "$PROMPT_DIR/overridable/" | head -5

      # Validate override paths for security (prevent path traversal)
      - name: Validate Override Paths
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true'
        env:
          OVERRIDE_FILES_TO_SKIP: ${{ inputs.prompt_override_files_to_skip }}
          OVERRIDE_REVIEW_PRIORITIES: ${{ inputs.prompt_override_review_priorities }}
          OVERRIDE_COMMUNICATION_STYLE: ${{ inputs.prompt_override_communication_style }}
          OVERRIDE_PATTERN_RECOGNITION: ${{ inputs.prompt_override_pattern_recognition }}
          OVERRIDE_INITIAL_REVIEW_PROCESS: ${{ inputs.prompt_override_initial_review_process }}
          OVERRIDE_AVOID_PATTERNS: ${{ inputs.prompt_override_avoid_patterns }}
          OVERRIDE_VERDICT_APPROVE: ${{ inputs.prompt_override_verdict_approve }}
          OVERRIDE_VERDICT_REQUEST_CHANGES: ${{ inputs.prompt_override_verdict_request_changes }}
          OVERRIDE_VERDICT_COMMENT: ${{ inputs.prompt_override_verdict_comment }}
          OVERRIDE_RE_REVIEW_PROCESS: ${{ inputs.prompt_override_re_review_process }}
        run: |
          set -euo pipefail

          echo "ðŸ”’ Validating override paths for security..."

          validate_path() {
            local path="$1"
            local name="$2"

            # Empty path is OK (no override)
            if [ -z "$path" ]; then
              return 0
            fi

            # Reject absolute paths
            if [[ "$path" == /* ]]; then
              echo "âŒ ERROR: Absolute paths not allowed for $name: $path"
              return 1
            fi

            # Reject path traversal attempts
            if [[ "$path" == *../* ]] || [[ "$path" == ../* ]] || [[ "$path" == */../* ]]; then
              echo "âŒ ERROR: Path traversal not allowed for $name: $path"
              return 1
            fi

            # Verify file exists in repository
            if [ ! -f "$path" ]; then
              echo "âš ï¸  WARNING: Override file not found for $name: $path (will use default)"
            else
              echo "âœ… Valid override for $name: $path"
            fi

            return 0
          }

          # Validate all override paths
          validation_failed=false

          if ! validate_path "$OVERRIDE_FILES_TO_SKIP" "files_to_skip"; then
            validation_failed=true
          fi

          if ! validate_path "$OVERRIDE_REVIEW_PRIORITIES" "review_priorities"; then
            validation_failed=true
          fi

          if ! validate_path "$OVERRIDE_COMMUNICATION_STYLE" "communication_style"; then
            validation_failed=true
          fi

          if ! validate_path "$OVERRIDE_PATTERN_RECOGNITION" "pattern_recognition"; then
            validation_failed=true
          fi

          if ! validate_path "$OVERRIDE_INITIAL_REVIEW_PROCESS" "initial_review_process"; then
            validation_failed=true
          fi

          if ! validate_path "$OVERRIDE_AVOID_PATTERNS" "avoid_patterns"; then
            validation_failed=true
          fi

          if ! validate_path "$OVERRIDE_VERDICT_APPROVE" "verdict_approve"; then
            validation_failed=true
          fi

          if ! validate_path "$OVERRIDE_VERDICT_REQUEST_CHANGES" "verdict_request_changes"; then
            validation_failed=true
          fi

          if ! validate_path "$OVERRIDE_VERDICT_COMMENT" "verdict_comment"; then
            validation_failed=true
          fi

          if ! validate_path "$OVERRIDE_RE_REVIEW_PROCESS" "re_review_process"; then
            validation_failed=true
          fi

          if [ "$validation_failed" = true ]; then
            echo ""
            echo "âŒ Override path validation failed - aborting for security"
            exit 1
          fi

          echo "âœ… All override paths validated"

      # Build final prompt using TypeScript script
      - name: Build Review Prompt
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true'
        id: build-prompt
        env:
          OVERRIDE_FILES_TO_SKIP: ${{ inputs.prompt_override_files_to_skip }}
          OVERRIDE_REVIEW_PRIORITIES: ${{ inputs.prompt_override_review_priorities }}
          OVERRIDE_COMMUNICATION_STYLE: ${{ inputs.prompt_override_communication_style }}
          OVERRIDE_PATTERN_RECOGNITION: ${{ inputs.prompt_override_pattern_recognition }}
          OVERRIDE_INITIAL_REVIEW_PROCESS: ${{ inputs.prompt_override_initial_review_process }}
          OVERRIDE_AVOID_PATTERNS: ${{ inputs.prompt_override_avoid_patterns }}
          OVERRIDE_VERDICT_APPROVE: ${{ inputs.prompt_override_verdict_approve }}
          OVERRIDE_VERDICT_REQUEST_CHANGES: ${{ inputs.prompt_override_verdict_request_changes }}
          OVERRIDE_VERDICT_COMMENT: ${{ inputs.prompt_override_verdict_comment }}
          OVERRIDE_RE_REVIEW_PROCESS: ${{ inputs.prompt_override_re_review_process }}
          BUILD_PROMPT_SCRIPT: ${{ steps.setup-build-prompt.outputs.script_path }}
          REPO: ${{ github.repository }}
          PR_NUMBER: ${{ inputs.pr_number }}
          BASE_REF: ${{ steps.pr-info.outputs.base_ref }}
          PATCH_ID: ${{ steps.patch-id.outputs.patch_id }}
          MERGE_BASE_SHA: ${{ steps.patch-id.outputs.merge_base_sha }}
          LINES_CHANGED: ${{ steps.pr-size.outputs.lines_changed }}
          EXISTING_COMMENT_COUNT: ${{ steps.existing-comments.outputs.existing_comment_count }}
          IS_TRIVIAL: ${{ steps.pr-size.outputs.is_trivial }}
        run: |
          set -euo pipefail

          echo "ðŸ“ Building prompt using TypeScript script"

          # Parse repository owner and name
          REPO_OWNER=$(echo "$REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$REPO" | cut -d'/' -f2)

          # Run the build-prompt script
          npx tsx "$BUILD_PROMPT_SCRIPT" \
            --prompt-dir "/tmp/pr-review-prompts" \
            --output "/tmp/final-prompt.txt" \
            --repo-owner "$REPO_OWNER" \
            --repo-name "$REPO_NAME" \
            --pr-number "$PR_NUMBER" \
            --base-ref "$BASE_REF" \
            --patch-id "$PATCH_ID" \
            --base-sha "$MERGE_BASE_SHA" \
            --lines-changed "$LINES_CHANGED" \
            --existing-comment-count "$EXISTING_COMMENT_COUNT" \
            --is-trivial "$IS_TRIVIAL" \
            --changed-files-file "/tmp/changed-files.txt" \
            --pr-diff-file "/tmp/pr-diff.txt" \
            --existing-comments-file "/tmp/existing-comments.json"

          # Output the file path (not content) to avoid Bun parsing issues with large prompts
          # The prompt content is written to /tmp/final-prompt.txt by the script above
          # Claude Code will read the file via the @path reference in the prompt
          echo "prompt_file_path=/tmp/final-prompt.txt" >> $GITHUB_OUTPUT

          # Show prompt size and preview for debugging
          echo ""
          PROMPT_SIZE=$(wc -c < "/tmp/final-prompt.txt")
          PROMPT_LINES=$(wc -l < "/tmp/final-prompt.txt")
          echo "ðŸ“Š Prompt size: $PROMPT_SIZE bytes, $PROMPT_LINES lines"
          echo ""
          echo "ðŸ“„ Prompt preview (first 15 lines):"
          head -n 15 "/tmp/final-prompt.txt"

      # Upload final prompt as artifact for debugging and inspection
      - name: Upload Final Prompt Artifact
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: final-prompt-pr${{ inputs.pr_number }}
          path: /tmp/final-prompt.txt
          retention-days: 7
          if-no-files-found: warn

      # Build Claude arguments - READ-ONLY tools only (no GitHub write tools)
      - name: Build Claude Arguments
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true'
        id: build-args
        env:
          INPUT_ALLOWED_TOOLS: ${{ inputs.allowed_tools }}
          INPUT_MAX_TURNS: ${{ inputs.max_turns }}
          INPUT_MODEL: ${{ inputs.model }}
        run: |
          # Build allowed tools list - READ-ONLY tools only
          # Claude outputs JSON, the post-review script handles GitHub writes
          if [ -n "$INPUT_ALLOWED_TOOLS" ]; then
            ALLOWED_TOOLS="$INPUT_ALLOWED_TOOLS"
          else
            # Define read-only tools for analysis
            TOOLS=(
              # File operations (read-only)
              "Read"
              "Grep"
              "Glob"

              # Git commands for context (read-only)
              "Bash(git log:*)"
              "Bash(git diff:*)"
              "Bash(git show:*)"
              "Bash(git blame:*)"
              "Bash(git rev-parse:*)"

              # GitHub MCP tools (read-only, for fetching PR context)
              "mcp__github__get_pull_request"
              "mcp__github__get_pull_request_files"
              "mcp__github__get_pull_request_comments"
              "mcp__github__get_pull_request_reviews"
            )

            # Join array elements with commas (no spaces)
            ALLOWED_TOOLS=$(IFS=,; echo "${TOOLS[*]}")
          fi

          # Define JSON schema for structured output
          # This ensures Claude returns validated JSON matching our expected format
          JSON_SCHEMA='{
            "type": "object",
            "properties": {
              "pr_review_body": {
                "type": "string",
                "description": "Markdown-formatted review summary with all analysis"
              },
              "pr_review_outcome": {
                "type": "string",
                "enum": ["COMMENT", "APPROVE", "REQUEST_CHANGES"],
                "description": "Review decision"
              },
              "inline_comments_new": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "path": { "type": "string", "description": "File path" },
                    "line": { "type": "integer", "description": "Line number" },
                    "body": { "type": "string", "description": "Comment text" },
                    "suggestion": { "type": "string", "description": "Optional code suggestion" }
                  },
                  "required": ["path", "line", "body"]
                },
                "description": "New inline comments on specific lines"
              },
              "inline_comments_responses": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "comment_id": { "type": "integer", "description": "ID of existing comment" },
                    "body": { "type": "string", "description": "Response text" },
                    "should_resolve": { "type": "boolean", "description": "Whether to resolve the thread" }
                  },
                  "required": ["comment_id", "body"]
                },
                "description": "Responses to existing review comments"
              },
              "files_reviewed": {
                "type": "array",
                "items": { "type": "string" },
                "description": "List of files reviewed"
              },
              "confidence": {
                "type": "number",
                "minimum": 0,
                "maximum": 1,
                "description": "Confidence level (0.0-1.0)"
              }
            },
            "required": ["pr_review_body", "pr_review_outcome", "inline_comments_new"]
          }'

          # Build claude_args conditionally based on provided inputs
          CLAUDE_ARGS="--model $INPUT_MODEL"

          # Only add --max-turns if explicitly provided (not empty or 0)
          # Note: GitHub Actions number inputs default to 0 when not provided
          if [ -n "$INPUT_MAX_TURNS" ] && [ "$INPUT_MAX_TURNS" != "0" ]; then
            CLAUDE_ARGS="$CLAUDE_ARGS
            --max-turns $INPUT_MAX_TURNS"
            echo "â„¹ï¸  Including --max-turns $INPUT_MAX_TURNS"
          else
            echo "â„¹ï¸  Omitting --max-turns (unlimited turns)"
          fi

          # Add JSON schema for structured output (ensures validated JSON response)
          # Compact the schema to a single line for the CLI argument
          COMPACT_SCHEMA=$(echo "$JSON_SCHEMA" | jq -c .)
          CLAUDE_ARGS="$CLAUDE_ARGS
            --json-schema '$COMPACT_SCHEMA'
            --allowedTools $ALLOWED_TOOLS"

          echo "allowed_tools=$ALLOWED_TOOLS" >> $GITHUB_OUTPUT
          echo "claude_args<<CLAUDE_ARGS_EOF" >> $GITHUB_OUTPUT
          echo "$CLAUDE_ARGS" >> $GITHUB_OUTPUT
          echo "CLAUDE_ARGS_EOF" >> $GITHUB_OUTPUT
          echo "âœ… Configured structured output with JSON schema"
          echo "âœ… Configured read-only tools (${#ALLOWED_TOOLS} chars)"

      # Build plugin configuration using shared composite action
      # Note: GitHub Actions requires static refs in 'uses:', so we use conditional
      # steps instead of dynamic interpolation for security and predictability.
      - name: Build plugin configuration (main)
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true' && (inputs.plugin_ref == 'main' || inputs.plugin_ref == '')
        id: build-plugins-main
        uses: Uniswap/ai-toolkit/.github/actions/build-plugin-config@main
        with:
          install_uniswap_plugins: ${{ inputs.install_uniswap_plugins }}

      - name: Build plugin configuration (next)
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true' && inputs.plugin_ref == 'next'
        id: build-plugins-next
        uses: Uniswap/ai-toolkit/.github/actions/build-plugin-config@next
        with:
          install_uniswap_plugins: ${{ inputs.install_uniswap_plugins }}

      # Run Claude Code Action to perform the review (analysis only, outputs JSON)
      # Supports both API key and OAuth token authentication (validated in earlier step)
      # NOTE: We use a file reference (@path) instead of passing prompt content directly
      # to avoid Bun parsing issues with large prompts (GitHub Actions output size limits)
      - name: Run Claude Code Review
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true'
        id: claude
        uses: anthropics/claude-code-action@1b8ee3b94104046d71fde52ec3557651ad8c0d71 # v1.0.29
        with:
          # Authentication: provide either API key or OAuth token (validated in earlier step)
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          # github_token is required for OAuth authentication
          github_token: ${{ secrets.GITHUB_TOKEN }}
          # Use file reference to avoid passing large prompt content through GitHub Actions outputs
          # Claude Code will read the file and execute the instructions within it
          prompt: "Read and act upon the prompt at @${{ steps.build-prompt.outputs.prompt_file_path }}"
          # Disable built-in progress tracking - we handle our own PR comments
          track_progress: false
          # Show full Claude output in logs for debugging
          show_full_output: false
          allowed_bots: dependabot
          claude_args: ${{ steps.build-args.outputs.claude_args }}
          # Plugin configuration (requires claude-code-action v1.0.28+)
          # Coalesce outputs from conditional steps (only one will have run)
          plugin_marketplaces: ${{ steps.build-plugins-main.outputs.plugin_marketplaces || steps.build-plugins-next.outputs.plugin_marketplaces }}
          plugins: ${{ steps.build-plugins-main.outputs.plugins || steps.build-plugins-next.outputs.plugins }}
          additional_permissions: |
            actions: read

      # Note: Node.js is already set up earlier for posting in-progress status

      # Extract Claude's structured output (validated JSON from --json-schema)
      - name: Extract Claude Response
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true' && success()
        id: extract-response
        env:
          STRUCTURED_OUTPUT: ${{ steps.claude.outputs.structured_output }}
        run: |
          set -euo pipefail

          echo "â„¹ï¸  Extracting structured output from Claude..."

          # The structured_output is already validated JSON from --json-schema
          if [ -z "$STRUCTURED_OUTPUT" ]; then
            echo "âŒ No structured_output from Claude"
            echo "   This may indicate the --json-schema flag wasn't processed correctly"
            exit 1
          fi

          # Save the structured output for the post-review script
          echo "$STRUCTURED_OUTPUT" > /tmp/claude-review-response.txt
          echo "âœ… Extracted structured output (${#STRUCTURED_OUTPUT} chars)"

          # Show preview and validate it's proper JSON
          echo "ðŸ“‹ Response preview:"
          echo "$STRUCTURED_OUTPUT" | jq -r '.pr_review_outcome // "unknown"' | xargs -I{} echo "  Outcome: {}"
          echo "$STRUCTURED_OUTPUT" | jq -r '.inline_comments_new | length' | xargs -I{} echo "  Inline comments: {}"
          echo "$STRUCTURED_OUTPUT" | jq -r '.confidence // "not set"' | xargs -I{} echo "  Confidence: {}"

      # Upload Claude execution output as artifact for debugging
      - name: Upload Claude Execution Output
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true' && always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: claude-execution-output-pr${{ inputs.pr_number }}
          path: /home/runner/work/_temp/claude-execution-output.json
          retention-days: 7
          if-no-files-found: warn

      # Note: Post-review script is already downloaded/located earlier for in-progress status

      # Post the review using our script (all comments as github-actions[bot])
      - name: Post Review via Script
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true' && success()
        id: post-review
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # WORKFLOW_PAT is used for GraphQL operations (resolving review threads)
          # that require elevated permissions beyond what GITHUB_TOKEN provides
          GH_TOKEN_FOR_GRAPHQL: ${{ secrets.WORKFLOW_PAT || secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          # Pass file path instead of content to avoid shell injection risks
          # The script reads the file directly, avoiding shell expansion of content
          REVIEW_JSON_FILE: /tmp/claude-review-response.txt
          # Script path determined by early setup step (local or downloaded)
          POST_REVIEW_SCRIPT: ${{ steps.setup-script-early.outputs.script_path }}
        run: |
          set -euo pipefail

          echo "â„¹ï¸  Parsing Claude's review output and posting to GitHub..."
          echo "â„¹ï¸  Using script: $POST_REVIEW_SCRIPT"

          # Parse owner and repo
          REPO_OWNER=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f1)
          REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2)

          # Verify the response file exists
          if [ ! -f "$REVIEW_JSON_FILE" ]; then
            echo "âŒ No review response file found at $REVIEW_JSON_FILE"
            exit 1
          fi

          # Check that the file has content
          if [ ! -s "$REVIEW_JSON_FILE" ]; then
            echo "âŒ No review output from Claude (file is empty)"
            exit 1
          fi

          echo "â„¹ï¸  Review response length: $(wc -c < "$REVIEW_JSON_FILE") bytes"

          # Run the post-review script (path from setup-script step)
          # REVIEW_JSON_FILE env var is passed to the script, which reads the file directly
          # This avoids shell expansion of file content (shell injection safe)
          npx tsx "$POST_REVIEW_SCRIPT" \
            --owner "$REPO_OWNER" \
            --repo "$REPO_NAME" \
            --pr-number "$PR_NUMBER"

          echo "âœ… Review posted successfully"

      # Upload post-review API request files for debugging
      # These temp files contain the JSON payloads sent to GitHub API
      - name: Upload Post Review Debug Artifacts
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true' && always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: post-review-debug-pr${{ inputs.pr_number }}
          path: /tmp/gh-input-*.json
          retention-days: 7
          if-no-files-found: ignore

      # Fallback: Post review summary as PR comment if script fails
      - name: Fallback Review Comment
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true' && failure()
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: |
          set -euo pipefail

          echo "âš ï¸  Script failed, posting Claude's output as comment fallback..."

          COMMENT_MARKER="<!-- claude-pr-review-bot -->"
          JOB_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          # Try to read the extracted response, fallback to execution file
          if [ -f /tmp/claude-review-response.txt ]; then
            SUMMARY=$(cat /tmp/claude-review-response.txt)
          elif [ -f /home/runner/work/_temp/claude-execution-output.json ]; then
            SUMMARY=$(cat /home/runner/work/_temp/claude-execution-output.json | head -c 10000)
          else
            SUMMARY="No review output available"
          fi

          # Generate fallback comment
          COMMENT_BODY=$(cat <<EOF
          ${COMMENT_MARKER}
          ## ðŸ¤– Claude Code Review

          **Status:** âš ï¸ Partial (script error)
          **Job:** [View workflow run](${JOB_URL})

          ---

          The review was completed but there was an error posting inline comments.

          <details>
          <summary>Raw Review Output</summary>

          \`\`\`
          ${SUMMARY:0:10000}
          \`\`\`

          </details>

          ---

          *Please check the workflow logs for details.*
          EOF
          )

          # Post as PR comment
          gh api "/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" \
            -X POST \
            -f body="$COMMENT_BODY" \
            > /dev/null

          echo "âœ… Fallback comment posted"

      # Post error comment if Claude completely fails (no output at all)
      - name: Post Review Error Comment
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true' && failure() && steps.claude.conclusion == 'failure'
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          COMMENT_MARKER="<!-- claude-pr-review-bot -->"
          JOB_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          echo "â„¹ï¸  Posting review error comment" >&2

          # Generate error comment body
          COMMENT_BODY=$(cat <<EOF
          ${COMMENT_MARKER}
          ## ðŸ¤– Claude Code Review

          **Status:** âŒ Error
          **Job:** [View workflow run](${JOB_URL})

          ---

          ### âš ï¸ Review Failed

          The automated code review encountered an error and could not complete.

          **Next Steps:**
          1. Check the [workflow logs](${JOB_URL}) for details
          2. Verify the GitHub Actions configuration
          3. Ensure the Anthropic API key is valid
          4. Check for any permission issues

          If the problem persists, please contact your repository administrator.

          ---

          *You can manually re-trigger the review by pushing a new commit or re-running the workflow.*
          EOF
          )

          # Post comment
          gh api "/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" \
            -X POST \
            -f body="$COMMENT_BODY" \
            > /dev/null

          echo "âœ… Error comment posted" >&2

      # Save successful review to cache
      - name: Save Review Cache Marker
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true' && success()
        run: |
          mkdir -p .review-cache
          echo "${{ steps.patch-id.outputs.patch_id }}" > .review-cache/patch-id
          echo "Cached review for patch-ID: ${{ steps.patch-id.outputs.patch_id }}"

      # Persist cache for future rebase detection
      - name: Cache Review State
        if: steps.cache-check.outputs.cache-hit != 'true' && steps.diff-size.outputs.is_too_large != 'true' && success()
        uses: actions/cache/save@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: .review-cache
          # Include merge_base_sha in cache key to invalidate when the merge base changes
          # (e.g., when a stacked PR's parent is merged and it rebases to main)
          key: review-pr${{ inputs.pr_number }}-base-${{ steps.patch-id.outputs.merge_base_sha }}-patch-${{ steps.patch-id.outputs.patch_id }}
