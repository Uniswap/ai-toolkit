name: "[claude] Claude Code Review"

# Reusable workflow for automated PR code reviews using Claude AI
#
# This workflow provides comprehensive code reviews with:
# - Formal GitHub reviews (APPROVE/REQUEST_CHANGES/COMMENT)
# - Inline comments on specific lines of code (as github-actions[bot])
# - Patch-ID based caching to skip rebases
# - Custom prompt support
#
# ARCHITECTURE:
# This workflow uses a hybrid approach:
# 1. Claude analyzes the PR and outputs structured JSON
# 2. A TypeScript script parses the JSON and posts the review via gh CLI
#
# This ensures all comments appear as `github-actions[bot]` using the official
# Anthropic action without needing a fork.
#
# USAGE:
#   uses: Uniswap/ai-toolkit/.github/workflows/_claude-code-review.yml@main
#   with:
#     pr_number: ${{ github.event.pull_request.number }}
#     base_ref: ${{ github.base_ref }}
#   secrets:
#     ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
#
# FEATURES:
# - Runs on every push but skips rebases (patch-ID detection)
# - Creates inline comments like human reviewers
# - Submits formal reviews for merge protection
# - Supports custom prompts
# - Comment trigger: "@request-claude-review" in any PR comment forces a new review
# - Manual trigger via workflow_dispatch to force a new review
#
# NOTE: Re-requesting a review from github-actions[bot] via the GitHub UI
# does NOT trigger this workflow. GitHub does not fire the review_requested
# event when re-requesting reviews from bot accounts. Use the comment trigger
# or manual workflow_dispatch instead.
#
# PERMISSIONS REQUIRED (calling workflow must grant these):
#   contents: read
#   pull-requests: write
#   issues: read
#   actions: read
#   id-token: write

on:
  workflow_call:
    inputs:
      pr_number:
        description: "Pull request number to review"
        required: true
        type: string

      base_ref:
        description: "Base branch name (e.g., main, master). Optional - if not provided, will be fetched via GitHub API."
        required: false
        type: string
        default: ""

      force_review:
        description: "Force a full review even if the code hasn't changed (bypasses patch-ID cache)"
        required: false
        type: boolean
        default: false

      model:
        description: "Claude model to use for review"
        required: false
        type: string
        default: "claude-sonnet-4-5-20250929"

      max_turns:
        description: "Maximum conversation turns for Claude. Omit to use unlimited turns."
        required: false
        type: number

      timeout_minutes:
        description: "Job timeout in minutes"
        required: false
        type: number
        default: 30

      allowed_tools:
        description: 'Comma-separated list of allowed tools for Claude (e.g., "Read,Grep,Glob"). Leave empty for default read-only set.'
        required: false
        type: string
        default: ""

      toolkit_ref:
        description: "Git ref (branch, tag, or SHA) of ai-toolkit to use for the post-review script. Defaults to 'main'. Use 'next' or a specific SHA to test unreleased changes."
        required: false
        type: string
        default: "main"

      prompt_override_files_to_skip:
        description: |
          Path to a markdown file in the repository that overrides the "Files to Skip" section.
          Example: .claude/prompts/review-files-to-skip.md
        required: false
        type: string
        default: ""

      prompt_override_review_priorities:
        description: |
          Path to a markdown file in the repository that overrides the "Review Priorities" section.
          Example: .claude/prompts/review-priorities.md
        required: false
        type: string
        default: ""

      prompt_override_communication_style:
        description: |
          Path to a markdown file in the repository that overrides the "Communication Style" section.
          Example: .claude/prompts/review-communication-style.md
        required: false
        type: string
        default: ""

      prompt_override_pattern_recognition:
        description: |
          Path to a markdown file in the repository that overrides the "Pattern Recognition" section.
          Example: .claude/prompts/review-pattern-recognition.md
        required: false
        type: string
        default: ""

    secrets:
      ANTHROPIC_API_KEY:
        description: "Anthropic API key for Claude access"
        required: true
      WORKFLOW_PAT:
        description: "Personal Access Token with repo scope. Only needed for resolving review threads via GraphQL API (falls back to GITHUB_TOKEN if not provided)."
        required: false

jobs:
  claude-review:
    runs-on: ubuntu-latest
    timeout-minutes: ${{ inputs.timeout_minutes }}

    # Fixed permissions (cannot be overridden by calling workflow)
    permissions:
      id-token: write # Required for OIDC
      contents: read # Required to read repository code
      pull-requests: write # Required to comment and submit reviews
      issues: read # Required to read PR discussions
      actions: read # Required to check CI status

    steps:
      # Security scanning (required for all workflows)
      - name: Security Scan
        uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4
        with:
          egress-policy: audit

      # Fetch PR metadata via API:
      # - head_sha: Checkout the exact PR commit (not GitHub's merge commit)
      # - base_ref: Use provided value or fetch from API (makes base_ref input optional)
      - name: Get PR Info
        id: pr-info
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ inputs.pr_number }}
          INPUT_BASE_REF: ${{ inputs.base_ref }}
        run: |
          echo "‚ÑπÔ∏è  Fetching PR #$PR_NUMBER info..."

          # Fetch PR data once
          PR_DATA=$(gh api repos/${{ github.repository }}/pulls/$PR_NUMBER)

          # Extract head SHA (always needed)
          HEAD_SHA=$(echo "$PR_DATA" | jq -r '.head.sha')
          echo "head_sha=$HEAD_SHA" >> $GITHUB_OUTPUT
          echo "üìç PR head SHA: $HEAD_SHA"

          # Use provided base_ref or fetch from API
          if [ -n "$INPUT_BASE_REF" ]; then
            BASE_REF="$INPUT_BASE_REF"
            echo "üìç Base ref (from input): $BASE_REF"
          else
            BASE_REF=$(echo "$PR_DATA" | jq -r '.base.ref')
            echo "üìç Base ref (from API): $BASE_REF"
          fi
          echo "base_ref=$BASE_REF" >> $GITHUB_OUTPUT

      # Checkout the exact PR head commit (not GitHub's merge commit)
      - name: Checkout Repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ steps.pr-info.outputs.head_sha }}
          fetch-depth: 0 # Full history needed for accurate diff calculation

      # Setup Node.js early so we can post status updates
      - name: Setup Node.js (Early)
        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af # v4.1.0
        with:
          node-version: "22"

      # Download or use local post-review script (needed for status updates)
      - name: Setup Post Review Script (Early)
        id: setup-script-early
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          TOOLKIT_REF: ${{ inputs.toolkit_ref }}
        run: |
          set -euo pipefail

          # Check if we're running from the ai-toolkit repository
          if [ "$GITHUB_REPOSITORY" = "Uniswap/ai-toolkit" ]; then
            echo "‚ÑπÔ∏è  Running from ai-toolkit - using local post-review.ts"
            echo "script_path=.github/scripts/post-review.ts" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è  Running from external repository - downloading post-review.ts from Uniswap/ai-toolkit"
            echo "‚ÑπÔ∏è  Using toolkit ref: $TOOLKIT_REF"

            # Download the script from ai-toolkit repository (public repo, no auth needed)
            if ! curl -fSs \
                      -H "Accept: application/vnd.github.v4.raw" \
                      -L "https://api.github.com/repos/Uniswap/ai-toolkit/contents/.github/scripts/post-review.ts?ref=${TOOLKIT_REF}" \
                      -o /tmp/post-review.ts 2>&1 | tee /tmp/curl-error.log; then
              echo "‚ùå Failed to download post-review.ts from Uniswap/ai-toolkit@${TOOLKIT_REF}"
              echo "   Error details:"
              cat /tmp/curl-error.log | head -5
              exit 1
            fi

            echo "‚úÖ Downloaded post-review.ts from SHA: $TOOLKIT_REF"
            echo "script_path=/tmp/post-review.ts" >> $GITHUB_OUTPUT
          fi

      # Calculate patch-ID (stable hash of code changes, survives rebases)
      # This must run BEFORE posting in-progress so we can check cache first
      - name: Calculate Patch ID
        id: patch-id
        env:
          BASE_REF: ${{ steps.pr-info.outputs.base_ref }}
        run: |
          # Find where the PR branch diverged from the base branch
          # HEAD is the PR head commit (checked out via pr-info step)
          MERGE_BASE=$(git merge-base origin/$BASE_REF HEAD)
          echo "merge_base=$MERGE_BASE" >> $GITHUB_OUTPUT

          # Calculate stable patch-ID (same code = same ID, even after rebase)
          # This diff contains ONLY the PR's changes, not other commits merged to base
          PATCH_ID=$(git diff ${MERGE_BASE}..HEAD | git patch-id --stable | cut -d' ' -f1)

          echo "patch_id=$PATCH_ID" >> $GITHUB_OUTPUT
          echo "üìä Patch-ID: ${PATCH_ID:0:12}... (first 12 chars)"
          echo "üìç Merge base: $MERGE_BASE"
          echo "   This ID stays the same across rebases if code hasn't changed"

      # Check cache BEFORE posting in-progress to preserve existing review
      # Skip cache check entirely when force_review is enabled
      - name: Check Review Cache
        id: cache-check
        if: inputs.force_review != true
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: .review-cache
          key: review-pr${{ inputs.pr_number }}-patch-${{ steps.patch-id.outputs.patch_id }}
          lookup-only: true # Just check, don't restore

      # Early exit if we've already reviewed this code (rebase detected)
      # Never skip when force_review is enabled
      # IMPORTANT: This runs BEFORE posting in-progress to preserve existing review content
      - name: Skip Review if No Changes
        if: steps.cache-check.outputs.cache-hit == 'true' && inputs.force_review != true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ inputs.pr_number }}
          POST_REVIEW_SCRIPT: ${{ steps.setup-script-early.outputs.script_path }}
        run: |
          echo "‚úÖ Skipping review - no actual code changes detected"
          echo ""
          echo "This push appears to be a rebase or merge without new code changes."
          echo "Patch-ID: ${{ steps.patch-id.outputs.patch_id }}"
          echo ""
          echo "We've already reviewed this exact code, so skipping to save API costs."
          echo ""
          echo "üí° To force a new review, use the manual trigger with force_review: true"

          # Add status banner to existing review (preserving full content)
          echo ""
          echo "‚ÑπÔ∏è  Adding 'still valid' status banner to existing review..."

          REPO_OWNER=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f1)
          REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2)

          npx tsx "$POST_REVIEW_SCRIPT" \
            --mode skipped \
            --owner "$REPO_OWNER" \
            --repo "$REPO_NAME" \
            --pr-number "$PR_NUMBER"

          echo "‚úÖ Review preserved with status banner"
          exit 0

      # Log when force review is enabled
      - name: Force Review Enabled
        if: inputs.force_review == true
        run: |
          echo "üîÑ Force review enabled - bypassing cache check"
          echo "   A full review will run regardless of previous reviews for this code"

      # Detect trivial PRs for fast-path review
      # Only runs if we're actually going to do a review (not cached)
      - name: Detect Trivial PR
        id: pr-size
        if: steps.cache-check.outputs.cache-hit != 'true'
        env:
          MERGE_BASE: ${{ steps.patch-id.outputs.merge_base }}
        run: |
          # Reuse merge base from patch-id step (already calculated)
          echo "üìç Using merge base from patch-id step: $MERGE_BASE"

          # Count lines changed (additions + deletions)
          STATS=$(git diff --shortstat ${MERGE_BASE}..HEAD)

          # Extract insertions and deletions, default to 0 if not present
          INSERTIONS=$(echo "$STATS" | grep -oP '\d+(?= insertion)' || echo "0")
          DELETIONS=$(echo "$STATS" | grep -oP '\d+(?= deletion)' || echo "0")
          TOTAL_CHANGES=$((INSERTIONS + DELETIONS))

          echo "lines_changed=$TOTAL_CHANGES" >> $GITHUB_OUTPUT
          echo "üìä Total lines changed: $TOTAL_CHANGES"

          # Determine if this is a trivial PR (< 20 lines changed)
          if [ "$TOTAL_CHANGES" -lt 20 ]; then
            echo "is_trivial=true" >> $GITHUB_OUTPUT
            echo "‚ú® Trivial PR detected (< 20 lines) - will use fast review mode"
          else
            echo "is_trivial=false" >> $GITHUB_OUTPUT
            echo "üìù Standard PR - will use comprehensive review mode"
          fi

      # Post "Review in Progress" comment ONLY if we're actually going to review
      # This runs AFTER cache check to preserve existing review on cache hits
      - name: Post Review In Progress
        id: in-progress
        if: steps.cache-check.outputs.cache-hit != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ inputs.pr_number }}
          POST_REVIEW_SCRIPT: ${{ steps.setup-script-early.outputs.script_path }}
        run: |
          set -euo pipefail

          echo "‚ÑπÔ∏è  Posting 'review in progress' status..."

          # Parse owner and repo
          REPO_OWNER=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f1)
          REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2)

          # Post in-progress comment (creates or updates the bot's comment)
          npx tsx "$POST_REVIEW_SCRIPT" \
            --mode in-progress \
            --owner "$REPO_OWNER" \
            --repo "$REPO_NAME" \
            --pr-number "$PR_NUMBER"

          echo "‚úÖ In-progress status posted"

      # Fetch existing review comments for context
      - name: Fetch Existing Review Comments
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: existing-comments
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          echo "‚ÑπÔ∏è  Fetching existing review comments for context..."

          # Get existing review comments (for re-review context)
          COMMENTS=$(gh api "/repos/${GITHUB_REPOSITORY}/pulls/${PR_NUMBER}/comments" \
            --jq '[.[] | {id: .id, path: .path, line: .line, body: .body, user: .user.login}]' || echo "[]")

          # Save to file for prompt inclusion
          echo "$COMMENTS" > /tmp/existing-comments.json

          COMMENT_COUNT=$(echo "$COMMENTS" | jq 'length')
          echo "existing_comment_count=$COMMENT_COUNT" >> $GITHUB_OUTPUT

          if [ "$COMMENT_COUNT" -gt 0 ]; then
            echo "‚ÑπÔ∏è  Found $COMMENT_COUNT existing review comment(s)"
          else
            echo "‚ÑπÔ∏è  No existing review comments found (initial review)"
          fi

      # Generate the PR diff for Claude to review
      # This ensures Claude reviews ONLY the PR's changes, not other commits merged to main
      - name: Generate PR Diff
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: pr-diff
        env:
          MERGE_BASE: ${{ steps.patch-id.outputs.merge_base }}
        run: |
          set -euo pipefail

          echo "‚ÑπÔ∏è  Generating PR diff..."

          # Reuse merge base from patch-id step (already calculated)
          # This ensures consistency across all steps using the merge base
          echo "üìç Using merge base from patch-id step: $MERGE_BASE"

          # Generate the list of changed files (for reference)
          CHANGED_FILES=$(git diff --name-only ${MERGE_BASE}..HEAD)
          FILE_COUNT=$(echo "$CHANGED_FILES" | grep -c . || echo "0")
          echo "üìÅ Files changed: $FILE_COUNT"

          # Generate the full diff
          # This is the ONLY diff Claude should review - it contains exactly the PR's changes
          git diff ${MERGE_BASE}..HEAD > /tmp/pr-diff.txt

          DIFF_SIZE=$(wc -c < /tmp/pr-diff.txt)
          echo "üìä Diff size: $DIFF_SIZE bytes"

          # Save changed files list
          echo "$CHANGED_FILES" > /tmp/changed-files.txt

          echo "‚úÖ PR diff generated successfully"

      # Build final prompt from modular section files
      - name: Build Review Prompt
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: build-prompt
        env:
          OVERRIDE_FILES_TO_SKIP: ${{ inputs.prompt_override_files_to_skip }}
          OVERRIDE_REVIEW_PRIORITIES: ${{ inputs.prompt_override_review_priorities }}
          OVERRIDE_COMMUNICATION_STYLE: ${{ inputs.prompt_override_communication_style }}
          OVERRIDE_PATTERN_RECOGNITION: ${{ inputs.prompt_override_pattern_recognition }}
          WORKFLOW_PAT: ${{ secrets.WORKFLOW_PAT }}
          REPO: ${{ github.repository }}
          PR_NUMBER: ${{ inputs.pr_number }}
          BASE_REF: ${{ steps.pr-info.outputs.base_ref }}
          PATCH_ID: ${{ steps.patch-id.outputs.patch_id }}
          EXISTING_COMMENT_COUNT: ${{ steps.existing-comments.outputs.existing_comment_count }}
          TOOLKIT_REF: ${{ inputs.toolkit_ref }}
          MERGE_BASE: ${{ steps.patch-id.outputs.merge_base }}
          LINES_CHANGED: ${{ steps.pr-size.outputs.lines_changed }}
          IS_TRIVIAL: ${{ steps.pr-size.outputs.is_trivial }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          # =====================================================================
          # File-based prompt assembly from modular section files
          # =====================================================================
          # The prompt is assembled from files in .github/prompts/pr-review/:
          #   - fixed/     : Always-included sections (numbered 1-3, 8-16)
          #   - overridable/ : Sections that can be replaced (numbered 4-7)
          #
          # Template variables (${VAR}) are substituted using envsubst.
          # =====================================================================

          echo "üìù Building prompt from modular section files"

          # Parse repository owner and name
          REPO_OWNER=$(echo "$REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$REPO" | cut -d'/' -f2)

          # Export all template variables for envsubst
          export REPO_OWNER REPO_NAME PR_NUMBER BASE_REF PATCH_ID MERGE_BASE LINES_CHANGED

          # Read dynamic content for template substitution
          export CHANGED_FILES
          CHANGED_FILES=$(cat /tmp/changed-files.txt)
          export PR_DIFF
          PR_DIFF=$(cat /tmp/pr-diff.txt)
          export EXISTING_COMMENTS_JSON
          EXISTING_COMMENTS_JSON=$(cat /tmp/existing-comments.json 2>/dev/null || echo "[]")

          # Create temp directory for downloaded files
          PROMPT_DIR="/tmp/pr-review-prompts"
          mkdir -p "$PROMPT_DIR/fixed" "$PROMPT_DIR/overridable"

          # Function to fetch a file from ai-toolkit repository
          fetch_prompt_file() {
            local remote_path="$1"
            local local_path="$2"

            if [ "$GITHUB_REPOSITORY" = "Uniswap/ai-toolkit" ]; then
              # Running from ai-toolkit - use local files
              local local_file=".github/prompts/pr-review/${remote_path}"
              if [ -f "$local_file" ]; then
                cp "$local_file" "$local_path"
                return 0
              else
                echo "::warning::Local file not found: $local_file"
                return 1
              fi
            else
              # Fetch from ai-toolkit repository
              if ! curl -fSs -H "Authorization: token $WORKFLOW_PAT" \
                        -H "Accept: application/vnd.github.v4.raw" \
                        -L "https://api.github.com/repos/Uniswap/ai-toolkit/contents/.github/prompts/pr-review/${remote_path}?ref=${TOOLKIT_REF}" \
                        -o "$local_path" 2>/dev/null; then
                echo "::warning::Failed to fetch: $remote_path"
                return 1
              fi
            fi
            return 0
          }

          # Function to process a section file (substitute vars and append)
          process_section() {
            local file="$1"
            local output="$2"

            if [ ! -f "$file" ]; then
              echo "::warning::Section file not found: $file"
              return 1
            fi

            # Use envsubst to replace template variables
            envsubst < "$file" >> "$output"
            echo "" >> "$output"  # Blank line between sections
          }

          # Initialize final prompt file
          FINAL_PROMPT="/tmp/final-prompt.txt"
          > "$FINAL_PROMPT"

          echo "üì• Fetching prompt section files..."

          # =====================================================================
          # Section 1-2: Fixed sections (workflow-injected context)
          # =====================================================================
          fetch_prompt_file "fixed/1-review-context.md" "$PROMPT_DIR/fixed/1-review-context.md"
          fetch_prompt_file "fixed/2-diff-instructions.md" "$PROMPT_DIR/fixed/2-diff-instructions.md"

          process_section "$PROMPT_DIR/fixed/1-review-context.md" "$FINAL_PROMPT"
          process_section "$PROMPT_DIR/fixed/2-diff-instructions.md" "$FINAL_PROMPT"
          echo "‚úÖ Added sections 1-2 (review context, diff instructions)"

          # =====================================================================
          # Section 3: Repository context (from default-pr-review.md)
          # =====================================================================
          fetch_prompt_file "fixed/3-repository-context.md" "$PROMPT_DIR/fixed/3-repository-context.md"
          process_section "$PROMPT_DIR/fixed/3-repository-context.md" "$FINAL_PROMPT"
          echo "‚úÖ Added section 3 (repository context)"

          # =====================================================================
          # Sections 4-7: Overridable sections
          # =====================================================================
          # Map section names to their override input variables
          declare -A OVERRIDE_MAP=(
            ["4-review-priorities"]="$OVERRIDE_REVIEW_PRIORITIES"
            ["5-files-to-skip"]="$OVERRIDE_FILES_TO_SKIP"
            ["6-communication-style"]="$OVERRIDE_COMMUNICATION_STYLE"
            ["7-pattern-recognition"]="$OVERRIDE_PATTERN_RECOGNITION"
          )

          OVERRIDES_APPLIED=0
          for section in "4-review-priorities" "5-files-to-skip" "6-communication-style" "7-pattern-recognition"; do
            override_file="${OVERRIDE_MAP[$section]}"

            if [ -n "$override_file" ] && [ -f "$override_file" ]; then
              # Use consumer's override file
              echo "üìù Using override for $section: $override_file"
              process_section "$override_file" "$FINAL_PROMPT"
              ((OVERRIDES_APPLIED++))
            else
              # Use default from ai-toolkit
              fetch_prompt_file "overridable/${section}.md" "$PROMPT_DIR/overridable/${section}.md"
              process_section "$PROMPT_DIR/overridable/${section}.md" "$FINAL_PROMPT"
            fi
          done

          if [ "$OVERRIDES_APPLIED" -gt 0 ]; then
            echo "‚úÖ Applied $OVERRIDES_APPLIED section override(s)"
          fi
          echo "‚úÖ Added sections 4-7 (review priorities, files to skip, communication style, pattern recognition)"

          # =====================================================================
          # Sections 8-12: Fixed sections (review process, inline comment rules, etc.)
          # =====================================================================
          for section_num in 8 9 10 11 12; do
            # Find the file with this number prefix
            case $section_num in
              8) section_name="8-review-process.md" ;;
              9) section_name="9-inline-comment-rules.md" ;;
              10) section_name="10-important-notes.md" ;;
              11) section_name="11-comment-examples.md" ;;
              12) section_name="12-avoid-patterns.md" ;;
            esac

            fetch_prompt_file "fixed/${section_name}" "$PROMPT_DIR/fixed/${section_name}"
            process_section "$PROMPT_DIR/fixed/${section_name}" "$FINAL_PROMPT"
          done
          echo "‚úÖ Added sections 8-12 (review process, inline rules, notes, examples, avoid patterns)"

          # =====================================================================
          # Section 13: Existing comments (conditional - only for re-reviews)
          # =====================================================================
          if [ "$EXISTING_COMMENT_COUNT" -gt 0 ]; then
            fetch_prompt_file "fixed/13-existing-comments.md" "$PROMPT_DIR/fixed/13-existing-comments.md"
            process_section "$PROMPT_DIR/fixed/13-existing-comments.md" "$FINAL_PROMPT"
            echo "‚úÖ Added section 13 (existing comments for re-review)"
          fi

          # =====================================================================
          # Section 14: Fast review mode (conditional - only for trivial PRs)
          # =====================================================================
          if [ "$IS_TRIVIAL" = "true" ]; then
            fetch_prompt_file "fixed/14-fast-review-mode.md" "$PROMPT_DIR/fixed/14-fast-review-mode.md"
            process_section "$PROMPT_DIR/fixed/14-fast-review-mode.md" "$FINAL_PROMPT"
            echo "‚úÖ Added section 14 (fast review mode for trivial PR)"
          fi

          # =====================================================================
          # Section 15-16: Verdict rules and output guidance (always included)
          # =====================================================================
          fetch_prompt_file "fixed/15-verdict-rules.md" "$PROMPT_DIR/fixed/15-verdict-rules.md"
          fetch_prompt_file "fixed/16-output-guidance.md" "$PROMPT_DIR/fixed/16-output-guidance.md"

          process_section "$PROMPT_DIR/fixed/15-verdict-rules.md" "$FINAL_PROMPT"
          process_section "$PROMPT_DIR/fixed/16-output-guidance.md" "$FINAL_PROMPT"
          echo "‚úÖ Added sections 15-16 (verdict rules, output guidance)"

          # =====================================================================
          # Finalize and export
          # =====================================================================
          PROMPT_LENGTH=$(wc -c < "$FINAL_PROMPT")
          echo "‚úÖ Built final prompt: $PROMPT_LENGTH characters"

          # Export as output for next step
          {
            echo "final_prompt<<PROMPT_DELIMITER_EOF"
            cat "$FINAL_PROMPT"
            echo "PROMPT_DELIMITER_EOF"
          } >> $GITHUB_OUTPUT

          # Show first few lines for debugging
          echo ""
          echo "üìÑ Prompt preview (first 15 lines):"
          head -n 15 "$FINAL_PROMPT"

      # Build Claude arguments - READ-ONLY tools only (no GitHub write tools)
      - name: Build Claude Arguments
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: build-args
        env:
          INPUT_ALLOWED_TOOLS: ${{ inputs.allowed_tools }}
          INPUT_MAX_TURNS: ${{ inputs.max_turns }}
          INPUT_MODEL: ${{ inputs.model }}
        run: |
          # Build allowed tools list - READ-ONLY tools only
          # Claude outputs JSON, the post-review script handles GitHub writes
          if [ -n "$INPUT_ALLOWED_TOOLS" ]; then
            ALLOWED_TOOLS="$INPUT_ALLOWED_TOOLS"
          else
            # Define read-only tools for analysis
            TOOLS=(
              # File operations (read-only)
              "Read"
              "Grep"
              "Glob"

              # Git commands for context (read-only)
              "Bash(git log:*)"
              "Bash(git diff:*)"
              "Bash(git show:*)"
              "Bash(git blame:*)"
              "Bash(git rev-parse:*)"

              # GitHub MCP tools (read-only, for fetching PR context)
              "mcp__github__get_pull_request"
              "mcp__github__get_pull_request_files"
              "mcp__github__get_pull_request_comments"
              "mcp__github__get_pull_request_reviews"
            )

            # Join array elements with commas (no spaces)
            ALLOWED_TOOLS=$(IFS=,; echo "${TOOLS[*]}")
          fi

          # Define JSON schema for structured output
          # This ensures Claude returns validated JSON matching our expected format
          JSON_SCHEMA='{
            "type": "object",
            "properties": {
              "pr_review_body": {
                "type": "string",
                "description": "Markdown-formatted review summary with all analysis"
              },
              "pr_review_outcome": {
                "type": "string",
                "enum": ["COMMENT", "APPROVE", "REQUEST_CHANGES"],
                "description": "Review decision"
              },
              "inline_comments_new": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "path": { "type": "string", "description": "File path" },
                    "line": { "type": "integer", "description": "Line number" },
                    "body": { "type": "string", "description": "Comment text" },
                    "suggestion": { "type": "string", "description": "Optional code suggestion" }
                  },
                  "required": ["path", "line", "body"]
                },
                "description": "New inline comments on specific lines"
              },
              "inline_comments_responses": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "comment_id": { "type": "integer", "description": "ID of existing comment" },
                    "body": { "type": "string", "description": "Response text" },
                    "should_resolve": { "type": "boolean", "description": "Whether to resolve the thread" }
                  },
                  "required": ["comment_id", "body"]
                },
                "description": "Responses to existing review comments"
              },
              "files_reviewed": {
                "type": "array",
                "items": { "type": "string" },
                "description": "List of files reviewed"
              },
              "confidence": {
                "type": "number",
                "minimum": 0,
                "maximum": 1,
                "description": "Confidence level (0.0-1.0)"
              }
            },
            "required": ["pr_review_body", "pr_review_outcome", "inline_comments_new"]
          }'

          # Build claude_args conditionally based on provided inputs
          CLAUDE_ARGS="--model $INPUT_MODEL"

          # Only add --max-turns if explicitly provided (not empty)
          if [ -n "$INPUT_MAX_TURNS" ]; then
            CLAUDE_ARGS="$CLAUDE_ARGS
            --max-turns $INPUT_MAX_TURNS"
            echo "‚ÑπÔ∏è  Including --max-turns $INPUT_MAX_TURNS"
          else
            echo "‚ÑπÔ∏è  Omitting --max-turns (unlimited turns)"
          fi

          # Add JSON schema for structured output (ensures validated JSON response)
          # Compact the schema to a single line for the CLI argument
          COMPACT_SCHEMA=$(echo "$JSON_SCHEMA" | jq -c .)
          CLAUDE_ARGS="$CLAUDE_ARGS
            --json-schema '$COMPACT_SCHEMA'
            --allowedTools $ALLOWED_TOOLS"

          echo "allowed_tools=$ALLOWED_TOOLS" >> $GITHUB_OUTPUT
          echo "claude_args<<CLAUDE_ARGS_EOF" >> $GITHUB_OUTPUT
          echo "$CLAUDE_ARGS" >> $GITHUB_OUTPUT
          echo "CLAUDE_ARGS_EOF" >> $GITHUB_OUTPUT
          echo "‚úÖ Configured structured output with JSON schema"
          echo "‚úÖ Configured read-only tools (${#ALLOWED_TOOLS} chars)"

      # Run Claude Code Action to perform the review (analysis only, outputs JSON)
      - name: Run Claude Code Review
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: claude
        uses: anthropics/claude-code-action@a7e4c51380c42dd89b127f5e5f9be7b54020bc6b # v1.0.21
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          prompt: ${{ steps.build-prompt.outputs.final_prompt }}
          # Disable built-in progress tracking - we handle our own PR comments
          track_progress: false
          # Show full Claude output in logs for debugging
          show_full_output: false
          allowed_bots: dependabot
          claude_args: ${{ steps.build-args.outputs.claude_args }}
          additional_permissions: |
            actions: read

      # Note: Node.js is already set up earlier for posting in-progress status

      # Extract Claude's structured output (validated JSON from --json-schema)
      - name: Extract Claude Response
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        id: extract-response
        env:
          STRUCTURED_OUTPUT: ${{ steps.claude.outputs.structured_output }}
        run: |
          set -euo pipefail

          echo "‚ÑπÔ∏è  Extracting structured output from Claude..."

          # The structured_output is already validated JSON from --json-schema
          if [ -z "$STRUCTURED_OUTPUT" ]; then
            echo "‚ùå No structured_output from Claude"
            echo "   This may indicate the --json-schema flag wasn't processed correctly"
            exit 1
          fi

          # Save the structured output for the post-review script
          echo "$STRUCTURED_OUTPUT" > /tmp/claude-review-response.txt
          echo "‚úÖ Extracted structured output (${#STRUCTURED_OUTPUT} chars)"

          # Show preview and validate it's proper JSON
          echo "üìã Response preview:"
          echo "$STRUCTURED_OUTPUT" | jq -r '.pr_review_outcome // "unknown"' | xargs -I{} echo "  Outcome: {}"
          echo "$STRUCTURED_OUTPUT" | jq -r '.inline_comments_new | length' | xargs -I{} echo "  Inline comments: {}"
          echo "$STRUCTURED_OUTPUT" | jq -r '.confidence // "not set"' | xargs -I{} echo "  Confidence: {}"

      # Upload Claude execution output as artifact for debugging
      - name: Upload Claude Execution Output
        if: steps.cache-check.outputs.cache-hit != 'true' && always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: claude-execution-output-pr${{ inputs.pr_number }}
          path: /home/runner/work/_temp/claude-execution-output.json
          retention-days: 7
          if-no-files-found: warn

      # Note: Post-review script is already downloaded/located earlier for in-progress status

      # Post the review using our script (all comments as github-actions[bot])
      - name: Post Review via Script
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        id: post-review
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # WORKFLOW_PAT is used for GraphQL operations (resolving review threads)
          # that require elevated permissions beyond what GITHUB_TOKEN provides
          GH_TOKEN_FOR_GRAPHQL: ${{ secrets.WORKFLOW_PAT || secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          # Pass file path instead of content to avoid shell injection risks
          # The script reads the file directly, avoiding shell expansion of content
          REVIEW_JSON_FILE: /tmp/claude-review-response.txt
          # Script path determined by early setup step (local or downloaded)
          POST_REVIEW_SCRIPT: ${{ steps.setup-script-early.outputs.script_path }}
        run: |
          set -euo pipefail

          echo "‚ÑπÔ∏è  Parsing Claude's review output and posting to GitHub..."
          echo "‚ÑπÔ∏è  Using script: $POST_REVIEW_SCRIPT"

          # Parse owner and repo
          REPO_OWNER=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f1)
          REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2)

          # Verify the response file exists
          if [ ! -f "$REVIEW_JSON_FILE" ]; then
            echo "‚ùå No review response file found at $REVIEW_JSON_FILE"
            exit 1
          fi

          # Check that the file has content
          if [ ! -s "$REVIEW_JSON_FILE" ]; then
            echo "‚ùå No review output from Claude (file is empty)"
            exit 1
          fi

          echo "‚ÑπÔ∏è  Review response length: $(wc -c < "$REVIEW_JSON_FILE") bytes"

          # Run the post-review script (path from setup-script step)
          # REVIEW_JSON_FILE env var is passed to the script, which reads the file directly
          # This avoids shell expansion of file content (shell injection safe)
          npx tsx "$POST_REVIEW_SCRIPT" \
            --owner "$REPO_OWNER" \
            --repo "$REPO_NAME" \
            --pr-number "$PR_NUMBER"

          echo "‚úÖ Review posted successfully"

      # Fallback: Post review summary as PR comment if script fails
      - name: Fallback Review Comment
        if: steps.cache-check.outputs.cache-hit != 'true' && failure()
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: |
          set -euo pipefail

          echo "‚ö†Ô∏è  Script failed, posting Claude's output as comment fallback..."

          COMMENT_MARKER="<!-- claude-pr-review-bot -->"
          JOB_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          # Try to read the extracted response, fallback to execution file
          if [ -f /tmp/claude-review-response.txt ]; then
            SUMMARY=$(cat /tmp/claude-review-response.txt)
          elif [ -f /home/runner/work/_temp/claude-execution-output.json ]; then
            SUMMARY=$(cat /home/runner/work/_temp/claude-execution-output.json | head -c 10000)
          else
            SUMMARY="No review output available"
          fi

          # Generate fallback comment
          COMMENT_BODY=$(cat <<EOF
          ${COMMENT_MARKER}
          ## ü§ñ Claude Code Review

          **Status:** ‚ö†Ô∏è Partial (script error)
          **Job:** [View workflow run](${JOB_URL})

          ---

          The review was completed but there was an error posting inline comments.

          <details>
          <summary>Raw Review Output</summary>

          \`\`\`
          ${SUMMARY:0:10000}
          \`\`\`

          </details>

          ---

          *Please check the workflow logs for details.*
          EOF
          )

          # Post as PR comment
          gh api "/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" \
            -X POST \
            -f body="$COMMENT_BODY" \
            > /dev/null

          echo "‚úÖ Fallback comment posted"

      # Post error comment if Claude completely fails (no output at all)
      - name: Post Review Error Comment
        if: steps.cache-check.outputs.cache-hit != 'true' && failure() && steps.claude.conclusion == 'failure'
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          COMMENT_MARKER="<!-- claude-pr-review-bot -->"
          JOB_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          echo "‚ÑπÔ∏è  Posting review error comment" >&2

          # Generate error comment body
          COMMENT_BODY=$(cat <<EOF
          ${COMMENT_MARKER}
          ## ü§ñ Claude Code Review

          **Status:** ‚ùå Error
          **Job:** [View workflow run](${JOB_URL})

          ---

          ### ‚ö†Ô∏è Review Failed

          The automated code review encountered an error and could not complete.

          **Next Steps:**
          1. Check the [workflow logs](${JOB_URL}) for details
          2. Verify the GitHub Actions configuration
          3. Ensure the Anthropic API key is valid
          4. Check for any permission issues

          If the problem persists, please contact your repository administrator.

          ---

          *You can manually re-trigger the review by pushing a new commit or re-running the workflow.*
          EOF
          )

          # Post comment
          gh api "/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" \
            -X POST \
            -f body="$COMMENT_BODY" \
            > /dev/null

          echo "‚úÖ Error comment posted" >&2

      # Save successful review to cache
      - name: Save Review Cache Marker
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        run: |
          mkdir -p .review-cache
          echo "${{ steps.patch-id.outputs.patch_id }}" > .review-cache/patch-id
          echo "Cached review for patch-ID: ${{ steps.patch-id.outputs.patch_id }}"

      # Persist cache for future rebase detection
      - name: Cache Review State
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        uses: actions/cache/save@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: .review-cache
          key: review-pr${{ inputs.pr_number }}-patch-${{ steps.patch-id.outputs.patch_id }}
