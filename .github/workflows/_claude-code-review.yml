name: '[claude] Claude Code Review'

# Reusable workflow for automated PR code reviews using Claude AI
#
# This workflow provides comprehensive code reviews with:
# - Formal GitHub reviews (APPROVE/REQUEST_CHANGES/COMMENT)
# - Inline comments on specific lines of code
# - Auto-resolution of comments when issues are fixed
# - Patch-ID based caching to skip rebases
# - Custom prompt support
#
# USAGE:
#   uses: Uniswap/ai-toolkit/.github/workflows/_claude-code-review.yml@main
#   with:
#     pr_number: ${{ github.event.pull_request.number }}
#     base_ref: ${{ github.base_ref }}
#   secrets:
#     ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
#
# FEATURES:
# - Runs on every push but skips rebases (patch-ID detection)
# - Creates inline comments like human reviewers
# - Tracks and resolves previous comments
# - Submits formal reviews for merge protection
# - Supports custom prompts
#
# PERMISSIONS REQUIRED (calling workflow must grant these):
#   contents: read
#   pull-requests: write
#   issues: read
#   actions: read
#   id-token: write

on:
  workflow_call:
    inputs:
      pr_number:
        description: 'Pull request number to review'
        required: true
        type: string

      base_ref:
        description: 'Base branch name (e.g., main, master)'
        required: true
        type: string

      model:
        description: 'Claude model to use for review'
        required: false
        type: string
        default: 'claude-sonnet-4-5-20250929'

      max_turns:
        description: 'Maximum conversation turns for Claude. Omit to use unlimited turns (may help with track_progress Issue #602).'
        required: false
        type: number

      custom_prompt:
        description: 'Custom prompt text (overrides prompt file and default). Verdict logic will be automatically appended.'
        required: false
        type: string
        default: ''

      custom_prompt_path:
        description: 'Path to custom prompt file in repository (e.g., .claude/prompts/claude-pr-bot.md)'
        required: false
        type: string
        default: '.claude/prompts/claude-pr-bot.md'

      timeout_minutes:
        description: 'Job timeout in minutes'
        required: false
        type: number
        default: 30

      allowed_tools:
        description: 'Comma-separated list of allowed tools for Claude (e.g., "Read,Grep,Glob,Bash(git log),Write"). Leave empty for default permissive set.'
        required: false
        type: string
        default: ''

    secrets:
      ANTHROPIC_API_KEY:
        description: 'Anthropic API key for Claude access'
        required: true

jobs:
  claude-review:
    runs-on: ubuntu-latest
    timeout-minutes: ${{ inputs.timeout_minutes }}

    # Fixed permissions (cannot be overridden by calling workflow)
    permissions:
      id-token: write # Required for OIDC
      contents: read # Required to read repository code
      pull-requests: write # Required to comment and submit reviews
      issues: read # Required to read PR discussions
      actions: read # Required to check CI status

    steps:
      # Security scanning (required for all workflows)
      - name: Security Scan
        uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4
        with:
          egress-policy: audit

      # Checkout code with full history for patch-ID calculation
      - name: Checkout Repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0 # Full history needed for git merge-base

      # Calculate patch-ID (stable hash of code changes, survives rebases)
      - name: Calculate Patch ID
        id: patch-id
        env:
          BASE_REF: ${{ inputs.base_ref }}
        run: |
          # Find the merge base between base branch and HEAD
          MERGE_BASE=$(git merge-base origin/$BASE_REF HEAD)

          # Calculate stable patch-ID (same code = same ID, even after rebase)
          PATCH_ID=$(git diff ${MERGE_BASE}..HEAD | git patch-id --stable | cut -d' ' -f1)

          echo "patch_id=$PATCH_ID" >> $GITHUB_OUTPUT
          echo "üìä Patch-ID: ${PATCH_ID:0:12}... (first 12 chars)"
          echo "   This ID stays the same across rebases if code hasn't changed"

      # Detect trivial PRs for fast-path review
      - name: Detect Trivial PR
        id: pr-size
        env:
          BASE_REF: ${{ inputs.base_ref }}
        run: |
          # Find the merge base between base branch and HEAD
          MERGE_BASE=$(git merge-base origin/$BASE_REF HEAD)

          # Count lines changed (additions + deletions)
          STATS=$(git diff --shortstat ${MERGE_BASE}..HEAD)

          # Extract insertions and deletions, default to 0 if not present
          INSERTIONS=$(echo "$STATS" | grep -oP '\d+(?= insertion)' || echo "0")
          DELETIONS=$(echo "$STATS" | grep -oP '\d+(?= deletion)' || echo "0")
          TOTAL_CHANGES=$((INSERTIONS + DELETIONS))

          echo "lines_changed=$TOTAL_CHANGES" >> $GITHUB_OUTPUT
          echo "üìä Total lines changed: $TOTAL_CHANGES"

          # Determine if this is a trivial PR (< 20 lines changed)
          if [ "$TOTAL_CHANGES" -lt 20 ]; then
            echo "is_trivial=true" >> $GITHUB_OUTPUT
            echo "‚ú® Trivial PR detected (< 20 lines) - will use fast review mode"
          else
            echo "is_trivial=false" >> $GITHUB_OUTPUT
            echo "üìù Standard PR - will use comprehensive review mode"
          fi

      # Check cache to see if we've already reviewed this exact code
      - name: Check Review Cache
        id: cache-check
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: .review-cache
          key: review-pr${{ inputs.pr_number }}-patch-${{ steps.patch-id.outputs.patch_id }}
          lookup-only: true # Just check, don't restore

      # Early exit if we've already reviewed this code (rebase detected)
      - name: Skip Review if No Changes
        if: steps.cache-check.outputs.cache-hit == 'true'
        run: |
          echo "‚úÖ Skipping review - no actual code changes detected"
          echo ""
          echo "This push appears to be a rebase or merge without new code changes."
          echo "Patch-ID: ${{ steps.patch-id.outputs.patch_id }}"
          echo ""
          echo "We've already reviewed this exact code, so skipping to save API costs."
          exit 0

      # Build final prompt with custom content + verdict injection
      - name: Build Review Prompt
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: build-prompt
        env:
          CUSTOM_PROMPT_INPUT: ${{ inputs.custom_prompt }}
          CUSTOM_PROMPT_PATH: ${{ inputs.custom_prompt_path }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          PR_NUMBER: ${{ inputs.pr_number }}
          BASE_REF: ${{ inputs.base_ref }}
          PATCH_ID: ${{ steps.patch-id.outputs.patch_id }}
        run: |
          CUSTOM_PROMPT=""

          # Priority 1: Explicit custom_prompt input
          if [ -n "$CUSTOM_PROMPT_INPUT" ]; then
            echo "üìù Using explicit custom prompt from workflow input"
            CUSTOM_PROMPT="$CUSTOM_PROMPT_INPUT"

          # Priority 2: Custom prompt file in repository
          elif [ -f "$CUSTOM_PROMPT_PATH" ]; then
            echo "üìù Using custom prompt from repository: $CUSTOM_PROMPT_PATH"
            CUSTOM_PROMPT=$(cat "$CUSTOM_PROMPT_PATH")

          # Priority 3: Default prompt from ai-toolkit repository
          else
            echo "üìù Fetching default prompt from Uniswap/ai-toolkit repository"

            # Fetch default prompt via GitHub API
            # -f: Fail on HTTP errors (status >= 400)
            # -S: Show errors even with -s
            # -s: Silent mode (no progress bar)
            if ! curl -fSs -H "Authorization: token $GITHUB_TOKEN" \
                      -H "Accept: application/vnd.github.v4.raw" \
                      -L "https://api.github.com/repos/Uniswap/ai-toolkit/contents/.github/prompts/default-pr-review.md" \
                      -o /tmp/default-prompt.md 2>&1 | tee /tmp/curl-error.log; then
              echo "‚ùå Failed to fetch default prompt from Uniswap/ai-toolkit"
              echo "   Error details:"
              cat /tmp/curl-error.log | head -5
              exit 1
            fi

            CUSTOM_PROMPT=$(cat /tmp/default-prompt.md)
            echo "‚úÖ Loaded default prompt from Uniswap/ai-toolkit"
          fi

          # Parse repository owner and name from REPO (format: owner/repo)
          REPO_OWNER=$(echo "$REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$REPO" | cut -d'/' -f2)

          # Build final prompt with context and verdict injection
          cat > /tmp/final-prompt.txt <<PROMPT_EOF
          # Review Context

          **Repository Owner:** $REPO_OWNER
          **Repository Name:** $REPO_NAME
          **PR Number:** $PR_NUMBER
          **Base Branch:** $BASE_REF
          **Patch ID:** $PATCH_ID

          ---

          PROMPT_EOF

          # Append custom prompt content
          echo "$CUSTOM_PROMPT" >> /tmp/final-prompt.txt

          # Append fast-review mode instructions for trivial PRs
          IS_TRIVIAL="${{ steps.pr-size.outputs.is_trivial }}"
          if [ "$IS_TRIVIAL" = "true" ]; then
            cat >> /tmp/final-prompt.txt <<TRIVIAL_MODE_EOF

          ---

          # üöÄ Fast Review Mode (Trivial PR)

          This PR has fewer than 20 lines of changes. Use an expedited review process:

          1. **Quick scan**: Review changed files briefly
          2. **Focus on critical issues only**: Bugs, security vulnerabilities, breaking changes
          3. **Skip comprehensive analysis**: Don't need detailed maintainability or improvement suggestions
          4. **Minimal inline comments**: If the PR only modifies auto-generated files (lockfiles, snapshots), skip inline comments entirely and just acknowledge in summary
          5. **Fast verdict**: Create verdict files and complete quickly

          **Goal**: Provide value while minimizing review cost for small changes.
          TRIVIAL_MODE_EOF
            echo "‚ú® Added fast-review mode instructions for trivial PR"
          fi

          # Append verdict writing requirements (always injected)
          cat >> /tmp/final-prompt.txt <<VERDICT_EOF

          ---

          # Required: Review Output

          After completing your review, you **MUST** create these two files in the GitHub workspace root directory:

          ## 1. \`\$GITHUB_WORKSPACE/.claude-review-verdict.txt\`

          **IMPORTANT:** Write this file to the full path: \`\$GITHUB_WORKSPACE/.claude-review-verdict.txt\`

          Contains ONLY one word (the verdict):
          - \`APPROVE\` - No blocking issues, safe to merge
          - \`REQUEST_CHANGES\` - Critical issues that must be fixed before merge
          - \`COMMENT\` - Moderate issues, non-blocking but should be addressed

          **Example file content:**
          \`\`\`
          APPROVE
          \`\`\`

          ## 2. \`\$GITHUB_WORKSPACE/.claude-review-summary.md\`

          **IMPORTANT:** Write this file to the full path: \`\$GITHUB_WORKSPACE/.claude-review-summary.md\`

          Your review summary in markdown format:

          ```markdown
          ## ü§ñ Claude Code Review

          **Status:** ‚úÖ Completed
          **Verdict:** [Your verdict: APPROVE/REQUEST_CHANGES/COMMENT]
          **Patch ID:** $PATCH_ID

          ### Summary
          [Brief overview of the PR and your assessment]

          ### Key Findings
          - [Important issue or observation 1]
          - [Important issue or observation 2]
          - [Important issue or observation 3]

          ### Inline Comments
          I've added [X] inline comments with detailed feedback on specific lines.
          Please review all comments and address the issues marked.

          [Optional: Any additional context or recommendations]
          ```

          **These files are required** for the formal GitHub review to be submitted.
          If you don't create them, the review will fail.
          VERDICT_EOF

          # Append final inline comment reminder (MUST be last thing in prompt)
          cat >> /tmp/final-prompt.txt <<INLINE_REMINDER_EOF

          ---

          # ‚ö†Ô∏è CRITICAL FINAL STEP: Create Inline Comments FIRST

          **BEFORE creating the verdict files above, you MUST:**

          1. Call \`mcp__github__create_pull_request_review\` with the \`comments\` array containing at least 1 inline comment
          2. Each comment needs: \`path\` (file path), \`line\` (line number), \`body\` (your feedback)
          3. ONLY AFTER inline comments are created, then create the verdict files

          **Example call you MUST make:**
          \`\`\`
          mcp__github__create_pull_request_review({
            owner: "$REPO_OWNER",
            repo: "$REPO_NAME",
            pull_number: $PR_NUMBER,
            body: "Review summary",
            event: "COMMENT",
            comments: [
              { path: "src/example.ts", line: 42, body: "Your feedback here" }
            ]
          })
          \`\`\`

          **Reviews without inline comments will be flagged as incomplete.**
          INLINE_REMINDER_EOF

          # Log final prompt length
          PROMPT_LENGTH=$(wc -c < /tmp/final-prompt.txt)
          echo "‚úÖ Built final prompt: $PROMPT_LENGTH characters"

          # Export as output for next step
          {
            echo "final_prompt<<PROMPT_DELIMITER_EOF"
            cat /tmp/final-prompt.txt
            echo "PROMPT_DELIMITER_EOF"
          } >> $GITHUB_OUTPUT

          # Show first few lines for debugging
          echo ""
          echo "üìÑ Prompt preview (first 10 lines):"
          head -n 10 /tmp/final-prompt.txt

      # Build Claude arguments with proper escaping for tool specifications
      - name: Build Claude Arguments
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: build-args
        env:
          INPUT_ALLOWED_TOOLS: ${{ inputs.allowed_tools }}
          INPUT_MAX_TURNS: ${{ inputs.max_turns }}
          INPUT_MODEL: ${{ inputs.model }}
        run: |
          # Build allowed tools list programmatically to avoid shell parsing issues
          if [ -n "$INPUT_ALLOWED_TOOLS" ]; then
            ALLOWED_TOOLS="$INPUT_ALLOWED_TOOLS"
          else
            # Define tools as array for better maintainability and to eliminate
            # shell string parsing nuances. Each tool is a separate array element.
            TOOLS=(
              # GitHub MCP tools for PR interaction
              "mcp__github__get_pull_request"
              "mcp__github__get_pull_request_files"
              "mcp__github__get_pull_request_diff"
              "mcp__github__get_pull_request_comments"
              "mcp__github__get_pull_request_reviews"
              "mcp__github__get_pull_request_review_comments"
              "mcp__github__create_review_comment"
              "mcp__github__resolve_review_thread"
              "mcp__github__list_review_comments"
              "mcp__github__create_pull_request_review"

              # File operations
              "Read"
              "Grep"
              "Glob"

              # Git commands (wildcard patterns allow any arguments/flags)
              "Bash(git log:*)"
              "Bash(git diff:*)"
              "Bash(git show:*)"
              "Bash(git blame:*)"
              "Bash(git rev-parse:*)"

              # File writing
              "Write"
            )

            # Join array elements with commas (no spaces)
            ALLOWED_TOOLS=$(IFS=,; echo "${TOOLS[*]}")
          fi

          # Build claude_args conditionally based on provided inputs
          CLAUDE_ARGS="--model $INPUT_MODEL"

          # Only add --max-turns if explicitly provided (not empty)
          if [ -n "$INPUT_MAX_TURNS" ]; then
            CLAUDE_ARGS="$CLAUDE_ARGS
            --max-turns $INPUT_MAX_TURNS"
            echo "‚ÑπÔ∏è  Including --max-turns $INPUT_MAX_TURNS"
          else
            echo "‚ÑπÔ∏è  Omitting --max-turns (unlimited turns)"
          fi

          CLAUDE_ARGS="$CLAUDE_ARGS
            --allowedTools $ALLOWED_TOOLS"

          echo "allowed_tools=$ALLOWED_TOOLS" >> $GITHUB_OUTPUT
          echo "claude_args<<CLAUDE_ARGS_EOF" >> $GITHUB_OUTPUT
          echo "$CLAUDE_ARGS" >> $GITHUB_OUTPUT
          echo "CLAUDE_ARGS_EOF" >> $GITHUB_OUTPUT
          echo "‚úÖ Configured allowed tools (${#ALLOWED_TOOLS} chars)"

      # Run Claude Code Action to perform the review
      - name: Run Claude Code Review
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: claude
        uses: anthropics/claude-code-action@a7e4c51380c42dd89b127f5e5f9be7b54020bc6b # v1.0.21
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          prompt: ${{ steps.build-prompt.outputs.final_prompt }}
          # Disable built-in progress tracking to avoid duplicate comments.
          # We maintain our own single PR comment via the "Post Review Completion Comment" step.
          # This ensures DEV-131 requirement #2: single PR comment for the lifetime of the PR.
          track_progress: false
          allowed_bots: dependabot
          claude_args: ${{ steps.build-args.outputs.claude_args }}
          additional_permissions: |
            actions: read

      # Validate that inline comments were created (warning only, not blocking)
      - name: Validate Inline Comments
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        id: validate-comments
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          IS_TRIVIAL: ${{ steps.pr-size.outputs.is_trivial }}
        run: |
          set -euo pipefail

          echo "‚ÑπÔ∏è  Checking for inline review comments on PR #$PR_NUMBER"

          # Get all review comments for this PR
          COMMENTS=$(gh api "/repos/${GITHUB_REPOSITORY}/pulls/${PR_NUMBER}/comments" --jq 'length')

          echo "inline_comment_count=$COMMENTS" >> $GITHUB_OUTPUT

          if [ "$COMMENTS" -eq 0 ]; then
            if [ "$IS_TRIVIAL" = "true" ]; then
              echo "‚ö†Ô∏è  No inline comments created, but PR is trivial (< 20 lines)"
              echo "   This is acceptable for small PRs with only auto-generated files"
              echo "has_inline_comments=false" >> $GITHUB_OUTPUT
            else
              echo "‚ö†Ô∏è  WARNING: No inline comments were created for this PR"
              echo "   The review prompt requires inline comments for comprehensive reviews"
              echo "   This may indicate a model capability issue or prompt following problem"
              echo ""
              echo "   Consider:"
              echo "   - Re-running the review with a more capable model"
              echo "   - Checking if the prompt instructions are clear enough"
              echo "has_inline_comments=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚úÖ Found $COMMENTS inline comment(s)"
            echo "has_inline_comments=true" >> $GITHUB_OUTPUT
          fi

      # Dismiss previous bot reviews to avoid cluttering PR with multiple reviews
      - name: Dismiss Previous Bot Reviews
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          echo "‚ÑπÔ∏è  Checking for previous bot reviews to dismiss..."

          # Get all reviews on this PR by github-actions[bot]
          # Filter for reviews that are APPROVED, CHANGES_REQUESTED, or COMMENTED (not DISMISSED or PENDING)
          REVIEWS=$(gh api "/repos/${GITHUB_REPOSITORY}/pulls/${PR_NUMBER}/reviews" \
            --jq '[.[] | select(.user.login == "github-actions[bot]" and (.state == "APPROVED" or .state == "CHANGES_REQUESTED" or .state == "COMMENTED"))]')

          REVIEW_COUNT=$(echo "$REVIEWS" | jq 'length')

          if [ "$REVIEW_COUNT" -eq 0 ]; then
            echo "‚ÑπÔ∏è  No previous bot reviews found to dismiss"
          else
            echo "‚ÑπÔ∏è  Found $REVIEW_COUNT previous bot review(s) to dismiss"

            # Dismiss each review
            echo "$REVIEWS" | jq -r '.[].id' | while read -r REVIEW_ID; do
              echo "   Dismissing review ID: $REVIEW_ID"
              gh api "/repos/${GITHUB_REPOSITORY}/pulls/${PR_NUMBER}/reviews/${REVIEW_ID}/dismissals" \
                -X PUT \
                -f message="Superseded by new review after PR update" \
                > /dev/null 2>&1 || {
                  echo "   ‚ö†Ô∏è  Could not dismiss review $REVIEW_ID (may lack permissions or review is not dismissible)"
                }
            done

            echo "‚úÖ Previous bot reviews dismissed"
          fi

      # Submit formal GitHub review using verdict from Claude
      - name: Submit GitHub Review
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Configuration
          WORKSPACE_ROOT="${GITHUB_WORKSPACE:-.}"
          VERDICT_FILE="$WORKSPACE_ROOT/.claude-review-verdict.txt"
          SUMMARY_FILE="$WORKSPACE_ROOT/.claude-review-summary.md"
          DEFAULT_VERDICT="COMMENT"
          DEFAULT_SUMMARY="Claude AI completed the code review. See inline comments for detailed feedback."

          echo "‚ÑπÔ∏è  Starting GitHub review submission for PR #$PR_NUMBER"

          # Read verdict from file or use default
          VERDICT="$DEFAULT_VERDICT"
          if [ -f "$VERDICT_FILE" ]; then
            VERDICT=$(cat "$VERDICT_FILE" | tr -d '[:space:]' | tr '[:lower:]' '[:upper:]')
            echo "‚ÑπÔ∏è  Read verdict from file: $VERDICT"
          else
            echo "‚ö†Ô∏è  No verdict file found at $VERDICT_FILE, using default: $DEFAULT_VERDICT"
          fi

          # Validate verdict
          case "$VERDICT" in
            APPROVE|REQUEST_CHANGES|COMMENT)
              echo "‚úÖ Valid verdict: $VERDICT"
              ;;
            *)
              echo "‚ùå Invalid verdict '$VERDICT', must be APPROVE, REQUEST_CHANGES, or COMMENT"
              echo "‚ö†Ô∏è  Falling back to default: $DEFAULT_VERDICT"
              VERDICT="$DEFAULT_VERDICT"
              ;;
          esac

          # Read summary from file or use default
          SUMMARY="$DEFAULT_SUMMARY"
          if [ -f "$SUMMARY_FILE" ]; then
            SUMMARY=$(cat "$SUMMARY_FILE")
            echo "‚ÑπÔ∏è  Read review summary from file (${#SUMMARY} chars)"
          else
            echo "‚ö†Ô∏è  No summary file found at $SUMMARY_FILE, using default message"
          fi

          # Submit GitHub review using gh CLI
          echo "‚ÑπÔ∏è  Submitting GitHub review for PR #$PR_NUMBER..."
          case "$VERDICT" in
            APPROVE)
              gh pr review "$PR_NUMBER" --approve --body "$SUMMARY"
              echo "‚úÖ Submitted APPROVE review"
              echo "‚ú® PR approved - no blocking issues found"
              ;;
            REQUEST_CHANGES)
              gh pr review "$PR_NUMBER" --request-changes --body "$SUMMARY"
              echo "‚úÖ Submitted REQUEST_CHANGES review (blocking)"
              echo "üî¥ Changes requested - critical issues must be addressed before merge"
              ;;
            COMMENT)
              gh pr review "$PR_NUMBER" --comment --body "$SUMMARY"
              echo "‚úÖ Submitted COMMENT review (non-blocking)"
              echo "üí¨ Review completed - see comments for feedback"
              ;;
          esac

          # Cleanup temporary files
          if [ -f "$VERDICT_FILE" ]; then
            rm -f "$VERDICT_FILE"
            echo "‚ÑπÔ∏è  Cleaned up $VERDICT_FILE"
          fi
          if [ -f "$SUMMARY_FILE" ]; then
            rm -f "$SUMMARY_FILE"
            echo "‚ÑπÔ∏è  Cleaned up $SUMMARY_FILE"
          fi

          echo "‚úÖ Review submission completed successfully"

      # Update PR comment with final results (success case)
      - name: Post Review Completion Comment
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          # Configuration
          COMMENT_ID_FILE=".claude-review-comment-id"
          VERDICT_FILE=".claude-review-verdict.txt"
          SUMMARY_FILE=".claude-review-summary.md"
          COMMENT_MARKER="<!-- claude-pr-review-bot -->"
          JOB_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          echo "‚ÑπÔ∏è  Preparing to post review completion comment" >&2

          # Get existing comment ID for this PR
          COMMENT_ID=""
          if [ -f "$COMMENT_ID_FILE" ]; then
            COMMENT_ID=$(cat "$COMMENT_ID_FILE")
            echo "‚ÑπÔ∏è  Found cached comment ID: $COMMENT_ID" >&2
          else
            echo "‚ÑπÔ∏è  Searching for existing Claude review comment..." >&2
            COMMENT_ID=$(gh api "/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" \
              --jq ".[] | select(.body | contains(\"${COMMENT_MARKER}\")) | .id" | head -1 || echo "")
            if [ -n "$COMMENT_ID" ]; then
              echo "‚ÑπÔ∏è  Found existing comment ID: $COMMENT_ID" >&2
              echo "$COMMENT_ID" > "$COMMENT_ID_FILE"
            else
              echo "‚ÑπÔ∏è  No existing comment found" >&2
            fi
          fi

          # Read verdict and summary
          VERDICT="COMMENT"
          VERDICT_EMOJI="üí¨"
          VERDICT_TEXT="Review Completed"
          VERDICT_COLOR="‚ö™"

          if [ -f "$VERDICT_FILE" ]; then
            VERDICT=$(cat "$VERDICT_FILE" | tr -d '[:space:]' | tr '[:lower:]' '[:upper:]')
            echo "‚ÑπÔ∏è  Read verdict: $VERDICT" >&2
          else
            echo "‚ö†Ô∏è  No verdict file found, using default: COMMENT" >&2
          fi

          # Set emoji and text based on verdict
          case "$VERDICT" in
            APPROVE)
              VERDICT_EMOJI="‚úÖ"
              VERDICT_TEXT="Approved"
              VERDICT_COLOR="üü¢"
              ;;
            REQUEST_CHANGES)
              VERDICT_EMOJI="üî¥"
              VERDICT_TEXT="Changes Requested"
              VERDICT_COLOR="üî¥"
              ;;
            COMMENT)
              VERDICT_EMOJI="üí¨"
              VERDICT_TEXT="Review Completed"
              VERDICT_COLOR="‚ö™"
              ;;
          esac

          # Read summary if available
          if [ -f "$SUMMARY_FILE" ]; then
            SUMMARY=$(cat "$SUMMARY_FILE")
            echo "‚ÑπÔ∏è  Read summary (${#SUMMARY} chars)" >&2
          else
            echo "‚ö†Ô∏è  No summary file found, using default" >&2
            SUMMARY="Claude AI completed the code review. See inline comments for detailed feedback."
          fi

          # Generate comment body
          COMMENT_BODY=$(cat <<EOF
          ${COMMENT_MARKER}
          ## ü§ñ Claude Code Review

          **Status:** ‚úÖ Completed
          **Verdict:** ${VERDICT_COLOR} ${VERDICT_EMOJI} **${VERDICT_TEXT}**
          **Job:** [View workflow run](${JOB_URL})

          ---

          ${SUMMARY}

          ---

          <details>
          <summary>Review Details</summary>

          **Verdict:** \`${VERDICT}\`
          **Completed:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")

          </details>
          EOF
          )

          # Create or update comment
          if [ -n "$COMMENT_ID" ]; then
            echo "‚ÑπÔ∏è  Updating comment ID: $COMMENT_ID..." >&2
            gh api "/repos/${GITHUB_REPOSITORY}/issues/comments/${COMMENT_ID}" \
              -X PATCH \
              -f body="$COMMENT_BODY" \
              > /dev/null
            echo "‚úÖ Updated comment ID: $COMMENT_ID" >&2
          else
            echo "‚ÑπÔ∏è  Creating new PR comment..." >&2
            COMMENT_ID=$(gh api "/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" \
              -X POST \
              -f body="$COMMENT_BODY" \
              --jq '.id')
            echo "$COMMENT_ID" > "$COMMENT_ID_FILE"
            echo "‚úÖ Created comment with ID: $COMMENT_ID" >&2
          fi

          echo "‚úÖ Review completion comment posted" >&2

      # Update PR comment with error status (failure case)
      - name: Post Review Error Comment
        if: steps.cache-check.outputs.cache-hit != 'true' && failure()
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          # Configuration
          COMMENT_ID_FILE=".claude-review-comment-id"
          COMMENT_MARKER="<!-- claude-pr-review-bot -->"
          JOB_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          echo "‚ÑπÔ∏è  Preparing to post review error comment" >&2

          # Get existing comment ID for this PR
          COMMENT_ID=""
          if [ -f "$COMMENT_ID_FILE" ]; then
            COMMENT_ID=$(cat "$COMMENT_ID_FILE")
            echo "‚ÑπÔ∏è  Found cached comment ID: $COMMENT_ID" >&2
          else
            echo "‚ÑπÔ∏è  Searching for existing Claude review comment..." >&2
            COMMENT_ID=$(gh api "/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" \
              --jq ".[] | select(.body | contains(\"${COMMENT_MARKER}\")) | .id" | head -1 || echo "")
            if [ -n "$COMMENT_ID" ]; then
              echo "‚ÑπÔ∏è  Found existing comment ID: $COMMENT_ID" >&2
              echo "$COMMENT_ID" > "$COMMENT_ID_FILE"
            else
              echo "‚ÑπÔ∏è  No existing comment found" >&2
            fi
          fi

          # Generate error comment body
          COMMENT_BODY=$(cat <<EOF
          ${COMMENT_MARKER}
          ## ü§ñ Claude Code Review

          **Status:** ‚ùå Error
          **Job:** [View workflow run](${JOB_URL})

          ---

          ### ‚ö†Ô∏è Review Failed

          The automated code review encountered an error and could not complete.

          **Next Steps:**
          1. Check the [workflow logs](${JOB_URL}) for details
          2. Verify the GitHub Actions configuration
          3. Ensure the Anthropic API key is valid
          4. Check for any permission issues

          If the problem persists, please contact your repository administrator.

          ---

          *You can manually re-trigger the review by pushing a new commit or re-running the workflow.*
          EOF
          )

          # Create or update comment
          if [ -n "$COMMENT_ID" ]; then
            echo "‚ÑπÔ∏è  Updating comment ID: $COMMENT_ID..." >&2
            gh api "/repos/${GITHUB_REPOSITORY}/issues/comments/${COMMENT_ID}" \
              -X PATCH \
              -f body="$COMMENT_BODY" \
              > /dev/null
            echo "‚úÖ Updated comment ID: $COMMENT_ID" >&2
          else
            echo "‚ÑπÔ∏è  Creating new PR comment..." >&2
            COMMENT_ID=$(gh api "/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" \
              -X POST \
              -f body="$COMMENT_BODY" \
              --jq '.id')
            echo "$COMMENT_ID" > "$COMMENT_ID_FILE"
            echo "‚úÖ Created comment with ID: $COMMENT_ID" >&2
          fi

          echo "‚úÖ Error comment posted" >&2

      # Save successful review to cache
      - name: Save Review Cache Marker
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        run: |
          mkdir -p .review-cache
          echo "${{ steps.patch-id.outputs.patch_id }}" > .review-cache/patch-id
          echo "Cached review for patch-ID: ${{ steps.patch-id.outputs.patch_id }}"

      # Persist cache for future rebase detection
      - name: Cache Review State
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        uses: actions/cache/save@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: .review-cache
          key: review-pr${{ inputs.pr_number }}-patch-${{ steps.patch-id.outputs.patch_id }}
