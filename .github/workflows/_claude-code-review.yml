name: "[claude] Claude Code Review"

# Reusable workflow for automated PR code reviews using Claude AI
#
# This workflow provides comprehensive code reviews with:
# - Formal GitHub reviews (APPROVE/REQUEST_CHANGES/COMMENT)
# - Inline comments on specific lines of code (as github-actions[bot])
# - Patch-ID based caching to skip rebases
# - Custom prompt support
#
# ARCHITECTURE:
# This workflow uses a hybrid approach:
# 1. Claude analyzes the PR and outputs structured JSON
# 2. A TypeScript script parses the JSON and posts the review via gh CLI
#
# This ensures all comments appear as `github-actions[bot]` using the official
# Anthropic action without needing a fork.
#
# USAGE:
#   uses: Uniswap/ai-toolkit/.github/workflows/_claude-code-review.yml@main
#   with:
#     pr_number: ${{ github.event.pull_request.number }}
#     base_ref: ${{ github.base_ref }}
#   secrets:
#     ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
#
# FEATURES:
# - Runs on every push but skips rebases (patch-ID detection)
# - Creates inline comments like human reviewers
# - Submits formal reviews for merge protection
# - Supports custom prompts
#
# PERMISSIONS REQUIRED (calling workflow must grant these):
#   contents: read
#   pull-requests: write
#   issues: read
#   actions: read
#   id-token: write

on:
  workflow_call:
    inputs:
      pr_number:
        description: "Pull request number to review"
        required: true
        type: string

      base_ref:
        description: "Base branch name (e.g., main, master)"
        required: true
        type: string

      model:
        description: "Claude model to use for review"
        required: false
        type: string
        default: "claude-sonnet-4-5-20250929"

      max_turns:
        description: "Maximum conversation turns for Claude. Omit to use unlimited turns."
        required: false
        type: number

      custom_prompt:
        description: "Custom prompt text (overrides prompt file and default)."
        required: false
        type: string
        default: ""

      custom_prompt_path:
        description: "Path to custom prompt file in repository (e.g., .claude/prompts/claude-pr-bot.md)"
        required: false
        type: string
        default: ".claude/prompts/claude-pr-bot.md"

      timeout_minutes:
        description: "Job timeout in minutes"
        required: false
        type: number
        default: 30

      allowed_tools:
        description: 'Comma-separated list of allowed tools for Claude (e.g., "Read,Grep,Glob"). Leave empty for default read-only set.'
        required: false
        type: string
        default: ""

    secrets:
      ANTHROPIC_API_KEY:
        description: "Anthropic API key for Claude access"
        required: true

jobs:
  claude-review:
    runs-on: ubuntu-latest
    timeout-minutes: ${{ inputs.timeout_minutes }}

    # Fixed permissions (cannot be overridden by calling workflow)
    permissions:
      id-token: write # Required for OIDC
      contents: read # Required to read repository code
      pull-requests: write # Required to comment and submit reviews
      issues: read # Required to read PR discussions
      actions: read # Required to check CI status

    steps:
      # Security scanning (required for all workflows)
      - name: Security Scan
        uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4
        with:
          egress-policy: audit

      # Checkout code with full history for patch-ID calculation
      - name: Checkout Repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0 # Full history needed for git merge-base

      # Calculate patch-ID (stable hash of code changes, survives rebases)
      - name: Calculate Patch ID
        id: patch-id
        env:
          BASE_REF: ${{ inputs.base_ref }}
        run: |
          # Find the merge base between base branch and HEAD
          MERGE_BASE=$(git merge-base origin/$BASE_REF HEAD)

          # Calculate stable patch-ID (same code = same ID, even after rebase)
          PATCH_ID=$(git diff ${MERGE_BASE}..HEAD | git patch-id --stable | cut -d' ' -f1)

          echo "patch_id=$PATCH_ID" >> $GITHUB_OUTPUT
          echo "üìä Patch-ID: ${PATCH_ID:0:12}... (first 12 chars)"
          echo "   This ID stays the same across rebases if code hasn't changed"

      # Detect trivial PRs for fast-path review
      - name: Detect Trivial PR
        id: pr-size
        env:
          BASE_REF: ${{ inputs.base_ref }}
        run: |
          # Find the merge base between base branch and HEAD
          MERGE_BASE=$(git merge-base origin/$BASE_REF HEAD)

          # Count lines changed (additions + deletions)
          STATS=$(git diff --shortstat ${MERGE_BASE}..HEAD)

          # Extract insertions and deletions, default to 0 if not present
          INSERTIONS=$(echo "$STATS" | grep -oP '\d+(?= insertion)' || echo "0")
          DELETIONS=$(echo "$STATS" | grep -oP '\d+(?= deletion)' || echo "0")
          TOTAL_CHANGES=$((INSERTIONS + DELETIONS))

          echo "lines_changed=$TOTAL_CHANGES" >> $GITHUB_OUTPUT
          echo "üìä Total lines changed: $TOTAL_CHANGES"

          # Determine if this is a trivial PR (< 20 lines changed)
          if [ "$TOTAL_CHANGES" -lt 20 ]; then
            echo "is_trivial=true" >> $GITHUB_OUTPUT
            echo "‚ú® Trivial PR detected (< 20 lines) - will use fast review mode"
          else
            echo "is_trivial=false" >> $GITHUB_OUTPUT
            echo "üìù Standard PR - will use comprehensive review mode"
          fi

      # Check cache to see if we've already reviewed this exact code
      - name: Check Review Cache
        id: cache-check
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: .review-cache
          key: review-pr${{ inputs.pr_number }}-patch-${{ steps.patch-id.outputs.patch_id }}
          lookup-only: true # Just check, don't restore

      # Early exit if we've already reviewed this code (rebase detected)
      - name: Skip Review if No Changes
        if: steps.cache-check.outputs.cache-hit == 'true'
        run: |
          echo "‚úÖ Skipping review - no actual code changes detected"
          echo ""
          echo "This push appears to be a rebase or merge without new code changes."
          echo "Patch-ID: ${{ steps.patch-id.outputs.patch_id }}"
          echo ""
          echo "We've already reviewed this exact code, so skipping to save API costs."
          exit 0

      # Fetch existing review comments for context
      - name: Fetch Existing Review Comments
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: existing-comments
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          echo "‚ÑπÔ∏è  Fetching existing review comments for context..."

          # Get existing review comments (for re-review context)
          COMMENTS=$(gh api "/repos/${GITHUB_REPOSITORY}/pulls/${PR_NUMBER}/comments" \
            --jq '[.[] | {id: .id, path: .path, line: .line, body: .body, user: .user.login}]' || echo "[]")

          # Save to file for prompt inclusion
          echo "$COMMENTS" > /tmp/existing-comments.json

          COMMENT_COUNT=$(echo "$COMMENTS" | jq 'length')
          echo "existing_comment_count=$COMMENT_COUNT" >> $GITHUB_OUTPUT

          if [ "$COMMENT_COUNT" -gt 0 ]; then
            echo "‚ÑπÔ∏è  Found $COMMENT_COUNT existing review comment(s)"
          else
            echo "‚ÑπÔ∏è  No existing review comments found (initial review)"
          fi

      # Build final prompt with custom content
      - name: Build Review Prompt
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: build-prompt
        env:
          CUSTOM_PROMPT_INPUT: ${{ inputs.custom_prompt }}
          CUSTOM_PROMPT_PATH: ${{ inputs.custom_prompt_path }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          PR_NUMBER: ${{ inputs.pr_number }}
          BASE_REF: ${{ inputs.base_ref }}
          PATCH_ID: ${{ steps.patch-id.outputs.patch_id }}
          EXISTING_COMMENT_COUNT: ${{ steps.existing-comments.outputs.existing_comment_count }}
        run: |
          CUSTOM_PROMPT=""

          # Priority 1: Explicit custom_prompt input
          if [ -n "$CUSTOM_PROMPT_INPUT" ]; then
            echo "üìù Using explicit custom prompt from workflow input"
            CUSTOM_PROMPT="$CUSTOM_PROMPT_INPUT"

          # Priority 2: Custom prompt file in repository
          elif [ -f "$CUSTOM_PROMPT_PATH" ]; then
            echo "üìù Using custom prompt from repository: $CUSTOM_PROMPT_PATH"
            CUSTOM_PROMPT=$(cat "$CUSTOM_PROMPT_PATH")

          # Priority 3: Default prompt from ai-toolkit repository
          else
            echo "üìù Fetching default prompt from Uniswap/ai-toolkit repository"

            # Fetch default prompt via GitHub API
            if ! curl -fSs -H "Authorization: token $GITHUB_TOKEN" \
                      -H "Accept: application/vnd.github.v4.raw" \
                      -L "https://api.github.com/repos/Uniswap/ai-toolkit/contents/.github/prompts/default-pr-review.md" \
                      -o /tmp/default-prompt.md 2>&1 | tee /tmp/curl-error.log; then
              echo "‚ùå Failed to fetch default prompt from Uniswap/ai-toolkit"
              echo "   Error details:"
              cat /tmp/curl-error.log | head -5
              exit 1
            fi

            CUSTOM_PROMPT=$(cat /tmp/default-prompt.md)
            echo "‚úÖ Loaded default prompt from Uniswap/ai-toolkit"
          fi

          # Parse repository owner and name from REPO (format: owner/repo)
          REPO_OWNER=$(echo "$REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$REPO" | cut -d'/' -f2)

          # Build final prompt with context
          cat > /tmp/final-prompt.txt <<PROMPT_EOF
          # Review Context

          **Repository Owner:** $REPO_OWNER
          **Repository Name:** $REPO_NAME
          **PR Number:** $PR_NUMBER
          **Base Branch:** $BASE_REF
          **Patch ID:** $PATCH_ID

          ---

          PROMPT_EOF

          # Append custom prompt content
          echo "$CUSTOM_PROMPT" >> /tmp/final-prompt.txt

          # Append existing comments context for re-reviews
          if [ "$EXISTING_COMMENT_COUNT" -gt 0 ]; then
            cat >> /tmp/final-prompt.txt <<EXISTING_COMMENTS_EOF

          ---

          # Existing Review Comments

          The following review comments already exist on this PR. Check if issues have been addressed:

          \`\`\`json
          $(cat /tmp/existing-comments.json)
          \`\`\`

          For each existing comment, if the issue has been fixed in the current code, include a response
          in your \`inline_comments_responses\` array with \`should_resolve: true\`.
          EXISTING_COMMENTS_EOF
            echo "‚ú® Added existing comments context for re-review"
          fi

          # Append fast-review mode instructions for trivial PRs
          IS_TRIVIAL="${{ steps.pr-size.outputs.is_trivial }}"
          if [ "$IS_TRIVIAL" = "true" ]; then
            cat >> /tmp/final-prompt.txt <<TRIVIAL_MODE_EOF

          ---

          # üöÄ Fast Review Mode (Trivial PR)

          This PR has fewer than 20 lines of changes. Use an expedited review process:

          1. **Quick scan**: Review changed files briefly
          2. **Focus on critical issues only**: Bugs, security vulnerabilities, breaking changes
          3. **Skip comprehensive analysis**: Don't need detailed maintainability or improvement suggestions
          4. **Minimal inline comments**: If the PR only modifies auto-generated files (lockfiles, snapshots), use an empty \`inline_comments_new\` array
          5. **Fast verdict**: Complete quickly with appropriate outcome

          **Goal**: Provide value while minimizing review cost for small changes.
          TRIVIAL_MODE_EOF
            echo "‚ú® Added fast-review mode instructions for trivial PR"
          fi

          # ALWAYS append JSON output instructions (required for hybrid approach)
          cat >> /tmp/final-prompt.txt <<JSON_OUTPUT_EOF

          ---

          # ‚ö†Ô∏è CRITICAL: Required JSON Output Format

          **Your ENTIRE response must be a single JSON code block.** Do NOT include any explanatory text, analysis summary, or preamble before the JSON. Do NOT call any GitHub MCP tools to post comments.

          Output your complete review as a JSON object with this exact structure:

          \`\`\`json
          {
            "pr_review_body": "## Code Review Summary\\n\\n[Your markdown-formatted review summary]",
            "pr_review_outcome": "COMMENT",
            "inline_comments_new": [
              {
                "path": "src/example.ts",
                "line": 42,
                "body": "Your detailed feedback for this specific line",
                "suggestion": "optional corrected code here"
              }
            ],
            "inline_comments_responses": [],
            "files_reviewed": ["src/file1.ts", "src/file2.ts"],
            "confidence": 0.85
          }
          \`\`\`

          **JSON Schema:**
          - \`pr_review_body\` (string, required): Markdown-formatted review summary
          - \`pr_review_outcome\` (enum, required): "COMMENT", "APPROVE", or "REQUEST_CHANGES"
          - \`inline_comments_new\` (array, required): New inline comments (can be empty \`[]\`)
            - Each comment needs: \`path\` (file path), \`line\` (number), \`body\` (feedback text)
            - Optional: \`suggestion\` (corrected code snippet)
          - \`inline_comments_responses\` (array, optional): Responses to existing comments
            - Each response needs: \`comment_id\` (number), \`body\` (response text), \`should_resolve\` (boolean)
          - \`files_reviewed\` (array, optional): List of files you reviewed
          - \`confidence\` (number, optional): 0.0-1.0 confidence in your review

          **Outcome Guidelines:**
          - \`APPROVE\`: No blocking issues, code is safe to merge
          - \`REQUEST_CHANGES\`: Critical bugs, security issues, or data loss risks
          - \`COMMENT\`: Suggestions and improvements, but not blocking

          **IMPORTANT:**
          - DO NOT call \`mcp__github__create_pull_request_review\` or any GitHub write tools
          - Your JSON will be parsed by a script that posts the review as \`github-actions[bot]\`
          - Ensure your JSON is valid and properly escaped
          JSON_OUTPUT_EOF
          echo "‚úÖ Added JSON output instructions (required for hybrid approach)"

          # Log final prompt length
          PROMPT_LENGTH=$(wc -c < /tmp/final-prompt.txt)
          echo "‚úÖ Built final prompt: $PROMPT_LENGTH characters"

          # Export as output for next step
          {
            echo "final_prompt<<PROMPT_DELIMITER_EOF"
            cat /tmp/final-prompt.txt
            echo "PROMPT_DELIMITER_EOF"
          } >> $GITHUB_OUTPUT

          # Show first few lines for debugging
          echo ""
          echo "üìÑ Prompt preview (first 10 lines):"
          head -n 10 /tmp/final-prompt.txt

      # Build Claude arguments - READ-ONLY tools only (no GitHub write tools)
      - name: Build Claude Arguments
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: build-args
        env:
          INPUT_ALLOWED_TOOLS: ${{ inputs.allowed_tools }}
          INPUT_MAX_TURNS: ${{ inputs.max_turns }}
          INPUT_MODEL: ${{ inputs.model }}
        run: |
          # Build allowed tools list - READ-ONLY tools only
          # Claude outputs JSON, the post-review script handles GitHub writes
          if [ -n "$INPUT_ALLOWED_TOOLS" ]; then
            ALLOWED_TOOLS="$INPUT_ALLOWED_TOOLS"
          else
            # Define read-only tools for analysis
            TOOLS=(
              # File operations (read-only)
              "Read"
              "Grep"
              "Glob"

              # Git commands for context (read-only)
              "Bash(git log:*)"
              "Bash(git diff:*)"
              "Bash(git show:*)"
              "Bash(git blame:*)"
              "Bash(git rev-parse:*)"

              # GitHub MCP tools (read-only, for fetching PR context)
              "mcp__github__get_pull_request"
              "mcp__github__get_pull_request_files"
              "mcp__github__get_pull_request_comments"
              "mcp__github__get_pull_request_reviews"
            )

            # Join array elements with commas (no spaces)
            ALLOWED_TOOLS=$(IFS=,; echo "${TOOLS[*]}")
          fi

          # Build claude_args conditionally based on provided inputs
          CLAUDE_ARGS="--model $INPUT_MODEL"

          # Only add --max-turns if explicitly provided (not empty)
          if [ -n "$INPUT_MAX_TURNS" ]; then
            CLAUDE_ARGS="$CLAUDE_ARGS
            --max-turns $INPUT_MAX_TURNS"
            echo "‚ÑπÔ∏è  Including --max-turns $INPUT_MAX_TURNS"
          else
            echo "‚ÑπÔ∏è  Omitting --max-turns (unlimited turns)"
          fi

          CLAUDE_ARGS="$CLAUDE_ARGS
            --allowedTools $ALLOWED_TOOLS"

          echo "allowed_tools=$ALLOWED_TOOLS" >> $GITHUB_OUTPUT
          echo "claude_args<<CLAUDE_ARGS_EOF" >> $GITHUB_OUTPUT
          echo "$CLAUDE_ARGS" >> $GITHUB_OUTPUT
          echo "CLAUDE_ARGS_EOF" >> $GITHUB_OUTPUT
          echo "‚úÖ Configured read-only tools (${#ALLOWED_TOOLS} chars)"

      # Run Claude Code Action to perform the review (analysis only, outputs JSON)
      - name: Run Claude Code Review
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: claude
        uses: anthropics/claude-code-action@a7e4c51380c42dd89b127f5e5f9be7b54020bc6b # v1.0.21
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          prompt: ${{ steps.build-prompt.outputs.final_prompt }}
          # Disable built-in progress tracking - we handle our own PR comments
          track_progress: false
          # Show full Claude output in logs for debugging
          show_full_output: true
          allowed_bots: dependabot
          claude_args: ${{ steps.build-args.outputs.claude_args }}
          additional_permissions: |
            actions: read

      # Setup Node.js for the post-review script
      - name: Setup Node.js
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af # v4.1.0
        with:
          node-version: "22"

      # Extract Claude's final response from the execution output
      - name: Extract Claude Response
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        id: extract-response
        run: |
          set -euo pipefail

          EXECUTION_FILE="/home/runner/work/_temp/claude-execution-output.json"

          if [ ! -f "$EXECUTION_FILE" ]; then
            echo "‚ùå Claude execution output file not found"
            exit 1
          fi

          echo "‚ÑπÔ∏è  Extracting Claude's final response from execution log..."

          # Extract the last assistant message content from the execution log
          # The file is a JSON array created by `jq -s '.'` in claude-code-action
          # Format: [{"type": "system", ...}, {"type": "assistant", "message": {...}}, ...]
          # We need to find the last assistant message and extract its text content
          REVIEW_TEXT=$(cat "$EXECUTION_FILE" | \
            jq '[.[] | select(.type == "assistant") | .message.content[] | select(.type == "text") | .text] | last // empty' -r)

          if [ -z "$REVIEW_TEXT" ]; then
            echo "‚ùå Could not extract assistant response from execution log"
            echo "üìã Execution file structure debug:"
            echo "  - File size: $(wc -c < "$EXECUTION_FILE") bytes"
            echo "  - Number of messages: $(jq 'length' "$EXECUTION_FILE")"
            echo "  - Message types: $(jq '[.[].type] | unique' "$EXECUTION_FILE")"
            echo "  - Assistant messages count: $(jq '[.[] | select(.type == "assistant")] | length' "$EXECUTION_FILE")"
            echo ""
            echo "üìã Last assistant message structure (first 1000 chars):"
            jq '[.[] | select(.type == "assistant")] | last' "$EXECUTION_FILE" | head -c 1000
            exit 1
          fi

          # Save for the next step
          echo "$REVIEW_TEXT" > /tmp/claude-review-response.txt
          echo "‚úÖ Extracted response (${#REVIEW_TEXT} chars)"

          # Show preview
          echo "üìã Response preview (first 500 chars):"
          echo "$REVIEW_TEXT" | head -c 500

      # Upload Claude execution output as artifact for debugging
      - name: Upload Claude Execution Output
        if: steps.cache-check.outputs.cache-hit != 'true' && always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: claude-execution-output-pr${{ inputs.pr_number }}
          path: /home/runner/work/_temp/claude-execution-output.json
          retention-days: 7
          if-no-files-found: warn

      # Download post-review script if running from external repository
      # When running from ai-toolkit itself, use the local file
      - name: Setup Post Review Script
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        id: setup-script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          # Check if we're running from the ai-toolkit repository
          if [ "$GITHUB_REPOSITORY" = "Uniswap/ai-toolkit" ]; then
            echo "‚ÑπÔ∏è  Running from ai-toolkit - using local post-review.ts"
            echo "script_path=.github/scripts/post-review.ts" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è  Running from external repository - downloading post-review.ts from Uniswap/ai-toolkit"

            # Download the script from ai-toolkit repository
            if ! curl -fSs -H "Authorization: token $GITHUB_TOKEN" \
                      -H "Accept: application/vnd.github.v4.raw" \
                      -L "https://api.github.com/repos/Uniswap/ai-toolkit/contents/.github/scripts/post-review.ts" \
                      -o /tmp/post-review.ts 2>&1 | tee /tmp/curl-error.log; then
              echo "‚ùå Failed to download post-review.ts from Uniswap/ai-toolkit"
              echo "   Error details:"
              cat /tmp/curl-error.log | head -5
              exit 1
            fi

            echo "‚úÖ Downloaded post-review.ts"
            echo "script_path=/tmp/post-review.ts" >> $GITHUB_OUTPUT
          fi

      # Post the review using our script (all comments as github-actions[bot])
      - name: Post Review via Script
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        id: post-review
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          # Pass file path instead of content to avoid shell injection risks
          # The script reads the file directly, avoiding shell expansion of content
          REVIEW_JSON_FILE: /tmp/claude-review-response.txt
          # Script path determined by setup-script step (local or downloaded)
          POST_REVIEW_SCRIPT: ${{ steps.setup-script.outputs.script_path }}
        run: |
          set -euo pipefail

          echo "‚ÑπÔ∏è  Parsing Claude's review output and posting to GitHub..."
          echo "‚ÑπÔ∏è  Using script: $POST_REVIEW_SCRIPT"

          # Parse owner and repo
          REPO_OWNER=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f1)
          REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2)

          # Verify the response file exists
          if [ ! -f "$REVIEW_JSON_FILE" ]; then
            echo "‚ùå No review response file found at $REVIEW_JSON_FILE"
            exit 1
          fi

          # Check that the file has content
          if [ ! -s "$REVIEW_JSON_FILE" ]; then
            echo "‚ùå No review output from Claude (file is empty)"
            exit 1
          fi

          echo "‚ÑπÔ∏è  Review response length: $(wc -c < "$REVIEW_JSON_FILE") bytes"

          # Run the post-review script (path from setup-script step)
          # REVIEW_JSON_FILE env var is passed to the script, which reads the file directly
          # This avoids shell expansion of file content (shell injection safe)
          npx tsx "$POST_REVIEW_SCRIPT" \
            --owner "$REPO_OWNER" \
            --repo "$REPO_NAME" \
            --pr-number "$PR_NUMBER"

          echo "‚úÖ Review posted successfully"

      # Fallback: Post review summary as PR comment if script fails
      - name: Fallback Review Comment
        if: steps.cache-check.outputs.cache-hit != 'true' && failure()
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: |
          set -euo pipefail

          echo "‚ö†Ô∏è  Script failed, posting Claude's output as comment fallback..."

          COMMENT_MARKER="<!-- claude-pr-review-bot -->"
          JOB_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          # Try to read the extracted response, fallback to execution file
          if [ -f /tmp/claude-review-response.txt ]; then
            SUMMARY=$(cat /tmp/claude-review-response.txt)
          elif [ -f /home/runner/work/_temp/claude-execution-output.json ]; then
            SUMMARY=$(cat /home/runner/work/_temp/claude-execution-output.json | head -c 10000)
          else
            SUMMARY="No review output available"
          fi

          # Generate fallback comment
          COMMENT_BODY=$(cat <<EOF
          ${COMMENT_MARKER}
          ## ü§ñ Claude Code Review

          **Status:** ‚ö†Ô∏è Partial (script error)
          **Job:** [View workflow run](${JOB_URL})

          ---

          The review was completed but there was an error posting inline comments.

          <details>
          <summary>Raw Review Output</summary>

          \`\`\`
          ${SUMMARY:0:10000}
          \`\`\`

          </details>

          ---

          *Please check the workflow logs for details.*
          EOF
          )

          # Post as PR comment
          gh api "/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" \
            -X POST \
            -f body="$COMMENT_BODY" \
            > /dev/null

          echo "‚úÖ Fallback comment posted"

      # Post error comment if Claude completely fails (no output at all)
      - name: Post Review Error Comment
        if: steps.cache-check.outputs.cache-hit != 'true' && failure() && steps.claude.conclusion == 'failure'
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          COMMENT_MARKER="<!-- claude-pr-review-bot -->"
          JOB_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          echo "‚ÑπÔ∏è  Posting review error comment" >&2

          # Generate error comment body
          COMMENT_BODY=$(cat <<EOF
          ${COMMENT_MARKER}
          ## ü§ñ Claude Code Review

          **Status:** ‚ùå Error
          **Job:** [View workflow run](${JOB_URL})

          ---

          ### ‚ö†Ô∏è Review Failed

          The automated code review encountered an error and could not complete.

          **Next Steps:**
          1. Check the [workflow logs](${JOB_URL}) for details
          2. Verify the GitHub Actions configuration
          3. Ensure the Anthropic API key is valid
          4. Check for any permission issues

          If the problem persists, please contact your repository administrator.

          ---

          *You can manually re-trigger the review by pushing a new commit or re-running the workflow.*
          EOF
          )

          # Post comment
          gh api "/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" \
            -X POST \
            -f body="$COMMENT_BODY" \
            > /dev/null

          echo "‚úÖ Error comment posted" >&2

      # Save successful review to cache
      - name: Save Review Cache Marker
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        run: |
          mkdir -p .review-cache
          echo "${{ steps.patch-id.outputs.patch_id }}" > .review-cache/patch-id
          echo "Cached review for patch-ID: ${{ steps.patch-id.outputs.patch_id }}"

      # Persist cache for future rebase detection
      - name: Cache Review State
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        uses: actions/cache/save@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: .review-cache
          key: review-pr${{ inputs.pr_number }}-patch-${{ steps.patch-id.outputs.patch_id }}
