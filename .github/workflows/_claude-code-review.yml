name: "[claude] Claude Code Review"

# Reusable workflow for automated PR code reviews using Claude AI
#
# This workflow provides comprehensive code reviews with:
# - Formal GitHub reviews (APPROVE/REQUEST_CHANGES/COMMENT)
# - Inline comments on specific lines of code (as github-actions[bot])
# - Patch-ID based caching to skip rebases
# - Custom prompt support
#
# ARCHITECTURE:
# This workflow uses a hybrid approach:
# 1. Claude analyzes the PR and outputs structured JSON
# 2. A TypeScript script parses the JSON and posts the review via gh CLI
#
# This ensures all comments appear as `github-actions[bot]` using the official
# Anthropic action without needing a fork.
#
# USAGE:
#   uses: Uniswap/ai-toolkit/.github/workflows/_claude-code-review.yml@main
#   with:
#     pr_number: ${{ github.event.pull_request.number }}
#     base_ref: ${{ github.base_ref }}
#   secrets:
#     ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
#
# FEATURES:
# - Runs on every push but skips rebases (patch-ID detection)
# - Creates inline comments like human reviewers
# - Submits formal reviews for merge protection
# - Supports custom prompts
#
# PERMISSIONS REQUIRED (calling workflow must grant these):
#   contents: read
#   pull-requests: write
#   issues: read
#   actions: read
#   id-token: write

on:
  workflow_call:
    inputs:
      pr_number:
        description: "Pull request number to review"
        required: true
        type: string

      base_ref:
        description: "Base branch name (e.g., main, master)"
        required: true
        type: string

      model:
        description: "Claude model to use for review"
        required: false
        type: string
        default: "claude-sonnet-4-5-20250929"

      max_turns:
        description: "Maximum conversation turns for Claude. Omit to use unlimited turns."
        required: false
        type: number

      custom_prompt:
        description: "Custom prompt text (overrides prompt file and default)."
        required: false
        type: string
        default: ""

      custom_prompt_path:
        description: "Path to custom prompt file in repository (e.g., .claude/prompts/claude-pr-bot.md)"
        required: false
        type: string
        default: ".claude/prompts/claude-pr-bot.md"

      timeout_minutes:
        description: "Job timeout in minutes"
        required: false
        type: number
        default: 30

      allowed_tools:
        description: 'Comma-separated list of allowed tools for Claude (e.g., "Read,Grep,Glob"). Leave empty for default read-only set.'
        required: false
        type: string
        default: ""

    secrets:
      ANTHROPIC_API_KEY:
        description: "Anthropic API key for Claude access"
        required: true
      WORKFLOW_PAT:
        description: "Personal Access Token with repo scope for cross-repo access to fetch default prompts from ai-toolkit. Only required if not providing a custom_prompt or custom_prompt_path."
        required: false

jobs:
  claude-review:
    runs-on: ubuntu-latest
    timeout-minutes: ${{ inputs.timeout_minutes }}

    # Fixed permissions (cannot be overridden by calling workflow)
    permissions:
      id-token: write # Required for OIDC
      contents: read # Required to read repository code
      pull-requests: write # Required to comment and submit reviews
      issues: read # Required to read PR discussions
      actions: read # Required to check CI status

    steps:
      # Security scanning (required for all workflows)
      - name: Security Scan
        uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4
        with:
          egress-policy: audit

      # Checkout code with full history for patch-ID calculation
      - name: Checkout Repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0 # Full history needed for git merge-base

      # Calculate patch-ID (stable hash of code changes, survives rebases)
      - name: Calculate Patch ID
        id: patch-id
        env:
          BASE_REF: ${{ inputs.base_ref }}
        run: |
          # Find the merge base between base branch and HEAD
          MERGE_BASE=$(git merge-base origin/$BASE_REF HEAD)

          # Calculate stable patch-ID (same code = same ID, even after rebase)
          PATCH_ID=$(git diff ${MERGE_BASE}..HEAD | git patch-id --stable | cut -d' ' -f1)

          echo "patch_id=$PATCH_ID" >> $GITHUB_OUTPUT
          echo "üìä Patch-ID: ${PATCH_ID:0:12}... (first 12 chars)"
          echo "   This ID stays the same across rebases if code hasn't changed"

      # Detect trivial PRs for fast-path review
      - name: Detect Trivial PR
        id: pr-size
        env:
          BASE_REF: ${{ inputs.base_ref }}
        run: |
          # Find the merge base between base branch and HEAD
          MERGE_BASE=$(git merge-base origin/$BASE_REF HEAD)

          # Count lines changed (additions + deletions)
          STATS=$(git diff --shortstat ${MERGE_BASE}..HEAD)

          # Extract insertions and deletions, default to 0 if not present
          INSERTIONS=$(echo "$STATS" | grep -oP '\d+(?= insertion)' || echo "0")
          DELETIONS=$(echo "$STATS" | grep -oP '\d+(?= deletion)' || echo "0")
          TOTAL_CHANGES=$((INSERTIONS + DELETIONS))

          echo "lines_changed=$TOTAL_CHANGES" >> $GITHUB_OUTPUT
          echo "üìä Total lines changed: $TOTAL_CHANGES"

          # Determine if this is a trivial PR (< 20 lines changed)
          if [ "$TOTAL_CHANGES" -lt 20 ]; then
            echo "is_trivial=true" >> $GITHUB_OUTPUT
            echo "‚ú® Trivial PR detected (< 20 lines) - will use fast review mode"
          else
            echo "is_trivial=false" >> $GITHUB_OUTPUT
            echo "üìù Standard PR - will use comprehensive review mode"
          fi

      # Check cache to see if we've already reviewed this exact code
      - name: Check Review Cache
        id: cache-check
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: .review-cache
          key: review-pr${{ inputs.pr_number }}-patch-${{ steps.patch-id.outputs.patch_id }}
          lookup-only: true # Just check, don't restore

      # Early exit if we've already reviewed this code (rebase detected)
      - name: Skip Review if No Changes
        if: steps.cache-check.outputs.cache-hit == 'true'
        run: |
          echo "‚úÖ Skipping review - no actual code changes detected"
          echo ""
          echo "This push appears to be a rebase or merge without new code changes."
          echo "Patch-ID: ${{ steps.patch-id.outputs.patch_id }}"
          echo ""
          echo "We've already reviewed this exact code, so skipping to save API costs."
          exit 0

      # Fetch existing review comments for context
      - name: Fetch Existing Review Comments
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: existing-comments
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          echo "‚ÑπÔ∏è  Fetching existing review comments for context..."

          # Get existing review comments (for re-review context)
          COMMENTS=$(gh api "/repos/${GITHUB_REPOSITORY}/pulls/${PR_NUMBER}/comments" \
            --jq '[.[] | {id: .id, path: .path, line: .line, body: .body, user: .user.login}]' || echo "[]")

          # Save to file for prompt inclusion
          echo "$COMMENTS" > /tmp/existing-comments.json

          COMMENT_COUNT=$(echo "$COMMENTS" | jq 'length')
          echo "existing_comment_count=$COMMENT_COUNT" >> $GITHUB_OUTPUT

          if [ "$COMMENT_COUNT" -gt 0 ]; then
            echo "‚ÑπÔ∏è  Found $COMMENT_COUNT existing review comment(s)"
          else
            echo "‚ÑπÔ∏è  No existing review comments found (initial review)"
          fi

      # Build final prompt with custom content
      - name: Build Review Prompt
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: build-prompt
        env:
          CUSTOM_PROMPT_INPUT: ${{ inputs.custom_prompt }}
          CUSTOM_PROMPT_PATH: ${{ inputs.custom_prompt_path }}
          WORKFLOW_PAT: ${{ secrets.WORKFLOW_PAT }}
          REPO: ${{ github.repository }}
          PR_NUMBER: ${{ inputs.pr_number }}
          BASE_REF: ${{ inputs.base_ref }}
          PATCH_ID: ${{ steps.patch-id.outputs.patch_id }}
          EXISTING_COMMENT_COUNT: ${{ steps.existing-comments.outputs.existing_comment_count }}
        run: |
          CUSTOM_PROMPT=""

          # Priority 1: Explicit custom_prompt input
          if [ -n "$CUSTOM_PROMPT_INPUT" ]; then
            echo "üìù Using explicit custom prompt from workflow input"
            CUSTOM_PROMPT="$CUSTOM_PROMPT_INPUT"

          # Priority 2: Custom prompt file in repository
          elif [ -f "$CUSTOM_PROMPT_PATH" ]; then
            echo "üìù Using custom prompt from repository: $CUSTOM_PROMPT_PATH"
            CUSTOM_PROMPT=$(cat "$CUSTOM_PROMPT_PATH")

          # Priority 3: Default prompt from ai-toolkit repository
          else
            echo "üìù Fetching default prompt from Uniswap/ai-toolkit repository"

            # Check if WORKFLOW_PAT is available for cross-repo access
            if [ -z "$WORKFLOW_PAT" ]; then
              echo "‚ùå WORKFLOW_PAT secret is required to fetch default prompt from Uniswap/ai-toolkit"
              echo "   Either provide a custom_prompt, custom_prompt_path, or set the WORKFLOW_PAT secret"
              exit 1
            fi

            # Fetch default prompt via GitHub API using WORKFLOW_PAT for cross-repo access
            if ! curl -fSs -H "Authorization: token $WORKFLOW_PAT" \
                      -H "Accept: application/vnd.github.v4.raw" \
                      -L "https://api.github.com/repos/Uniswap/ai-toolkit/contents/.github/prompts/default-pr-review.md" \
                      -o /tmp/default-prompt.md 2>&1 | tee /tmp/curl-error.log; then
              echo "‚ùå Failed to fetch default prompt from Uniswap/ai-toolkit"
              echo "   Error details:"
              cat /tmp/curl-error.log | head -5
              exit 1
            fi

            CUSTOM_PROMPT=$(cat /tmp/default-prompt.md)
            echo "‚úÖ Loaded default prompt from Uniswap/ai-toolkit"
          fi

          # Parse repository owner and name from REPO (format: owner/repo)
          REPO_OWNER=$(echo "$REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$REPO" | cut -d'/' -f2)

          # Build final prompt with review context
          # Note: JSON output format is enforced by --json-schema flag, not prompt instructions
          cat > /tmp/final-prompt.txt <<PROMPT_EOF
          # Review Context

          **Repository Owner:** $REPO_OWNER
          **Repository Name:** $REPO_NAME
          **PR Number:** $PR_NUMBER
          **Base Branch:** $BASE_REF
          **Patch ID:** $PATCH_ID

          ---

          PROMPT_EOF

          # Append custom prompt content
          echo "$CUSTOM_PROMPT" >> /tmp/final-prompt.txt

          # Append existing comments context for re-reviews
          if [ "$EXISTING_COMMENT_COUNT" -gt 0 ]; then
            cat >> /tmp/final-prompt.txt <<EXISTING_COMMENTS_EOF

          ---

          # Existing Review Comments

          The following review comments already exist on this PR. Check if issues have been addressed:

          \`\`\`json
          $(cat /tmp/existing-comments.json)
          \`\`\`

          For each existing comment, if the issue has been fixed in the current code, include a response
          in your \`inline_comments_responses\` array with \`should_resolve: true\`.
          EXISTING_COMMENTS_EOF
            echo "‚ú® Added existing comments context for re-review"
          fi

          # Append fast-review mode instructions for trivial PRs
          IS_TRIVIAL="${{ steps.pr-size.outputs.is_trivial }}"
          if [ "$IS_TRIVIAL" = "true" ]; then
            cat >> /tmp/final-prompt.txt <<TRIVIAL_MODE_EOF

          ---

          # üöÄ Fast Review Mode (Trivial PR)

          This PR has fewer than 20 lines of changes. Use an expedited review process:

          1. **Quick scan**: Review changed files briefly
          2. **Focus on critical issues only**: Bugs, security vulnerabilities, breaking changes
          3. **Skip comprehensive analysis**: Don't need detailed maintainability or improvement suggestions
          4. **Minimal inline comments**: If the PR only modifies auto-generated files (lockfiles, snapshots), use an empty \`inline_comments_new\` array
          5. **Fast verdict**: Complete quickly with appropriate outcome

          **Goal**: Provide value while minimizing review cost for small changes.
          TRIVIAL_MODE_EOF
            echo "‚ú® Added fast-review mode instructions for trivial PR"
          fi

          # Append field guidance for the structured output
          # Note: The actual JSON schema is enforced via --json-schema flag
          cat >> /tmp/final-prompt.txt <<JSON_GUIDANCE_EOF

          ---

          # üìã Output Field Guidance

          Your structured output will be validated against a JSON schema. Here's how to use each field:

          **Required fields:**
          - \`pr_review_body\`: Your complete markdown-formatted review. Put ALL your analysis, findings, and reasoning here.
          - \`pr_review_outcome\`: Your review decision:
            - \`APPROVE\`: No blocking issues, code is safe to merge
            - \`REQUEST_CHANGES\`: Critical bugs, security vulnerabilities, or data loss risks
            - \`COMMENT\`: Suggestions and improvements, but not blocking merge
          - \`inline_comments_new\`: Array of inline comments on specific lines (can be empty \`[]\`)
            - Each needs: \`path\` (file), \`line\` (number), \`body\` (feedback)
            - Optional: \`suggestion\` (corrected code snippet)

          **Optional fields:**
          - \`inline_comments_responses\`: Responses to existing review comments (for re-reviews)
            - Each needs: \`comment_id\`, \`body\`, and optionally \`should_resolve: true\`
          - \`files_reviewed\`: List of files you reviewed
          - \`confidence\`: 0.0-1.0 confidence in your review
          JSON_GUIDANCE_EOF
          echo "‚úÖ Added output field guidance"

          # Log final prompt length
          PROMPT_LENGTH=$(wc -c < /tmp/final-prompt.txt)
          echo "‚úÖ Built final prompt: $PROMPT_LENGTH characters"

          # Export as output for next step
          {
            echo "final_prompt<<PROMPT_DELIMITER_EOF"
            cat /tmp/final-prompt.txt
            echo "PROMPT_DELIMITER_EOF"
          } >> $GITHUB_OUTPUT

          # Show first few lines for debugging
          echo ""
          echo "üìÑ Prompt preview (first 10 lines):"
          head -n 10 /tmp/final-prompt.txt

      # Build Claude arguments - READ-ONLY tools only (no GitHub write tools)
      - name: Build Claude Arguments
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: build-args
        env:
          INPUT_ALLOWED_TOOLS: ${{ inputs.allowed_tools }}
          INPUT_MAX_TURNS: ${{ inputs.max_turns }}
          INPUT_MODEL: ${{ inputs.model }}
        run: |
          # Build allowed tools list - READ-ONLY tools only
          # Claude outputs JSON, the post-review script handles GitHub writes
          if [ -n "$INPUT_ALLOWED_TOOLS" ]; then
            ALLOWED_TOOLS="$INPUT_ALLOWED_TOOLS"
          else
            # Define read-only tools for analysis
            TOOLS=(
              # File operations (read-only)
              "Read"
              "Grep"
              "Glob"

              # Git commands for context (read-only)
              "Bash(git log:*)"
              "Bash(git diff:*)"
              "Bash(git show:*)"
              "Bash(git blame:*)"
              "Bash(git rev-parse:*)"

              # GitHub MCP tools (read-only, for fetching PR context)
              "mcp__github__get_pull_request"
              "mcp__github__get_pull_request_files"
              "mcp__github__get_pull_request_comments"
              "mcp__github__get_pull_request_reviews"
            )

            # Join array elements with commas (no spaces)
            ALLOWED_TOOLS=$(IFS=,; echo "${TOOLS[*]}")
          fi

          # Define JSON schema for structured output
          # This ensures Claude returns validated JSON matching our expected format
          JSON_SCHEMA='{
            "type": "object",
            "properties": {
              "pr_review_body": {
                "type": "string",
                "description": "Markdown-formatted review summary with all analysis"
              },
              "pr_review_outcome": {
                "type": "string",
                "enum": ["COMMENT", "APPROVE", "REQUEST_CHANGES"],
                "description": "Review decision"
              },
              "inline_comments_new": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "path": { "type": "string", "description": "File path" },
                    "line": { "type": "integer", "description": "Line number" },
                    "body": { "type": "string", "description": "Comment text" },
                    "suggestion": { "type": "string", "description": "Optional code suggestion" }
                  },
                  "required": ["path", "line", "body"]
                },
                "description": "New inline comments on specific lines"
              },
              "inline_comments_responses": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "comment_id": { "type": "integer", "description": "ID of existing comment" },
                    "body": { "type": "string", "description": "Response text" },
                    "should_resolve": { "type": "boolean", "description": "Whether to resolve the thread" }
                  },
                  "required": ["comment_id", "body"]
                },
                "description": "Responses to existing review comments"
              },
              "files_reviewed": {
                "type": "array",
                "items": { "type": "string" },
                "description": "List of files reviewed"
              },
              "confidence": {
                "type": "number",
                "minimum": 0,
                "maximum": 1,
                "description": "Confidence level (0.0-1.0)"
              }
            },
            "required": ["pr_review_body", "pr_review_outcome", "inline_comments_new"]
          }'

          # Build claude_args conditionally based on provided inputs
          CLAUDE_ARGS="--model $INPUT_MODEL"

          # Only add --max-turns if explicitly provided (not empty)
          if [ -n "$INPUT_MAX_TURNS" ]; then
            CLAUDE_ARGS="$CLAUDE_ARGS
            --max-turns $INPUT_MAX_TURNS"
            echo "‚ÑπÔ∏è  Including --max-turns $INPUT_MAX_TURNS"
          else
            echo "‚ÑπÔ∏è  Omitting --max-turns (unlimited turns)"
          fi

          # Add JSON schema for structured output (ensures validated JSON response)
          # Compact the schema to a single line for the CLI argument
          COMPACT_SCHEMA=$(echo "$JSON_SCHEMA" | jq -c .)
          CLAUDE_ARGS="$CLAUDE_ARGS
            --json-schema '$COMPACT_SCHEMA'
            --allowedTools $ALLOWED_TOOLS"

          echo "allowed_tools=$ALLOWED_TOOLS" >> $GITHUB_OUTPUT
          echo "claude_args<<CLAUDE_ARGS_EOF" >> $GITHUB_OUTPUT
          echo "$CLAUDE_ARGS" >> $GITHUB_OUTPUT
          echo "CLAUDE_ARGS_EOF" >> $GITHUB_OUTPUT
          echo "‚úÖ Configured structured output with JSON schema"
          echo "‚úÖ Configured read-only tools (${#ALLOWED_TOOLS} chars)"

      # Run Claude Code Action to perform the review (analysis only, outputs JSON)
      - name: Run Claude Code Review
        if: steps.cache-check.outputs.cache-hit != 'true'
        id: claude
        uses: anthropics/claude-code-action@a7e4c51380c42dd89b127f5e5f9be7b54020bc6b # v1.0.21
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          prompt: ${{ steps.build-prompt.outputs.final_prompt }}
          # Disable built-in progress tracking - we handle our own PR comments
          track_progress: false
          # Show full Claude output in logs for debugging
          show_full_output: false
          allowed_bots: dependabot
          claude_args: ${{ steps.build-args.outputs.claude_args }}
          additional_permissions: |
            actions: read

      # Setup Node.js for the post-review script
      - name: Setup Node.js
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af # v4.1.0
        with:
          node-version: "22"

      # Extract Claude's structured output (validated JSON from --json-schema)
      - name: Extract Claude Response
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        id: extract-response
        env:
          STRUCTURED_OUTPUT: ${{ steps.claude.outputs.structured_output }}
        run: |
          set -euo pipefail

          echo "‚ÑπÔ∏è  Extracting structured output from Claude..."

          # The structured_output is already validated JSON from --json-schema
          if [ -z "$STRUCTURED_OUTPUT" ]; then
            echo "‚ùå No structured_output from Claude"
            echo "   This may indicate the --json-schema flag wasn't processed correctly"
            exit 1
          fi

          # Save the structured output for the post-review script
          echo "$STRUCTURED_OUTPUT" > /tmp/claude-review-response.txt
          echo "‚úÖ Extracted structured output (${#STRUCTURED_OUTPUT} chars)"

          # Show preview and validate it's proper JSON
          echo "üìã Response preview:"
          echo "$STRUCTURED_OUTPUT" | jq -r '.pr_review_outcome // "unknown"' | xargs -I{} echo "  Outcome: {}"
          echo "$STRUCTURED_OUTPUT" | jq -r '.inline_comments_new | length' | xargs -I{} echo "  Inline comments: {}"
          echo "$STRUCTURED_OUTPUT" | jq -r '.confidence // "not set"' | xargs -I{} echo "  Confidence: {}"

      # Upload Claude execution output as artifact for debugging
      - name: Upload Claude Execution Output
        if: steps.cache-check.outputs.cache-hit != 'true' && always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: claude-execution-output-pr${{ inputs.pr_number }}
          path: /home/runner/work/_temp/claude-execution-output.json
          retention-days: 7
          if-no-files-found: warn

      # Download post-review script if running from external repository
      # When running from ai-toolkit itself, use the local file
      - name: Setup Post Review Script
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        id: setup-script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          WORKFLOW_PAT: ${{ secrets.WORKFLOW_PAT }}
          # github.job_workflow_sha is the commit SHA of the reusable workflow file
          # This is the SHA of the ai-toolkit commit that the workflow was called from
          # e.g., if caller uses @next, this is the HEAD commit of the next branch
          # if caller uses @39bfb2d..., this is that exact commit
          JOB_WORKFLOW_SHA: ${{ github.job_workflow_sha }}
        run: |
          set -euo pipefail

          # Check if we're running from the ai-toolkit repository
          if [ "$GITHUB_REPOSITORY" = "Uniswap/ai-toolkit" ]; then
            echo "‚ÑπÔ∏è  Running from ai-toolkit - using local post-review.ts"
            echo "script_path=.github/scripts/post-review.ts" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è  Running from external repository - downloading post-review.ts from Uniswap/ai-toolkit"
            echo "‚ÑπÔ∏è  Using reusable workflow SHA: $JOB_WORKFLOW_SHA"

            # Download the script from ai-toolkit repository at the exact commit of the workflow
            if ! curl -fSs -H "Authorization: token $WORKFLOW_PAT" \
                      -H "Accept: application/vnd.github.v4.raw" \
                      -L "https://api.github.com/repos/Uniswap/ai-toolkit/contents/.github/scripts/post-review.ts?ref=${JOB_WORKFLOW_SHA}" \
                      -o /tmp/post-review.ts 2>&1 | tee /tmp/curl-error.log; then
              echo "‚ùå Failed to download post-review.ts from Uniswap/ai-toolkit@${JOB_WORKFLOW_SHA}"
              echo "   Error details:"
              cat /tmp/curl-error.log | head -5
              exit 1
            fi

            echo "‚úÖ Downloaded post-review.ts from SHA: $JOB_WORKFLOW_SHA"
            echo "script_path=/tmp/post-review.ts" >> $GITHUB_OUTPUT
          fi

      # Post the review using our script (all comments as github-actions[bot])
      - name: Post Review via Script
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        id: post-review
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # WORKFLOW_PAT is used for GraphQL operations (resolving review threads)
          # that require elevated permissions beyond what GITHUB_TOKEN provides
          GH_TOKEN_FOR_GRAPHQL: ${{ secrets.WORKFLOW_PAT || secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          # Pass file path instead of content to avoid shell injection risks
          # The script reads the file directly, avoiding shell expansion of content
          REVIEW_JSON_FILE: /tmp/claude-review-response.txt
          # Script path determined by setup-script step (local or downloaded)
          POST_REVIEW_SCRIPT: ${{ steps.setup-script.outputs.script_path }}
        run: |
          set -euo pipefail

          echo "‚ÑπÔ∏è  Parsing Claude's review output and posting to GitHub..."
          echo "‚ÑπÔ∏è  Using script: $POST_REVIEW_SCRIPT"

          # Parse owner and repo
          REPO_OWNER=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f1)
          REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2)

          # Verify the response file exists
          if [ ! -f "$REVIEW_JSON_FILE" ]; then
            echo "‚ùå No review response file found at $REVIEW_JSON_FILE"
            exit 1
          fi

          # Check that the file has content
          if [ ! -s "$REVIEW_JSON_FILE" ]; then
            echo "‚ùå No review output from Claude (file is empty)"
            exit 1
          fi

          echo "‚ÑπÔ∏è  Review response length: $(wc -c < "$REVIEW_JSON_FILE") bytes"

          # Run the post-review script (path from setup-script step)
          # REVIEW_JSON_FILE env var is passed to the script, which reads the file directly
          # This avoids shell expansion of file content (shell injection safe)
          npx tsx "$POST_REVIEW_SCRIPT" \
            --owner "$REPO_OWNER" \
            --repo "$REPO_NAME" \
            --pr-number "$PR_NUMBER"

          echo "‚úÖ Review posted successfully"

      # Fallback: Post review summary as PR comment if script fails
      - name: Fallback Review Comment
        if: steps.cache-check.outputs.cache-hit != 'true' && failure()
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: |
          set -euo pipefail

          echo "‚ö†Ô∏è  Script failed, posting Claude's output as comment fallback..."

          COMMENT_MARKER="<!-- claude-pr-review-bot -->"
          JOB_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          # Try to read the extracted response, fallback to execution file
          if [ -f /tmp/claude-review-response.txt ]; then
            SUMMARY=$(cat /tmp/claude-review-response.txt)
          elif [ -f /home/runner/work/_temp/claude-execution-output.json ]; then
            SUMMARY=$(cat /home/runner/work/_temp/claude-execution-output.json | head -c 10000)
          else
            SUMMARY="No review output available"
          fi

          # Generate fallback comment
          COMMENT_BODY=$(cat <<EOF
          ${COMMENT_MARKER}
          ## ü§ñ Claude Code Review

          **Status:** ‚ö†Ô∏è Partial (script error)
          **Job:** [View workflow run](${JOB_URL})

          ---

          The review was completed but there was an error posting inline comments.

          <details>
          <summary>Raw Review Output</summary>

          \`\`\`
          ${SUMMARY:0:10000}
          \`\`\`

          </details>

          ---

          *Please check the workflow logs for details.*
          EOF
          )

          # Post as PR comment
          gh api "/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" \
            -X POST \
            -f body="$COMMENT_BODY" \
            > /dev/null

          echo "‚úÖ Fallback comment posted"

      # Post error comment if Claude completely fails (no output at all)
      - name: Post Review Error Comment
        if: steps.cache-check.outputs.cache-hit != 'true' && failure() && steps.claude.conclusion == 'failure'
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          COMMENT_MARKER="<!-- claude-pr-review-bot -->"
          JOB_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          echo "‚ÑπÔ∏è  Posting review error comment" >&2

          # Generate error comment body
          COMMENT_BODY=$(cat <<EOF
          ${COMMENT_MARKER}
          ## ü§ñ Claude Code Review

          **Status:** ‚ùå Error
          **Job:** [View workflow run](${JOB_URL})

          ---

          ### ‚ö†Ô∏è Review Failed

          The automated code review encountered an error and could not complete.

          **Next Steps:**
          1. Check the [workflow logs](${JOB_URL}) for details
          2. Verify the GitHub Actions configuration
          3. Ensure the Anthropic API key is valid
          4. Check for any permission issues

          If the problem persists, please contact your repository administrator.

          ---

          *You can manually re-trigger the review by pushing a new commit or re-running the workflow.*
          EOF
          )

          # Post comment
          gh api "/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" \
            -X POST \
            -f body="$COMMENT_BODY" \
            > /dev/null

          echo "‚úÖ Error comment posted" >&2

      # Save successful review to cache
      - name: Save Review Cache Marker
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        run: |
          mkdir -p .review-cache
          echo "${{ steps.patch-id.outputs.patch_id }}" > .review-cache/patch-id
          echo "Cached review for patch-ID: ${{ steps.patch-id.outputs.patch_id }}"

      # Persist cache for future rebase detection
      - name: Cache Review State
        if: steps.cache-check.outputs.cache-hit != 'true' && success()
        uses: actions/cache/save@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: .review-cache
          key: review-pr${{ inputs.pr_number }}-patch-${{ steps.patch-id.outputs.patch_id }}
