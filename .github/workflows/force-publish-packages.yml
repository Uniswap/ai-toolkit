name: Force Publish Packages

# This workflow allows manually force-publishing packages to npm with the 'next' tag.
# It is useful for publishing new packages that haven't had code changes detected,
# or for republishing packages after failed releases.
#
# REQUIRED SECRETS:
# 1. WORKFLOW_PAT: Personal Access Token with 'repo' and 'workflow' scopes
#    - Required to push version commits and tags back to the repository
# 2. NODE_AUTH_TOKEN: NPM authentication token
#    - Required to publish packages to NPM registry
# 3. SERVICE_ACCOUNT_GPG_PRIVATE_KEY: GPG key for signing commits
#    - Required for signed commits and tags
#
# USAGE:
# - Select packages to publish: single package name, comma-separated list, or 'all'
# - Examples:
#   - Single: "@uniswap/ai-toolkit-nx-claude"
#   - Multiple: "@uniswap/ai-toolkit-nx-claude,@ai-toolkit/utils"
#   - All: "all" (publishes all release-configured packages)
#
# BEHAVIOR:
# - Increments the prerelease version (e.g., 0.5.5-next.10 ‚Üí 0.5.5-next.11)
# - Publishes to npm with the 'next' tag
# - Creates git commits and tags for version bumps

on:
  workflow_dispatch:
    inputs:
      packages:
        description: 'Packages to publish (single name, comma-separated list, or "all")'
        required: true
        default: 'all'
        type: string
      dryRun:
        description: 'Perform a dry run without publishing'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

# Ensure only one force-publish workflow runs at a time
concurrency:
  group: force-publish-${{ github.ref }}
  cancel-in-progress: false

jobs:
  validate:
    runs-on: ubuntu-24.04
    outputs:
      packages: ${{ steps.resolve-packages.outputs.packages }}
      projects: ${{ steps.resolve-packages.outputs.projects }}
      package_count: ${{ steps.resolve-packages.outputs.package_count }}
    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - name: Validate branch
        run: |
          if [[ "${{ github.ref_name }}" != "next" ]]; then
            echo "‚ùå ERROR: Force publish is only allowed on the 'next' branch"
            echo "Current branch: ${{ github.ref_name }}"
            echo "This workflow publishes with the 'next' npm tag and should only run on the next branch."
            exit 1
          fi
          echo "‚úÖ Branch validation passed - running on 'next' branch"

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Setup Node.js
        uses: actions/setup-node@2028fbc5c25fe9cf00d9f06a71cc4710d4507903 # v6.0.0
        with:
          node-version: '22.21.1'
          registry-url: 'https://registry.npmjs.org'
          scope: '@uniswap'

      - name: Install npm
        run: npm install -g npm@11.6.2

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Resolve packages to publish
        id: resolve-packages
        run: |
          INPUT_PACKAGES="${{ github.event.inputs.packages }}"
          echo "Input packages: $INPUT_PACKAGES"

          # Get all release-configured packages from nx.json
          ALL_PACKAGES=$(npx nx show projects --json 2>/dev/null | jq -r '.[]' | while read project; do
            PROJECT_ROOT=$(npx nx show project "$project" --json 2>/dev/null | jq -r '.root' || echo "")
            if [ -n "$PROJECT_ROOT" ] && [ -f "$PROJECT_ROOT/package.json" ]; then
              IS_PRIVATE=$(jq -r '.private // false' "$PROJECT_ROOT/package.json")
              if [ "$IS_PRIVATE" != "true" ]; then
                PACKAGE_NAME=$(jq -r '.name // ""' "$PROJECT_ROOT/package.json")
                if [ -n "$PACKAGE_NAME" ]; then
                  # Check if this package is in the nx.json release.projects array
                  if jq -e --arg pkg "$PACKAGE_NAME" '.release.projects | index($pkg)' nx.json > /dev/null 2>&1; then
                    echo "$project:$PACKAGE_NAME"
                  fi
                fi
              fi
            fi
          done)

          echo "All release-configured packages:"
          echo "$ALL_PACKAGES"

          if [[ "$INPUT_PACKAGES" == "all" ]]; then
            # Use all release-configured packages
            SELECTED_PROJECTS=$(echo "$ALL_PACKAGES" | cut -d: -f1 | tr '\n' ',' | sed 's/,$//')
            SELECTED_PACKAGES=$(echo "$ALL_PACKAGES" | cut -d: -f2 | tr '\n' ',' | sed 's/,$//')
          else
            # Parse comma-separated input and match to projects
            SELECTED_PROJECTS=""
            SELECTED_PACKAGES=""
            IFS=',' read -ra INPUT_PKG_ARRAY <<< "$INPUT_PACKAGES"

            for input_pkg in "${INPUT_PKG_ARRAY[@]}"; do
              # Trim whitespace
              input_pkg=$(echo "$input_pkg" | xargs)

              # Find the matching project
              MATCH=$(echo "$ALL_PACKAGES" | grep ":${input_pkg}$" || echo "")

              if [ -z "$MATCH" ]; then
                echo "‚ùå ERROR: Package '$input_pkg' not found in release configuration"
                echo "Available packages:"
                echo "$ALL_PACKAGES" | cut -d: -f2
                exit 1
              fi

              PROJECT=$(echo "$MATCH" | cut -d: -f1)
              PACKAGE=$(echo "$MATCH" | cut -d: -f2)

              if [ -n "$SELECTED_PROJECTS" ]; then
                SELECTED_PROJECTS="${SELECTED_PROJECTS},${PROJECT}"
                SELECTED_PACKAGES="${SELECTED_PACKAGES},${PACKAGE}"
              else
                SELECTED_PROJECTS="$PROJECT"
                SELECTED_PACKAGES="$PACKAGE"
              fi
            done
          fi

          echo "Selected Nx projects: $SELECTED_PROJECTS"
          echo "Selected npm packages: $SELECTED_PACKAGES"

          # Count packages
          PACKAGE_COUNT=$(echo "$SELECTED_PACKAGES" | tr ',' '\n' | grep -c '.' || echo "0")

          echo "projects=$SELECTED_PROJECTS" >> $GITHUB_OUTPUT
          echo "packages=$SELECTED_PACKAGES" >> $GITHUB_OUTPUT
          echo "package_count=$PACKAGE_COUNT" >> $GITHUB_OUTPUT

          if [ "$PACKAGE_COUNT" -eq "0" ]; then
            echo "‚ùå ERROR: No packages selected for publishing"
            exit 1
          fi

          echo "‚úÖ Resolved $PACKAGE_COUNT package(s) for publishing"

  force-publish:
    needs: validate
    runs-on:
      group: npm-deploy
    permissions:
      id-token: write
      contents: write
      packages: write
    outputs:
      successful_packages: ${{ steps.publish.outputs.successful_packages }}
      failed_packages: ${{ steps.publish.outputs.failed_packages }}
      successful_count: ${{ steps.publish.outputs.successful_count }}
      failed_count: ${{ steps.publish.outputs.failed_count }}

    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec # v6
        with:
          gpg_private_key: ${{ secrets.SERVICE_ACCOUNT_GPG_PRIVATE_KEY }}
          git_user_signingkey: true
          git_commit_gpgsign: true
          git_tag_gpgsign: true
          git_config_global: true

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: Setup Node.js
        uses: actions/setup-node@2028fbc5c25fe9cf00d9f06a71cc4710d4507903 # v6.0.0
        with:
          node-version: '22.21.1'
          registry-url: 'https://registry.npmjs.org'
          scope: '@uniswap'

      - name: Install npm
        run: npm install -g npm@11.6.2

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Configure Git identity for service account
        run: |
          git config user.name "Uniswap Labs Service Account"
          git config user.email "hello-happy-puppy@uniswap.org"

      - name: Verify GPG configuration
        run: |
          echo "GPG signing enabled: $(git config commit.gpgsign)"
          echo "GPG signing key: $(git config user.signingkey)"
          echo "Git user name: $(git config user.name)"
          echo "Git user email: $(git config user.email)"

      - name: Build selected packages
        run: |
          PROJECTS="${{ needs.validate.outputs.projects }}"
          echo "Building packages: $PROJECTS"

          # Build each project
          IFS=',' read -ra PROJECT_ARRAY <<< "$PROJECTS"
          for project in "${PROJECT_ARRAY[@]}"; do
            echo "Building $project..."
            npx nx build "$project"
          done

      - name: Version and publish packages (dry run)
        if: github.event.inputs.dryRun == 'true'
        run: |
          PROJECTS="${{ needs.validate.outputs.projects }}"
          echo "=========================================="
          echo "DRY RUN - Force Publish"
          echo "=========================================="
          echo "Projects: $PROJECTS"
          echo ""

          IFS=',' read -ra PROJECT_ARRAY <<< "$PROJECTS"
          for project in "${PROJECT_ARRAY[@]}"; do
            echo "-------------------------------------------"
            echo "Processing: $project"
            echo "-------------------------------------------"

            echo "Versioning (dry run)..."
            npx nx release version prerelease --preid=next --projects="$project" --dry-run

            echo ""
            echo "Publishing (dry run)..."
            npx nx release publish --projects="$project" --tag=next --dry-run

            echo ""
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Version and publish packages
        if: github.event.inputs.dryRun != 'true'
        id: publish
        run: |
          # Configure npm authentication
          echo "//registry.npmjs.org/:_authToken=${NODE_AUTH_TOKEN}" > ~/.npmrc
          echo "Configured npm authentication"
          echo ""

          PROJECTS="${{ needs.validate.outputs.projects }}"
          PACKAGES="${{ needs.validate.outputs.packages }}"

          echo "=========================================="
          echo "FORCE PUBLISH - Prerelease Versions"
          echo "=========================================="
          echo "Nx projects: $PROJECTS"
          echo "npm packages: $PACKAGES"
          echo ""
          echo "Strategy:"
          echo "  1. Version each package (prerelease bump)"
          echo "  2. Publish to npm with 'next' tag"
          echo "  3. Push commit + tag to remote"
          echo ""

          # Convert comma-separated lists to arrays
          IFS=',' read -ra PROJECT_ARRAY <<< "$PROJECTS"
          IFS=',' read -ra PACKAGE_ARRAY <<< "$PACKAGES"

          # Track results
          FAILED_PACKAGES=()
          SUCCESS_PACKAGES=()

          # Process each package
          for i in "${!PROJECT_ARRAY[@]}"; do
            project="${PROJECT_ARRAY[$i]}"
            package="${PACKAGE_ARRAY[$i]}"

            if [ -z "$project" ] || [ -z "$package" ]; then
              continue
            fi

            echo "=========================================="
            echo "Processing: $project ‚Üí $package"
            echo "=========================================="

            # Extract package name without scope
            PACKAGE_NAME=$(echo "$package" | sed 's/@[^/]*\///')

            # Step 1: Version the package
            echo ""
            echo "Step 1: Versioning package (prerelease)..."
            if ! npx nx release version prerelease --preid=next --projects="$project"; then
              echo "‚ùå Failed to version $package"
              FAILED_PACKAGES+=("$package")
              echo ""
              continue
            fi
            echo "‚úÖ Versioning complete"

            # Get the new version
            PROJECT_ROOT=$(npx nx show project "$project" --json 2>/dev/null | jq -r '.root' || echo "")
            NEW_VERSION=$(jq -r '.version' "$PROJECT_ROOT/package.json")
            echo "New version: $NEW_VERSION"

            # Step 2: Publish to npm
            echo ""
            echo "Step 2: Publishing to npm..."

            # Check if package exists on npm
            if npm view "$package" version --registry=https://registry.npmjs.org &>/dev/null; then
              echo "üì¶ Status: EXISTING package on npm"
              PUBLISH_CMD="npx nx release publish --projects=\"$project\" --tag=next --registry=https://registry.npmjs.org"
            else
              echo "üÜï Status: NEW package (not found on npm)"
              PUBLISH_CMD="npx nx release publish --projects=\"$project\" --first-release --tag=next --registry=https://registry.npmjs.org"
            fi

            if eval "$PUBLISH_CMD"; then
              echo "‚úÖ Successfully published $package@$NEW_VERSION to npm"

              # Step 3: Push commit and tag
              echo ""
              echo "Step 3: Pushing commit and tag to remote..."

              PUSH_FAILED=false

              # Push version commit
              echo "üì§ Pushing version commit to next..."
              if git push origin next; then
                echo "‚úÖ Successfully pushed version commit"
              else
                if git fetch origin next && git diff --quiet HEAD origin/next; then
                  echo "‚úÖ Branch already up to date"
                else
                  echo "‚ùå CRITICAL: Failed to push version commit!"
                  PUSH_FAILED=true
                fi
              fi

              # Push git tag
              PACKAGE_TAG=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -V | tail -n 1)
              if [ -n "$PACKAGE_TAG" ]; then
                echo "üè∑Ô∏è  Pushing tag: $PACKAGE_TAG"
                if git push origin "$PACKAGE_TAG"; then
                  echo "‚úÖ Successfully pushed tag"
                else
                  if git ls-remote --tags origin | grep -q "refs/tags/$PACKAGE_TAG$"; then
                    echo "‚úÖ Tag already exists on remote"
                  else
                    echo "‚ùå Failed to push tag!"
                    PUSH_FAILED=true
                  fi
                fi
              fi

              if [ "$PUSH_FAILED" = true ]; then
                echo "‚ö†Ô∏è  Published to npm but git sync incomplete"
              fi

              SUCCESS_PACKAGES+=("$package")
              echo ""
              echo "‚úÖ Package $package@$NEW_VERSION published successfully!"

            else
              echo "‚ùå Failed to publish $package"

              # Revert local changes
              echo ""
              echo "Step 3: Reverting local changes..."

              TAG_TO_DELETE=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | grep "@${NEW_VERSION}$" | head -n 1)
              if [ -n "$TAG_TO_DELETE" ]; then
                echo "  Deleting local tag: $TAG_TO_DELETE"
                git tag -d "$TAG_TO_DELETE" 2>/dev/null || true
              fi

              echo "  Resetting to previous commit..."
              git reset --hard HEAD~1

              FAILED_PACKAGES+=("$package")
              echo "‚èÆÔ∏è  Reverted local changes for $package"
            fi

            echo ""
          done

          # Output results
          SUCCESS_JSON=$(printf '%s\n' "${SUCCESS_PACKAGES[@]}" | jq -R . | jq -s -c .)
          FAILED_JSON=$(printf '%s\n' "${FAILED_PACKAGES[@]}" | jq -R . | jq -s -c .)

          echo "successful_packages=$SUCCESS_JSON" >> $GITHUB_OUTPUT
          echo "failed_packages=$FAILED_JSON" >> $GITHUB_OUTPUT
          echo "successful_count=${#SUCCESS_PACKAGES[@]}" >> $GITHUB_OUTPUT
          echo "failed_count=${#FAILED_PACKAGES[@]}" >> $GITHUB_OUTPUT

          # Summary
          echo "=========================================="
          echo "Force Publish Summary"
          echo "=========================================="
          echo "Successful: ${#SUCCESS_PACKAGES[@]} package(s)"
          for pkg in "${SUCCESS_PACKAGES[@]}"; do
            echo "  ‚úÖ $pkg"
          done

          if [ ${#FAILED_PACKAGES[@]} -gt 0 ]; then
            echo ""
            echo "Failed: ${#FAILED_PACKAGES[@]} package(s)"
            for pkg in "${FAILED_PACKAGES[@]}"; do
              echo "  ‚ùå $pkg"
            done
          fi

          # Fail if no packages published
          if [ ${#SUCCESS_PACKAGES[@]} -eq 0 ]; then
            echo ""
            echo "‚ùå No packages were successfully published."
            exit 1
          fi
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NODE_AUTH_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}

      - name: Create GitHub releases
        if: github.event.inputs.dryRun != 'true' && steps.publish.outputs.successful_count != '0'
        run: |
          SUCCESSFUL_PACKAGES='${{ steps.publish.outputs.successful_packages }}'
          echo "Creating GitHub releases for: $SUCCESSFUL_PACKAGES"

          readarray -t PACKAGES < <(echo "$SUCCESSFUL_PACKAGES" | jq -r '.[]')

          for package in "${PACKAGES[@]}"; do
            if [ -z "$package" ]; then
              continue
            fi

            PACKAGE_NAME=$(echo "$package" | sed 's/@[^/]*\///')
            LATEST_TAG=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -V | tail -n 1)

            if [ -n "$LATEST_TAG" ]; then
              VERSION="${LATEST_TAG##*@}"

              if gh release view "$LATEST_TAG" &>/dev/null; then
                echo "‚úì Release $LATEST_TAG already exists"
              else
                echo "Creating release for $LATEST_TAG"
                gh release create "$LATEST_TAG" \
                  --title "$package $VERSION" \
                  --notes "Force-published release $VERSION of $package (prerelease)." \
                  --prerelease \
                  --verify-tag
                echo "‚úÖ Created release for $LATEST_TAG"
              fi
            fi
          done
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}

      - name: Summary
        if: always()
        run: |
          echo "## üöÄ Force Publish Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ github.event.inputs.dryRun }}" = "true" ]; then
            echo "**Mode:** Dry Run (no changes made)" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Mode:** Live Publish" >> $GITHUB_STEP_SUMMARY
          fi

          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Packages requested:** ${{ needs.validate.outputs.package_count }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ github.event.inputs.dryRun }}" != "true" ]; then
            echo "### Results" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Successful:** ${{ steps.publish.outputs.successful_count || '0' }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Failed:** ${{ steps.publish.outputs.failed_count || '0' }}" >> $GITHUB_STEP_SUMMARY

            if [ -n "${{ steps.publish.outputs.successful_packages }}" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "#### Successfully Published" >> $GITHUB_STEP_SUMMARY
              echo '${{ steps.publish.outputs.successful_packages }}' | jq -r '.[]' | while read pkg; do
                echo "- ‚úÖ $pkg" >> $GITHUB_STEP_SUMMARY
              done
            fi

            if [ "${{ steps.publish.outputs.failed_count }}" != "0" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "#### Failed" >> $GITHUB_STEP_SUMMARY
              echo '${{ steps.publish.outputs.failed_packages }}' | jq -r '.[]' | while read pkg; do
                echo "- ‚ùå $pkg" >> $GITHUB_STEP_SUMMARY
              done
            fi
          fi
