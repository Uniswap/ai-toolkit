name: Publish Packages

# This workflow handles versioning, building, and publishing packages to NPM for both
# production (main branch) and pre-release (next branch) deployments.
#
# REQUIRED SECRETS:
# 1. WORKFLOW_PAT: Personal Access Token with 'repo' and 'workflow' scopes
#    - Required to push version commits and tags back to the repository
#    - Create at: GitHub Settings > Developer settings > Personal access tokens
# 2. ANTHROPIC_API_KEY: API key for AI-powered changelog generation
#    - Required to generate intelligent release changelogs
#    - Create at: https://console.anthropic.com/settings/keys
# 3. SLACK_WEBHOOK_URL: Incoming webhook URL for release notifications
#    - Required to send notifications to #ai-internal Slack channel
#    - Create at: https://api.slack.com/apps > Incoming Webhooks
# 4. NODE_AUTH_TOKEN: NPM authentication token
#    - Required to publish packages to NPM registry
#    - Create at: https://www.npmjs.com/settings/your-username/tokens
#
# WORKFLOW BEHAVIOR:
# - Triggered on push to 'main' or 'next' branches
# - Can be manually triggered with optional dry-run mode
# - Versions packages based on conventional commits
# - Publishes to NPM with appropriate tags (latest for main, next for next branch)
# - Generates AI-powered changelog for release notes
# - Sends Slack notification with changelog
# - Syncs 'next' branch with 'main' after production releases
#
# ARCHITECTURE:
# This workflow uses a multi-job orchestration pattern:
# 1. publish: Builds, versions, and publishes packages to NPM
# 2. generate-changelog: Generates AI-powered changelog using reusable workflow
# 3. notify-release: Sends Slack notification with changelog using reusable workflow
# 4. sync-next: Syncs 'next' branch with 'main' after production releases
#
# The changelog generation and notification are separated into reusable workflows
# for better maintainability and reusability across different workflows.

on:
  push:
    branches:
      - main
      - next
  workflow_dispatch:
    inputs:
      dryRun:
        description: 'Perform a dry run without publishing'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

# Ensure only one publish workflow runs at a time per branch
# If a new run is triggered while one is in progress, it will be queued
# Setting cancel-in-progress to false ensures queued runs execute sequentially
concurrency:
  group: publish-${{ github.ref }}
  cancel-in-progress: false

jobs:
  publish:
    runs-on:
      group: npm-deploy
    environment: ${{ github.event_name == 'push' && 'Production' || null }}
    permissions:
      id-token: write
      contents: write
      packages: write
      pull-requests: write
      issues: write
    outputs:
      has_affected: ${{ steps.affected.outputs.has_affected }}
      successful_packages: ${{ steps.publish.outputs.successful_packages }}
      failed_packages: ${{ steps.publish.outputs.failed_packages }}
      successful_count: ${{ steps.publish.outputs.successful_count }}
      failed_count: ${{ steps.publish.outputs.failed_count }}
      has_failures: ${{ steps.publish.outputs.has_failures }}
      has_successes: ${{ steps.publish.outputs.has_successes }}
    # Skip the workflow if the commit is a version bump (to prevent loops)
    # Allow workflow to run for merge commits from update-production workflow
    # Skip workflow for branch sync commits
    if: ${{ !startsWith(github.event.head_commit.message, 'chore(release):') && !startsWith(github.event.head_commit.message, 'chore(sync):') }}

    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: Setup Node.js
        uses: actions/setup-node@2028fbc5c25fe9cf00d9f06a71cc4710d4507903 # v6.0.0
        with:
          node-version: '22.21.1'
          registry-url: 'https://registry.npmjs.org'
          scope: '@uniswap'

      - name: Install npm
        run: npm install -g npm@11.6.2
        # IMPORTANT: Pinning to npm 11.6.2 for two reasons:
        # 1. OIDC trusted publishing requires npm >= 11.5.1
        # 2. Using a pinned version prevents lockfile format changes in CI
        # Local developers should use: npm install -g npm@11.6.2
      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Verify package-lock.json unchanged
        run: |
          if ! git diff --exit-code package-lock.json; then
            echo "‚ùå ERROR: npm ci modified package-lock.json!"
            echo "This should not happen. Please investigate why npm ci is modifying the lock file."
            git diff package-lock.json
            exit 1
          fi
          echo "‚úÖ package-lock.json unchanged after npm ci"

      - name: Configure Git
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

      - name: Determine npm tag
        id: npm-tag
        run: |
          if [[ "${{ github.ref_name }}" == "next" ]]; then
            echo "tag=next" >> $GITHUB_OUTPUT
            echo "Using 'next' tag for npm publish"
          else
            echo "tag=latest" >> $GITHUB_OUTPUT
            echo "Using 'latest' tag for npm publish"
          fi

      - name: Determine base SHA for affected detection
        id: base-sha
        run: |
          # For push events, use the commit before the push
          # For manual triggers, fall back to HEAD~1
          if [[ "${{ github.event_name }}" == "push" ]]; then
            BASE_SHA="${{ github.event.before }}"

            # Handle edge case: first push to a new branch (null SHA)
            if [[ "$BASE_SHA" == "0000000000000000000000000000000000000000" ]]; then
              echo "First push to branch - using HEAD~1 as base"
              echo "base=HEAD~1" >> $GITHUB_OUTPUT
            else
              echo "Using commit before push: $BASE_SHA"
              echo "base=$BASE_SHA" >> $GITHUB_OUTPUT
            fi
          else
            # Manual workflow dispatch - use previous commit
            echo "Manual trigger - using HEAD~1 as base"
            echo "base=HEAD~1" >> $GITHUB_OUTPUT
          fi

      - name: Determine affected packages
        id: affected
        run: |
          # Get affected projects using Nx
          echo "Running: npx nx show projects --affected --base=${{ steps.base-sha.outputs.base }} --head=HEAD --type=lib --json"

          # Capture output and check if it's valid JSON
          # Suppress Node.js deprecation warnings and npm warnings to avoid polluting JSON output
          RAW_OUTPUT=$(NODE_NO_WARNINGS=1 npx nx show projects --affected --base=${{ steps.base-sha.outputs.base }} --head=HEAD --type=lib --json 2>&1 || echo "[]")

          # Filter out npm warnings (lines starting with "npm warn")
          AFFECTED_OUTPUT=$(echo "$RAW_OUTPUT" | grep -v '^npm warn' || echo "[]")

          echo "AFFECTED_OUTPUT: $AFFECTED_OUTPUT"

          # Check if output is valid JSON
          if echo "$AFFECTED_OUTPUT" | jq empty 2>/dev/null; then
            AFFECTED_JSON="$AFFECTED_OUTPUT"
          else
            echo "‚ö†Ô∏è  Nx output is not valid JSON. Output:"
            echo "$AFFECTED_OUTPUT"
            echo "Using empty array as fallback"
            AFFECTED_JSON="[]"
          fi

          # Extract project names and filter out private packages
          # Read each project and check if it has "private": true in package.json
          echo "Filtering out private packages..."
          PUBLISHABLE_PROJECTS=()
          PACKAGE_NAMES=()

          for project in $(echo "$AFFECTED_JSON" | jq -r '.[]'); do
            # Find the package.json for this project
            # Use nx show project to get the project root
            PROJECT_ROOT=$(npx nx show project "$project" --json 2>/dev/null | jq -r '.root' || echo "")

            if [ -n "$PROJECT_ROOT" ] && [ -f "$PROJECT_ROOT/package.json" ]; then
              # Check if package is private
              IS_PRIVATE=$(jq -r '.private // false' "$PROJECT_ROOT/package.json")

              if [ "$IS_PRIVATE" = "true" ]; then
                echo "  ‚è≠Ô∏è  Skipping $project (private: true)"
              else
                PACKAGE_NAME=$(jq -r '.name // ""' "$PROJECT_ROOT/package.json")
                if [ -n "$PACKAGE_NAME" ]; then
                  echo "  ‚úÖ Including $project ‚Üí $PACKAGE_NAME (publishable)"
                  PUBLISHABLE_PROJECTS+=("$project")  # Store Nx project name
                  PACKAGE_NAMES+=("$PACKAGE_NAME")    # Store npm package name
                else
                  echo "  ‚ö†Ô∏è  Skipping $project (no package name found)"
                fi
              fi
            else
              echo "  ‚ö†Ô∏è  Skipping $project (no package.json found)"
            fi
          done

          # Join arrays with commas
          AFFECTED_PROJECTS=$(IFS=,; echo "${PUBLISHABLE_PROJECTS[*]}")
          AFFECTED_PACKAGES=$(IFS=,; echo "${PACKAGE_NAMES[*]}")

          echo "Publishable affected projects (Nx names): $AFFECTED_PROJECTS"
          echo "Publishable affected packages (npm names): $AFFECTED_PACKAGES"

          echo "projects=$AFFECTED_PROJECTS" >> $GITHUB_OUTPUT
          echo "packages=$AFFECTED_PACKAGES" >> $GITHUB_OUTPUT

          # Set a flag indicating if any packages are affected
          if [ -z "$AFFECTED_PROJECTS" ] || [ "$AFFECTED_PROJECTS" = "null" ]; then
            echo "has_affected=false" >> $GITHUB_OUTPUT
            echo "No publishable affected packages found - skipping release"
          else
            echo "has_affected=true" >> $GITHUB_OUTPUT
            echo "Found ${#PUBLISHABLE_PROJECTS[@]} publishable package(s)"
          fi

      - name: Build affected packages
        if: steps.affected.outputs.has_affected == 'true'
        run: |
          echo "Building affected packages: ${{ steps.affected.outputs.projects }}"
          npx nx affected --target=build --base=${{ steps.base-sha.outputs.base }} --head=HEAD

      - name: Clean up orphaned tags
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.affected.outputs.has_affected == 'true'
        run: |
          # Configure npm authentication for viewing restricted packages
          # The @uniswap packages are restricted and require authentication even for read operations
          echo "//registry.npmjs.org/:_authToken=${NODE_AUTH_TOKEN}" > ~/.npmrc
          echo "Configured npm authentication for restricted package queries"
          echo ""

          AFFECTED_PACKAGES="${{ steps.affected.outputs.packages }}"

          echo "=========================================="
          echo "Checking for orphaned Git tags"
          echo "=========================================="
          echo ""
          echo "Orphaned tags are Git tags that exist but their corresponding"
          echo "npm package version was never successfully published."
          echo "These must be cleaned up before versioning can proceed."
          echo ""

          # Convert comma-separated list to array
          IFS=',' read -ra PACKAGES <<< "$AFFECTED_PACKAGES"

          CLEANED_TAGS=()

          for package in "${PACKAGES[@]}"; do
            if [ -z "$package" ]; then
              continue
            fi

            echo "Checking package: $package"

            # Extract the package name without scope for tag checking
            PACKAGE_NAME=$(echo "$package" | sed 's/@[^/]*\///')

            # Get the latest tag for this package
            LATEST_TAG=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -V | tail -n 1)

            if [ -z "$LATEST_TAG" ]; then
              echo "  ‚ÑπÔ∏è  No tags found - will create first tag during versioning"
              echo ""
              continue
            fi

            # Extract version from tag
            VERSION="${LATEST_TAG##*@}"
            echo "  Latest tag: $LATEST_TAG (version: $VERSION)"

            # Check if this specific version exists on npm
            if npm view "${package}@${VERSION}" version --registry=https://registry.npmjs.org &>/dev/null; then
              echo "  ‚úÖ Version $VERSION exists on npm - tag is valid"
              echo ""
            else
              echo "  ‚ö†Ô∏è  Version $VERSION NOT found on npm - tag is orphaned!"
              echo "  üßπ Deleting orphaned tag: $LATEST_TAG"

              # Delete tag locally
              if git tag -d "$LATEST_TAG" 2>/dev/null; then
                echo "  ‚úÖ Deleted local tag"
              else
                echo "  ‚ö†Ô∏è  Local tag already deleted or doesn't exist"
              fi

              # Delete tag from remote
              if git push --delete origin "$LATEST_TAG" 2>/dev/null; then
                echo "  ‚úÖ Deleted remote tag"
                CLEANED_TAGS+=("$LATEST_TAG")
              else
                echo "  ‚ö†Ô∏è  Remote tag already deleted or doesn't exist"
              fi

              echo ""
            fi
          done

          echo ""
          echo "=========================================="
          echo "Checking for missing Git tags"
          echo "=========================================="
          echo ""
          echo "Missing tags are npm versions that were successfully"
          echo "published but their Git tags were never pushed to remote."
          echo "These must be created so Nx can properly version from them."
          echo ""

          CREATED_TAGS=()

          for package in "${PACKAGES[@]}"; do
            if [ -z "$package" ]; then
              continue
            fi

            echo "Checking package: $package"

            # Get latest version from npm for the appropriate dist-tag
            if [[ "${{ github.ref_name }}" == "next" ]]; then
              LATEST_NPM=$(npm view "$package" dist-tags.next --registry=https://registry.npmjs.org 2>/dev/null || echo "")
              echo "  Querying npm dist-tag 'next'..."
            else
              LATEST_NPM=$(npm view "$package" version --registry=https://registry.npmjs.org 2>/dev/null || echo "")
              echo "  Querying npm version (latest)..."
            fi

            if [ -z "$LATEST_NPM" ]; then
              echo "  ‚ÑπÔ∏è  Package not on npm yet (will be first release)"
              echo ""
              continue
            fi

            EXPECTED_TAG="${package}@${LATEST_NPM}"
            echo "  Latest npm version: $LATEST_NPM"

            # Check if Git tag exists for this version
            if git rev-parse "$EXPECTED_TAG" >/dev/null 2>&1; then
              echo "  ‚úÖ Git tag exists: $EXPECTED_TAG (in sync)"
            else
              echo "  üîß Git tag missing for npm version $LATEST_NPM"
              echo "  üè∑Ô∏è  Creating tag: $EXPECTED_TAG"

              # Create tag at current HEAD
              # (Assumes HEAD is at or past the commit where this version was published)
              if git tag "$EXPECTED_TAG" HEAD 2>/dev/null; then
                echo "  ‚úÖ Created local tag at HEAD"
                CREATED_TAGS+=("$EXPECTED_TAG")
              else
                echo "  ‚ö†Ô∏è  Failed to create tag (may already exist locally)"
              fi
            fi

            echo ""
          done

          # Summary
          echo "=========================================="
          echo "Git/npm Sync Summary"
          echo "=========================================="

          if [ ${#CLEANED_TAGS[@]} -gt 0 ]; then
            echo "Orphaned Tags Cleaned (deleted): ${#CLEANED_TAGS[@]}"
            for tag in "${CLEANED_TAGS[@]}"; do
              echo "  üßπ $tag"
            done
            echo "  ‚Üí These will be recreated with correct associations"
          else
            echo "Orphaned Tags Cleaned: 0"
            echo "  ‚úÖ No orphaned tags found"
          fi

          echo ""

          if [ ${#CREATED_TAGS[@]} -gt 0 ]; then
            echo "Missing Tags Created: ${#CREATED_TAGS[@]}"
            for tag in "${CREATED_TAGS[@]}"; do
              echo "  üè∑Ô∏è  $tag"
            done
            echo "  ‚Üí Nx will now use these as base for version bumps"
          else
            echo "Missing Tags Created: 0"
            echo "  ‚úÖ Git tags in sync with npm versions"
          fi

          echo ""
          echo "‚úÖ Git/npm synchronization complete."
          echo "   Nx versioning will now use accurate base versions."
          echo ""
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
          NODE_AUTH_TOKEN: ${{ secrets.NODE_AUTH_TOKEN }}

      - name: Version and publish packages (dry run)
        if: github.event.inputs.dryRun == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          echo "Running dry-run for affected packages with tag: ${{ steps.npm-tag.outputs.tag }}"
          if [[ "${{ github.ref_name }}" == "next" ]]; then
            echo "Using prerelease versioning for next branch"
            npx nx release version prerelease --preid=next --dry-run
          else
            echo "Using standard versioning for main branch"
            npx nx release version --specifier=patch --dry-run
          fi
          npx nx release publish --dry-run --tag=${{ steps.npm-tag.outputs.tag }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Version affected packages
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.affected.outputs.has_affected == 'true'
        id: version
        run: |
          AFFECTED_PROJECTS="${{ steps.affected.outputs.projects }}"
          echo "Versioning affected packages: $AFFECTED_PROJECTS"

          if [[ "${{ github.ref_name }}" == "next" ]]; then
            echo "Using prerelease versioning for next branch"
            npx nx release version prerelease --preid=next --projects="$AFFECTED_PROJECTS"
          else
            echo "Using standard versioning for main branch"
            npx nx release version --specifier=patch --projects="$AFFECTED_PROJECTS"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NODE_AUTH_TOKEN }}

      - name: Publish affected packages to NPM
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.affected.outputs.has_affected == 'true'
        id: publish
        run: |
          # Configure npm authentication for viewing restricted packages
          # The @uniswap packages are restricted and require authentication even for read operations
          echo "//registry.npmjs.org/:_authToken=${NODE_AUTH_TOKEN}" > ~/.npmrc
          echo "Configured npm authentication for restricted package queries"
          echo ""

          AFFECTED_PROJECTS="${{ steps.affected.outputs.projects }}"
          AFFECTED_PACKAGES="${{ steps.affected.outputs.packages }}"
          echo "Publishing affected packages with tag: ${{ steps.npm-tag.outputs.tag }} to NPM"
          echo "Nx projects: $AFFECTED_PROJECTS"
          echo "npm packages: $AFFECTED_PACKAGES"
          echo ""

          # Convert comma-separated lists to arrays
          IFS=',' read -ra PROJECTS <<< "$AFFECTED_PROJECTS"
          IFS=',' read -ra PACKAGES <<< "$AFFECTED_PACKAGES"

          # Track publishing results
          FAILED_PACKAGES=()
          SUCCESS_PACKAGES=()

          # Publish each package individually with appropriate flags
          # Loop through both arrays using indices
          for i in "${!PROJECTS[@]}"; do
            project="${PROJECTS[$i]}"
            package="${PACKAGES[$i]}"

            if [ -z "$project" ] || [ -z "$package" ]; then
              continue
            fi

            echo "=========================================="
            echo "Processing: $project ‚Üí $package"
            echo "=========================================="

            # Extract the package name without scope for debugging
            PACKAGE_NAME=$(echo "$package" | sed 's/@[^/]*\///')

            # Check if package exists on npm registry (not just Git tags)
            # Git tags can exist even if npm publishing failed, so we need to check npm directly
            echo "Checking if package exists on npm registry..."

            # Query npm registry to check if package exists
            # Returns 0 if package exists, non-zero if it doesn't
            if npm view "$package" version --registry=https://registry.npmjs.org &>/dev/null; then
              # Package exists on npm
              NPM_VERSION=$(npm view "$package" version --registry=https://registry.npmjs.org 2>/dev/null || echo "unknown")
              echo "üì¶ Status: EXISTING package on npm (current version: $NPM_VERSION)"
              echo "Publishing without --first-release flag..."

              # Use Nx PROJECT NAME for the --projects flag
              if npx nx release publish --projects="$project" --tag=${{ steps.npm-tag.outputs.tag }} --registry=https://registry.npmjs.org; then
                echo "‚úÖ Successfully published $package"
                SUCCESS_PACKAGES+=("$package")

                # Immediately push the git tag for this successful publish
                PACKAGE_TAG=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -V | tail -n 1)
                if [ -n "$PACKAGE_TAG" ]; then
                  echo "üè∑Ô∏è  Pushing tag: $PACKAGE_TAG"
                  if git push origin "$PACKAGE_TAG" 2>/dev/null; then
                    echo "‚úÖ Successfully pushed tag $PACKAGE_TAG"
                  else
                    echo "‚ö†Ô∏è  Failed to push tag $PACKAGE_TAG (may already exist on remote)"
                  fi
                fi
              else
                echo "‚ùå Failed to publish $package"
                FAILED_PACKAGES+=("$package")
              fi
            else
              # Package does NOT exist on npm (truly a first release)
              echo "üÜï Status: NEW package (not found on npm registry)"

              # Show Git tags if they exist (for debugging orphaned tags)
              FOUND_TAGS=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -u || echo "")
              if [ -n "$FOUND_TAGS" ]; then
                echo "‚ö†Ô∏è  Note: Git tags exist but package not on npm (likely from failed previous publish)"
                echo "Git tags found:"
                echo "$FOUND_TAGS" | head -n 3
                echo ""
              fi

              echo "Publishing with --first-release flag..."

              # Use Nx PROJECT NAME for the --projects flag
              if npx nx release publish --projects="$project" --first-release --tag=${{ steps.npm-tag.outputs.tag }} --registry=https://registry.npmjs.org; then
                echo "‚úÖ Successfully published $package (first release)"
                SUCCESS_PACKAGES+=("$package")

                # Immediately push the git tag for this successful publish
                PACKAGE_TAG=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -V | tail -n 1)
                if [ -n "$PACKAGE_TAG" ]; then
                  echo "üè∑Ô∏è  Pushing tag: $PACKAGE_TAG"
                  if git push origin "$PACKAGE_TAG" 2>/dev/null; then
                    echo "‚úÖ Successfully pushed tag $PACKAGE_TAG"
                  else
                    echo "‚ö†Ô∏è  Failed to push tag $PACKAGE_TAG (may already exist on remote)"
                  fi
                fi
              else
                echo "‚ùå Failed to publish $package (first release)"
                FAILED_PACKAGES+=("$package")
              fi
            fi

            echo ""
          done

          # Convert arrays to JSON for outputs
          SUCCESS_JSON=$(printf '%s\n' "${SUCCESS_PACKAGES[@]}" | jq -R . | jq -s -c .)
          FAILED_JSON=$(printf '%s\n' "${FAILED_PACKAGES[@]}" | jq -R . | jq -s -c .)

          # Set step outputs
          echo "successful_packages=$SUCCESS_JSON" >> $GITHUB_OUTPUT
          echo "failed_packages=$FAILED_JSON" >> $GITHUB_OUTPUT
          echo "successful_count=${#SUCCESS_PACKAGES[@]}" >> $GITHUB_OUTPUT
          echo "failed_count=${#FAILED_PACKAGES[@]}" >> $GITHUB_OUTPUT
          echo "has_failures=$( [ ${#FAILED_PACKAGES[@]} -gt 0 ] && echo 'true' || echo 'false' )" >> $GITHUB_OUTPUT
          echo "has_successes=$( [ ${#SUCCESS_PACKAGES[@]} -gt 0 ] && echo 'true' || echo 'false' )" >> $GITHUB_OUTPUT

          # Report results
          echo "=========================================="
          echo "Publishing Summary"
          echo "=========================================="
          echo "Successful: ${#SUCCESS_PACKAGES[@]} package(s)"
          for pkg in "${SUCCESS_PACKAGES[@]}"; do
            echo "  ‚úÖ $pkg"
          done

          if [ ${#FAILED_PACKAGES[@]} -gt 0 ]; then
            echo ""
            echo "Failed: ${#FAILED_PACKAGES[@]} package(s)"
            for pkg in "${FAILED_PACKAGES[@]}"; do
              echo "  ‚ùå $pkg"
            done
            echo ""
            echo "‚ö†Ô∏è  Some packages failed to publish, but workflow will continue for successful packages."
          else
            echo ""
            echo "‚úÖ All packages published successfully!"
          fi

          # Exit successfully even if some packages failed (as long as at least one succeeded)
          # This allows the workflow to continue and push tags/create releases for successful packages
          if [ ${#SUCCESS_PACKAGES[@]} -eq 0 ]; then
            echo ""
            echo "‚ùå No packages were successfully published. Failing workflow."
            exit 1
          fi
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NODE_AUTH_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}

      - name: Revert failed package versions
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.publish.outputs.has_failures == 'true'
        run: |
          echo "=========================================="
          echo "Reverting version bumps for failed packages"
          echo "=========================================="
          echo ""
          echo "This ensures git stays in sync with npm - only successfully"
          echo "published packages will have their versions bumped in git."
          echo ""

          AFFECTED_PROJECTS="${{ steps.affected.outputs.projects }}"
          FAILED_PACKAGES='${{ steps.publish.outputs.failed_packages }}'

          # Parse JSON array of failed packages
          readarray -t FAILED < <(echo "$FAILED_PACKAGES" | jq -r '.[]')

          if [ ${#FAILED[@]} -eq 0 ]; then
            echo "No failed packages to revert."
            exit 0
          fi

          echo "Failed packages to revert: ${#FAILED[@]}"
          echo ""

          # Convert affected projects to array for mapping
          IFS=',' read -ra PROJECTS <<< "$AFFECTED_PROJECTS"

          for failed_package in "${FAILED[@]}"; do
            if [ -z "$failed_package" ]; then
              continue
            fi

            echo "Processing: $failed_package"

            # Find the Nx project for this package
            for project in "${PROJECTS[@]}"; do
              if [ -z "$project" ]; then
                continue
              fi

              # Get project root from Nx
              PROJECT_ROOT=$(npx nx show project "$project" --json 2>/dev/null | jq -r '.root' || echo "")

              if [ -z "$PROJECT_ROOT" ] || [ ! -f "$PROJECT_ROOT/package.json" ]; then
                continue
              fi

              # Check if this is the package we're looking for
              PACKAGE_NAME=$(jq -r '.name // ""' "$PROJECT_ROOT/package.json")

              if [ "$PACKAGE_NAME" = "$failed_package" ]; then
                echo "  Found at: $PROJECT_ROOT/package.json"

                # Get the version that was bumped to (but never published)
                CURRENT_VERSION=$(jq -r '.version' "$PROJECT_ROOT/package.json")
                echo "  Current version (not published): $CURRENT_VERSION"

                # Delete the local git tag for this unpublished version
                PACKAGE_NAME_FOR_TAG=$(echo "$failed_package" | sed 's/@[^/]*\///')
                TAG_TO_DELETE=$(git tag -l "${PACKAGE_NAME_FOR_TAG}@*" "${failed_package}@*" 2>/dev/null | grep "@${CURRENT_VERSION}$" | head -n 1)

                if [ -n "$TAG_TO_DELETE" ]; then
                  echo "  Deleting local tag: $TAG_TO_DELETE"
                  git tag -d "$TAG_TO_DELETE" 2>/dev/null || echo "  ‚ö†Ô∏è  Tag already deleted"
                fi

                # Reset package.json to the version before this commit (HEAD~1)
                echo "  Reverting package.json to previous version..."
                git checkout HEAD~1 -- "$PROJECT_ROOT/package.json"

                # Verify the revert
                REVERTED_VERSION=$(jq -r '.version' "$PROJECT_ROOT/package.json")
                echo "  ‚úÖ Reverted to: $REVERTED_VERSION"
                echo ""

                break
              fi
            done
          done

          # Stage the reverted files
          git add -A

          # Check if there are any changes staged
          if git diff --cached --quiet; then
            echo "‚ö†Ô∏è  No changes staged after reverting."
            echo "This is unexpected - please review the workflow logs."
          else
            echo "=========================================="
            echo "Amending version commit"
            echo "=========================================="
            echo ""
            echo "Updating the version commit to only include successfully published packages."
            echo ""

            # Show what's being reverted
            echo "Changes being committed:"
            git diff --cached --name-status

            # Amend the commit to include the reverted package.json files
            git commit --amend --no-edit

            echo "‚úÖ Version commit amended successfully"
          fi

          echo ""
          echo "=========================================="
          echo "Version Revert Complete"
          echo "=========================================="
          echo ""
          echo "Git is now in sync with npm:"
          echo "  - Successfully published packages: version bumped ‚úÖ"
          echo "  - Failed packages: version reverted to previous ‚èÆÔ∏è"
          echo ""
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}

      - name: Push version commit
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.publish.outputs.has_successes == 'true'
        run: |
          # Push the version commit created by Nx (and potentially amended if there were failures)
          # Tags have already been pushed individually after each successful publish
          git push origin ${{ github.ref_name }}
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}

      - name: Create GitHub releases
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.publish.outputs.has_successes == 'true'
        run: |
          # Get only the successfully published packages from the publish step
          # Parse the JSON array of successful packages
          SUCCESSFUL_PACKAGES='${{ steps.publish.outputs.successful_packages }}'

          echo "Creating GitHub releases for successfully published packages..."
          echo "Successful packages JSON: $SUCCESSFUL_PACKAGES"
          echo ""

          # Parse JSON array into bash array
          readarray -t PACKAGES < <(echo "$SUCCESSFUL_PACKAGES" | jq -r '.[]')

          if [ ${#PACKAGES[@]} -eq 0 ]; then
            echo "‚ö†Ô∏è  No successfully published packages to create releases for."
            exit 0
          fi

          for package in "${PACKAGES[@]}"; do
            if [ -z "$package" ]; then
              continue
            fi

            echo "Processing package: $package"

            # Extract the package name without scope for tag checking
            PACKAGE_NAME=$(echo "$package" | sed 's/@[^/]*\///')

            # Get the latest tag for this package
            # Nx creates tags in the format: package-name@version or @scope/package-name@version
            # Use git tag glob patterns for precise matching without escaping issues
            LATEST_TAG=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -V | tail -n 1)

            if [ -n "$LATEST_TAG" ]; then
              # Extract version from tag
              VERSION="${LATEST_TAG##*@}"

              # Check if release already exists
              if gh release view "$LATEST_TAG" &>/dev/null; then
                echo "‚úì Release $LATEST_TAG already exists, skipping"
              else
                echo "Creating GitHub release for $LATEST_TAG"

                # Create the release with a basic changelog
                # The AI-generated changelog will be added to Slack/Notion notifications
                gh release create "$LATEST_TAG" \
                  --title "$package $VERSION" \
                  --notes "Release $VERSION of $package. See [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details." \
                  --verify-tag

                echo "‚úÖ Created release for $LATEST_TAG"
              fi
            else
              echo "‚ö†Ô∏è No tag found for $package (this might indicate the package was not versioned)"
            fi

            echo ""
          done

          echo "GitHub releases creation complete."
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}

  generate-changelog:
    name: Generate AI-powered changelog
    needs: publish
    if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && needs.publish.outputs.has_successes == 'true'
    uses: ./.github/workflows/_generate-changelog.yml
    with:
      from_ref: ${{ github.event.before }}
      to_ref: ${{ github.sha }}
      output_formats: 'slack,markdown'
      custom_prompt_text: |
        # Release Changelog Generation Prompt

        You are a changelog generator. Based on the following git changes, create a concise, human-readable changelog summary.

        ${{ needs.publish.outputs.has_failures == 'true' && format('**IMPORTANT**: This is a PARTIAL release. Some packages failed to publish.

        **Successfully published packages**:
        {0}

        **Failed packages** (not published):
        {1}

        Focus your changelog ONLY on the successfully published packages. Add a note at the end about which packages failed to publish.

        ', join(fromJSON(needs.publish.outputs.successful_packages), ', '), join(fromJSON(needs.publish.outputs.failed_packages), ', ')) || format('All packages were successfully published.

        **Published packages**:
        {0}

        ', join(fromJSON(needs.publish.outputs.successful_packages), ', ')) }}

        Focus on:
        - What features were added
        - What bugs were fixed
        - What was changed or improved

        Format requirements:
        - Use bullet points (‚Ä¢ or -) for each item, separated by a newline character
        - Keep it to 3-10 items max
        - Be concise and clear
        - Do NOT include commit hashes unless specifically requested
        - Group related changes together

        Slack formatting requirements (IMPORTANT):
        - DO NOT use markdown headers (no #, ##, ###)
        - Use plain text for section titles followed by a colon (e.g., "Features:")
        - Use _single asterisks_ for bold text (NOT double asterisks)
        - Use _underscores_ for italic text
        - Use simple bullet lists with ‚Ä¢ or - characters
        - Keep formatting minimal and clean
        - DO NOT use standard markdown links [text](url) - just use plain URLs or omit them
      max_tokens: 1024
    secrets:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

  notify-release:
    name: Notify release via Slack
    needs: [publish, generate-changelog]
    if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && needs.publish.outputs.has_successes == 'true'
    uses: ./.github/workflows/_notify-release.yml
    with:
      changelog_slack: ${{ needs.generate-changelog.outputs.changelog_slack }}
      changelog_markdown: ${{ needs.generate-changelog.outputs.changelog_markdown }}
      destinations: 'slack,notion'
      from_ref: ${{ github.event.before }}
      to_ref: ${{ github.sha }}
      branch: ${{ github.ref_name }}
      release_title: ${{ needs.publish.outputs.has_failures == 'true' && format('‚ö†Ô∏è Partial Release - {0} ({1} succeeded, {2} failed)', github.ref_name, needs.publish.outputs.successful_count, needs.publish.outputs.failed_count) || '' }}
    secrets:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      NOTION_API_KEY: ${{ secrets.NOTION_API_KEY }}
      RELEASE_NOTES_NOTION_DATABASE_ID: ${{ secrets.RELEASE_NOTES_NOTION_DATABASE_ID }}
      NODE_AUTH_TOKEN: ${{ secrets.NODE_AUTH_TOKEN }}

  sync-next:
    name: Sync next branch with main
    runs-on: ubuntu-24.04
    needs: publish
    # Only run when main branch is updated (not on next branch pushes)
    if: github.ref_name == 'main' && github.event_name == 'push'
    permissions:
      contents: write

    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: Install Graphite CLI
        run: |
          # Install Graphite CLI using npm (faster than installing Homebrew)
          npm install -g @withgraphite/graphite-cli

          # Verify installation
          gt --version

      - name: Configure Git
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

      - name: Sync next branch with main
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
        run: |
          echo "Starting sync of next branch with main..."

          # Fetch all remote branches
          git fetch origin

          # Check if next branch exists on remote
          if ! git show-ref --verify --quiet refs/remotes/origin/next; then
            echo "Next branch does not exist on remote. Skipping sync."
            exit 0
          fi

          # Switch to next branch (tracking origin/next)
          git checkout -B next origin/next

          # Attempt to rebase next onto main
          echo "Rebasing next onto main..."

          # Try to rebase onto origin/main
          if git rebase origin/main; then
            echo "‚úÖ Rebase successful!"

            # Create an empty commit to mark this as a sync operation
            # This prevents the publish workflow from triggering on the next branch
            git commit --allow-empty -m "chore(sync): [skip ci] sync next with main"

            # Force push the rebased next branch
            git push origin next --force-with-lease

            echo "‚úÖ Successfully synced next branch with main"

            # Create summary
            echo "## üîÑ Branch Sync Complete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The \`next\` branch has been successfully rebased onto \`main\`." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Main branch**: $(git rev-parse --short origin/main)" >> $GITHUB_STEP_SUMMARY
            echo "- **Next branch**: $(git rev-parse --short next)" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Rebase failed due to conflicts"

            # Abort the rebase
            git rebase --abort

            # Create an issue for manual intervention
            gh issue create \
              --title "Manual intervention required: next branch sync failed" \
              --body "The automatic sync of the \`next\` branch with \`main\` has failed due to conflicts.

              ## Action Required
              Please manually resolve the conflicts by:
              1. Checking out the \`next\` branch locally
              2. Rebasing it onto \`main\`
              3. Resolving any conflicts
              4. Force pushing the resolved branch

              ## Commands
              \`\`\`bash
              git checkout next
              git fetch origin
              git rebase origin/main
              # Resolve conflicts
              git push origin next --force-with-lease
              \`\`\`

              This issue was automatically created by the publish-packages workflow." \
              --label "automated,needs-attention"

            echo "## ‚ö†Ô∏è Branch Sync Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The \`next\` branch could not be automatically rebased onto \`main\` due to conflicts." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "An issue has been created for manual intervention." >> $GITHUB_STEP_SUMMARY

            exit 1
          fi

      - name: Alternative sync with Graphite (if available)
        if: failure()
        continue-on-error: true
        run: |
          echo "Attempting alternative sync method with Graphite CLI..."

          # Initialize Graphite if needed
          gt init --trunk main --no-interactive || true

          # Try to sync using Graphite
          if gt sync --force --no-interactive; then
            echo "‚úÖ Successfully synced using Graphite CLI"
          else
            echo "‚ö†Ô∏è Graphite sync also failed. Manual intervention required."
          fi
