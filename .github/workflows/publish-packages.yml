name: Publish Packages

# This workflow handles versioning, building, and publishing packages to NPM for both
# production (main branch) and pre-release (next branch) deployments.
#
# REQUIRED SECRETS:
# 1. WORKFLOW_PAT: Personal Access Token with 'repo' and 'workflow' scopes
#    - Required to push version commits and tags back to the repository
#    - Create at: GitHub Settings > Developer settings > Personal access tokens
# 2. ANTHROPIC_API_KEY: API key for AI-powered changelog generation
#    - Required to generate intelligent release changelogs
#    - Create at: https://console.anthropic.com/settings/keys
# 3. SLACK_WEBHOOK_URL: Incoming webhook URL for release notifications
#    - Required to send notifications to #ai-internal Slack channel
#    - Create at: https://api.slack.com/apps > Incoming Webhooks
# 4. NODE_AUTH_TOKEN: NPM authentication token
#    - Required to publish packages to NPM registry
#    - Create at: https://www.npmjs.com/settings/your-username/tokens
#
# WORKFLOW BEHAVIOR:
# - Triggered on push to 'main' or 'next' branches
# - Can be manually triggered with optional dry-run mode
# - Versions packages based on conventional commits
# - Publishes to NPM with appropriate tags (latest for main, next for next branch)
# - Generates AI-powered changelog for release notes
# - Sends Slack notification with changelog
# - Syncs 'next' branch with 'main' after production releases
#
# ARCHITECTURE:
# This workflow uses a multi-job orchestration pattern:
# 1. publish: Builds, versions, and publishes packages to NPM
# 2. generate-changelog: Generates AI-powered changelog using reusable workflow
# 3. notify-release: Sends Slack notification with changelog using reusable workflow
# 4. sync-next: Syncs 'next' branch with 'main' after production releases
#
# The changelog generation and notification are separated into reusable workflows
# for better maintainability and reusability across different workflows.

on:
  push:
    branches:
      - main
      - next
  workflow_dispatch:
    inputs:
      dryRun:
        description: 'Perform a dry run without publishing'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

jobs:
  publish:
    runs-on:
      group: npm-deploy
    environment: ${{ github.event_name == 'push' && 'Production' || null }}
    permissions:
      id-token: write
      contents: write
      packages: write
      pull-requests: write
      issues: write
    outputs:
      has_affected: ${{ steps.affected.outputs.has_affected }}
    # Skip the workflow if the commit is a version bump (to prevent loops)
    # Allow workflow to run for merge commits from update-production workflow
    if: ${{ !startsWith(github.event.head_commit.message, 'chore(release):') }}

    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - name: Checkout repository
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: Setup Node.js
        uses: actions/setup-node@2028fbc5c25fe9cf00d9f06a71cc4710d4507903 # v6.0.0
        with:
          node-version: '20.x'
          registry-url: 'https://registry.npmjs.org'
          scope: '@uniswap'

      - name: Install npm
        run: npm install -g npm@10.9.2
      - name: Install dependencies
        run: npm ci
      - name: Configure Git
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

      - name: Determine npm tag
        id: npm-tag
        run: |
          if [[ "${{ github.ref_name }}" == "next" ]]; then
            echo "tag=next" >> $GITHUB_OUTPUT
            echo "Using 'next' tag for npm publish"
          else
            echo "tag=latest" >> $GITHUB_OUTPUT
            echo "Using 'latest' tag for npm publish"
          fi

      - name: Determine base SHA for affected detection
        id: base-sha
        run: |
          # Get the latest release tag to use as base for affected detection
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -z "$LATEST_TAG" ]; then
            echo "No previous release tags found - this appears to be a first release"
            echo "base=HEAD~1" >> $GITHUB_OUTPUT
          else
            echo "Latest release tag: $LATEST_TAG"
            echo "base=$LATEST_TAG" >> $GITHUB_OUTPUT
          fi

      - name: Determine affected packages
        id: affected
        run: |
          # Get affected projects using Nx
          echo "Running: npx nx show projects --affected --base=${{ steps.base-sha.outputs.base }} --head=HEAD --type=lib --json"

          # Capture output and check if it's valid JSON
          AFFECTED_OUTPUT=$(npx nx show projects --affected --base=${{ steps.base-sha.outputs.base }} --head=HEAD --type=lib --json 2>&1 || echo "[]")

          # Check if output is valid JSON
          if echo "$AFFECTED_OUTPUT" | jq empty 2>/dev/null; then
            AFFECTED_JSON="$AFFECTED_OUTPUT"
          else
            echo "‚ö†Ô∏è  Nx output is not valid JSON. Output:"
            echo "$AFFECTED_OUTPUT"
            echo "Using empty array as fallback"
            AFFECTED_JSON="[]"
          fi

          # Extract just the project names from the JSON array and join with commas
          AFFECTED_PROJECTS=$(echo "$AFFECTED_JSON" | jq -r 'join(",")')

          echo "Affected projects: $AFFECTED_PROJECTS"
          echo "projects=$AFFECTED_PROJECTS" >> $GITHUB_OUTPUT

          # Set a flag indicating if any packages are affected
          if [ -z "$AFFECTED_PROJECTS" ] || [ "$AFFECTED_PROJECTS" = "null" ]; then
            echo "has_affected=false" >> $GITHUB_OUTPUT
            echo "No affected packages found - skipping release"
          else
            echo "has_affected=true" >> $GITHUB_OUTPUT
          fi

      - name: Build affected packages
        if: steps.affected.outputs.has_affected == 'true'
        run: |
          echo "Building affected packages: ${{ steps.affected.outputs.projects }}"
          npx nx affected --target=build --base=${{ steps.base-sha.outputs.base }} --head=HEAD

      - name: Version and publish packages (dry run)
        if: github.event.inputs.dryRun == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          echo "Running dry-run for affected packages with tag: ${{ steps.npm-tag.outputs.tag }}"
          if [[ "${{ github.ref_name }}" == "next" ]]; then
            echo "Using prerelease versioning for next branch"
            npx nx release version prerelease --preid=next --dry-run
          else
            echo "Using standard versioning for main branch"
            npx nx release version --specifier=patch --dry-run
          fi
          npx nx release publish --dry-run --tag=${{ steps.npm-tag.outputs.tag }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Version affected packages
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.affected.outputs.has_affected == 'true'
        id: version
        run: |
          AFFECTED_PROJECTS="${{ steps.affected.outputs.projects }}"
          echo "Versioning affected packages: $AFFECTED_PROJECTS"

          if [[ "${{ github.ref_name }}" == "next" ]]; then
            echo "Using prerelease versioning for next branch"
            npx nx release version prerelease --preid=next --projects="$AFFECTED_PROJECTS"
          else
            echo "Using standard versioning for main branch"
            npx nx release version --specifier=patch --projects="$AFFECTED_PROJECTS"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish affected packages to NPM
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.affected.outputs.has_affected == 'true'
        run: |
          AFFECTED_PROJECTS="${{ steps.affected.outputs.projects }}"
          echo "Publishing affected packages with tag: ${{ steps.npm-tag.outputs.tag }} to NPM"
          echo "Affected packages: $AFFECTED_PROJECTS"

          # Check if any of the affected packages have been released before
          # If no tags exist for any affected package, use --first-release flag
          IS_FIRST_RELEASE=true

          # Convert comma-separated list to array
          IFS=',' read -ra PACKAGES <<< "$AFFECTED_PROJECTS"

          for package in "${PACKAGES[@]}"; do
            if [ -n "$package" ]; then
              # Extract the package name without scope for tag checking
              PACKAGE_NAME=$(echo "$package" | sed 's/@[^/]*\///')

              echo "Checking for Git tags for package: $package"

              # Check if any tags exist for this package
              # Nx typically creates tags in the format: package-name@version
              if git tag -l | grep -q "^${PACKAGE_NAME}@" || git tag -l | grep -q "^${package}@"; then
                echo "‚úì Found existing tags for $package"
                IS_FIRST_RELEASE=false
                break
              else
                echo "‚úó No tags found for $package"
              fi
            fi
          done

          # Publish the packages
          # Nx release publish will only publish packages that were versioned in the previous step
          if [ "$IS_FIRST_RELEASE" = true ]; then
            echo "No tags found for any affected packages - publishing with --first-release flag"
            npx nx release publish --first-release --tag=${{ steps.npm-tag.outputs.tag }} --registry=https://registry.npmjs.org
          else
            echo "Found existing tags - publishing without --first-release flag"
            npx nx release publish --tag=${{ steps.npm-tag.outputs.tag }} --registry=https://registry.npmjs.org
          fi

      - name: Push version commits and tags
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.affected.outputs.has_affected == 'true'
        run: |
          # Push commits and tags created by Nx
          git push origin ${{ github.ref_name }} --follow-tags
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}

      - name: Create GitHub releases
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.affected.outputs.has_affected == 'true'
        run: |
          # Nx Release will create GitHub releases based on changelog configuration
          echo "GitHub releases will be created by Nx Release based on the changelog configuration"
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}

  generate-changelog:
    name: Generate AI-powered changelog
    needs: publish
    if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && needs.publish.outputs.has_affected == 'true'
    uses: ./.github/workflows/_generate-changelog.yml
    with:
      before_sha: ${{ github.event.before }}
      after_sha: ${{ github.sha }}
      custom_prompt_file: '.github/prompts/release-changelog.md'
      max_tokens: 1024
    secrets:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

  notify-release:
    name: Notify release via Slack
    needs: [publish, generate-changelog]
    if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && needs.publish.outputs.has_affected == 'true'
    uses: ./.github/workflows/_notify-release.yml
    with:
      branch: ${{ github.ref_name }}
      npm_tag: ${{ github.ref_name == 'next' && 'next' || 'latest' }}
      before_sha: ${{ github.event.before }}
      after_sha: ${{ github.sha }}
      changelog: ${{ needs.generate-changelog.outputs.changelog }}
    secrets:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  sync-next:
    name: Sync next branch with main
    runs-on: ubuntu-24.04
    needs: publish
    # Only run when main branch is updated (not on next branch pushes)
    if: github.ref_name == 'main' && github.event_name == 'push'
    permissions:
      contents: write

    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - name: Checkout repository
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: Install Graphite CLI
        run: |
          # Install Graphite CLI using npm (faster than installing Homebrew)
          npm install -g @withgraphite/graphite-cli

          # Verify installation
          gt --version

      - name: Configure Git
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

      - name: Sync next branch with main
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
        run: |
          echo "Starting sync of next branch with main..."

          # Fetch all remote branches
          git fetch origin

          # Check if next branch exists on remote
          if ! git show-ref --verify --quiet refs/remotes/origin/next; then
            echo "Next branch does not exist on remote. Skipping sync."
            exit 0
          fi

          # Switch to next branch (tracking origin/next)
          git checkout -B next origin/next

          # Attempt to rebase next onto main
          echo "Rebasing next onto main..."

          # Try to rebase onto origin/main
          if git rebase origin/main; then
            echo "‚úÖ Rebase successful!"

            # Force push the rebased next branch
            git push origin next --force-with-lease

            echo "‚úÖ Successfully synced next branch with main"

            # Create summary
            echo "## üîÑ Branch Sync Complete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The \`next\` branch has been successfully rebased onto \`main\`." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Main branch**: $(git rev-parse --short origin/main)" >> $GITHUB_STEP_SUMMARY
            echo "- **Next branch**: $(git rev-parse --short next)" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Rebase failed due to conflicts"

            # Abort the rebase
            git rebase --abort

            # Create an issue for manual intervention
            gh issue create \
              --title "Manual intervention required: next branch sync failed" \
              --body "The automatic sync of the \`next\` branch with \`main\` has failed due to conflicts.

              ## Action Required
              Please manually resolve the conflicts by:
              1. Checking out the \`next\` branch locally
              2. Rebasing it onto \`main\`
              3. Resolving any conflicts
              4. Force pushing the resolved branch

              ## Commands
              \`\`\`bash
              git checkout next
              git fetch origin
              git rebase origin/main
              # Resolve conflicts
              git push origin next --force-with-lease
              \`\`\`

              This issue was automatically created by the publish-packages workflow." \
              --label "automated,needs-attention"

            echo "## ‚ö†Ô∏è Branch Sync Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The \`next\` branch could not be automatically rebased onto \`main\` due to conflicts." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "An issue has been created for manual intervention." >> $GITHUB_STEP_SUMMARY

            exit 1
          fi

      - name: Alternative sync with Graphite (if available)
        if: failure()
        continue-on-error: true
        run: |
          echo "Attempting alternative sync method with Graphite CLI..."

          # Initialize Graphite if needed
          gt init --trunk main --no-interactive || true

          # Try to sync using Graphite
          if gt sync --force --no-interactive; then
            echo "‚úÖ Successfully synced using Graphite CLI"
          else
            echo "‚ö†Ô∏è Graphite sync also failed. Manual intervention required."
          fi
