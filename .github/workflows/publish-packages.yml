name: Publish Packages

# This workflow handles versioning, building, and publishing packages to NPM for both
# production (main branch) and pre-release (next branch) deployments.
#
# REQUIRED SECRETS:
# 1. WORKFLOW_PAT: Personal Access Token with 'repo' and 'workflow' scopes
#    - Required to push version commits and tags back to the repository
#    - Create at: GitHub Settings > Developer settings > Personal access tokens
# 2. ANTHROPIC_API_KEY: API key for AI-powered changelog generation
#    - Required to generate intelligent release changelogs
#    - Create at: https://console.anthropic.com/settings/keys
# 3. SLACK_WEBHOOK_URL: Incoming webhook URL for release notifications
#    - Required to send notifications to #ai-internal Slack channel
#    - Create at: https://api.slack.com/apps > Incoming Webhooks
# 4. NODE_AUTH_TOKEN: NPM authentication token
#    - Required to publish packages to NPM registry
#    - Create at: https://www.npmjs.com/settings/your-username/tokens
#
# WORKFLOW BEHAVIOR:
# - Triggered on push to 'main' or 'next' branches
# - Can be manually triggered with optional dry-run mode
# - Versions packages based on conventional commits
# - Publishes to NPM with appropriate tags (latest for main, next for next branch)
# - Generates AI-powered changelog for release notes
# - Sends Slack notification with changelog
# - Syncs 'next' branch with 'main' after production releases
#
# ARCHITECTURE:
# This workflow uses a multi-job orchestration pattern:
# 1. publish: Builds, versions, and publishes packages to NPM
# 2. generate-changelog: Generates AI-powered changelog using reusable workflow
# 3. notify-release: Sends Slack notification with changelog using reusable workflow
# 4. sync-next: Syncs 'next' branch with 'main' after production releases
#
# The changelog generation and notification are separated into reusable workflows
# for better maintainability and reusability across different workflows.

on:
  push:
    branches:
      - main
      - next
  workflow_dispatch:
    inputs:
      dryRun:
        description: 'Perform a dry run without publishing'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

# Ensure only one publish workflow runs at a time per branch
# If a new run is triggered while one is in progress, it will be queued
# Setting cancel-in-progress to false ensures queued runs execute sequentially
concurrency:
  group: publish-${{ github.ref }}
  cancel-in-progress: false

jobs:
  publish:
    runs-on:
      group: npm-deploy
    environment: ${{ github.event_name == 'push' && 'Production' || null }}
    permissions:
      id-token: write
      contents: write
      packages: write
      pull-requests: write
      issues: write
    outputs:
      has_affected: ${{ steps.affected.outputs.has_affected }}
    # Skip the workflow if the commit is a version bump (to prevent loops)
    # Allow workflow to run for merge commits from update-production workflow
    # Skip workflow for branch sync commits
    if: ${{ !startsWith(github.event.head_commit.message, 'chore(release):') && !startsWith(github.event.head_commit.message, 'chore(sync):') }}

    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - name: Checkout repository
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: Setup Node.js
        uses: actions/setup-node@2028fbc5c25fe9cf00d9f06a71cc4710d4507903 # v6.0.0
        with:
          node-version: '22.21.1'
          registry-url: 'https://registry.npmjs.org'
          scope: '@uniswap'

      - name: Install npm
        run: npm install -g npm@11.6.2
        # IMPORTANT: Pinning to npm 11.6.2 for two reasons:
        # 1. OIDC trusted publishing requires npm >= 11.5.1
        # 2. Using a pinned version prevents lockfile format changes in CI
        # Local developers should use: npm install -g npm@11.6.2
      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Verify package-lock.json unchanged
        run: |
          if ! git diff --exit-code package-lock.json; then
            echo "‚ùå ERROR: npm ci modified package-lock.json!"
            echo "This should not happen. Please investigate why npm ci is modifying the lock file."
            git diff package-lock.json
            exit 1
          fi
          echo "‚úÖ package-lock.json unchanged after npm ci"

      - name: Configure Git
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

      - name: Determine npm tag
        id: npm-tag
        run: |
          if [[ "${{ github.ref_name }}" == "next" ]]; then
            echo "tag=next" >> $GITHUB_OUTPUT
            echo "Using 'next' tag for npm publish"
          else
            echo "tag=latest" >> $GITHUB_OUTPUT
            echo "Using 'latest' tag for npm publish"
          fi

      - name: Determine base SHA for affected detection
        id: base-sha
        run: |
          # Get the latest release tag to use as base for affected detection
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -z "$LATEST_TAG" ]; then
            echo "No previous release tags found - this appears to be a first release"
            echo "base=HEAD~1" >> $GITHUB_OUTPUT
          else
            echo "Latest release tag: $LATEST_TAG"
            echo "base=$LATEST_TAG" >> $GITHUB_OUTPUT
          fi

      - name: Determine affected packages
        id: affected
        run: |
          # Get affected projects using Nx
          echo "Running: npx nx show projects --affected --base=${{ steps.base-sha.outputs.base }} --head=HEAD --type=lib --json"

          # Capture output and check if it's valid JSON
          # Suppress Node.js deprecation warnings and npm warnings to avoid polluting JSON output
          RAW_OUTPUT=$(NODE_NO_WARNINGS=1 npx nx show projects --affected --base=${{ steps.base-sha.outputs.base }} --head=HEAD --type=lib --json 2>&1 || echo "[]")

          # Filter out npm warnings (lines starting with "npm warn")
          AFFECTED_OUTPUT=$(echo "$RAW_OUTPUT" | grep -v '^npm warn' || echo "[]")

          echo "AFFECTED_OUTPUT: $AFFECTED_OUTPUT"

          # Check if output is valid JSON
          if echo "$AFFECTED_OUTPUT" | jq empty 2>/dev/null; then
            AFFECTED_JSON="$AFFECTED_OUTPUT"
          else
            echo "‚ö†Ô∏è  Nx output is not valid JSON. Output:"
            echo "$AFFECTED_OUTPUT"
            echo "Using empty array as fallback"
            AFFECTED_JSON="[]"
          fi

          # Extract project names and filter out private packages
          # Read each project and check if it has "private": true in package.json
          echo "Filtering out private packages..."
          PUBLISHABLE_PROJECTS=()
          PACKAGE_NAMES=()

          for project in $(echo "$AFFECTED_JSON" | jq -r '.[]'); do
            # Find the package.json for this project
            # Use nx show project to get the project root
            PROJECT_ROOT=$(npx nx show project "$project" --json 2>/dev/null | jq -r '.root' || echo "")

            if [ -n "$PROJECT_ROOT" ] && [ -f "$PROJECT_ROOT/package.json" ]; then
              # Check if package is private
              IS_PRIVATE=$(jq -r '.private // false' "$PROJECT_ROOT/package.json")

              if [ "$IS_PRIVATE" = "true" ]; then
                echo "  ‚è≠Ô∏è  Skipping $project (private: true)"
              else
                PACKAGE_NAME=$(jq -r '.name // ""' "$PROJECT_ROOT/package.json")
                if [ -n "$PACKAGE_NAME" ]; then
                  echo "  ‚úÖ Including $project ‚Üí $PACKAGE_NAME (publishable)"
                  PUBLISHABLE_PROJECTS+=("$project")  # Store Nx project name
                  PACKAGE_NAMES+=("$PACKAGE_NAME")    # Store npm package name
                else
                  echo "  ‚ö†Ô∏è  Skipping $project (no package name found)"
                fi
              fi
            else
              echo "  ‚ö†Ô∏è  Skipping $project (no package.json found)"
            fi
          done

          # Join arrays with commas
          AFFECTED_PROJECTS=$(IFS=,; echo "${PUBLISHABLE_PROJECTS[*]}")
          AFFECTED_PACKAGES=$(IFS=,; echo "${PACKAGE_NAMES[*]}")

          echo "Publishable affected projects (Nx names): $AFFECTED_PROJECTS"
          echo "Publishable affected packages (npm names): $AFFECTED_PACKAGES"

          echo "projects=$AFFECTED_PROJECTS" >> $GITHUB_OUTPUT
          echo "packages=$AFFECTED_PACKAGES" >> $GITHUB_OUTPUT

          # Set a flag indicating if any packages are affected
          if [ -z "$AFFECTED_PROJECTS" ] || [ "$AFFECTED_PROJECTS" = "null" ]; then
            echo "has_affected=false" >> $GITHUB_OUTPUT
            echo "No publishable affected packages found - skipping release"
          else
            echo "has_affected=true" >> $GITHUB_OUTPUT
            echo "Found ${#PUBLISHABLE_PROJECTS[@]} publishable package(s)"
          fi

      - name: Build affected packages
        if: steps.affected.outputs.has_affected == 'true'
        run: |
          echo "Building affected packages: ${{ steps.affected.outputs.projects }}"
          npx nx affected --target=build --base=${{ steps.base-sha.outputs.base }} --head=HEAD

      - name: Clean up orphaned tags
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.affected.outputs.has_affected == 'true'
        run: |
          AFFECTED_PACKAGES="${{ steps.affected.outputs.packages }}"

          echo "=========================================="
          echo "Checking for orphaned Git tags"
          echo "=========================================="
          echo ""
          echo "Orphaned tags are Git tags that exist but their corresponding"
          echo "npm package version was never successfully published."
          echo "These must be cleaned up before versioning can proceed."
          echo ""

          # Convert comma-separated list to array
          IFS=',' read -ra PACKAGES <<< "$AFFECTED_PACKAGES"

          CLEANED_TAGS=()

          for package in "${PACKAGES[@]}"; do
            if [ -z "$package" ]; then
              continue
            fi

            echo "Checking package: $package"

            # Extract the package name without scope for tag checking
            PACKAGE_NAME=$(echo "$package" | sed 's/@[^/]*\///')

            # Get the latest tag for this package
            LATEST_TAG=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -V | tail -n 1)

            if [ -z "$LATEST_TAG" ]; then
              echo "  ‚ÑπÔ∏è  No tags found - will create first tag during versioning"
              echo ""
              continue
            fi

            # Extract version from tag
            VERSION="${LATEST_TAG##*@}"
            echo "  Latest tag: $LATEST_TAG (version: $VERSION)"

            # Check if this specific version exists on npm
            if npm view "${package}@${VERSION}" version --registry=https://registry.npmjs.org &>/dev/null; then
              echo "  ‚úÖ Version $VERSION exists on npm - tag is valid"
              echo ""
            else
              echo "  ‚ö†Ô∏è  Version $VERSION NOT found on npm - tag is orphaned!"
              echo "  üßπ Deleting orphaned tag: $LATEST_TAG"

              # Delete tag locally
              if git tag -d "$LATEST_TAG" 2>/dev/null; then
                echo "  ‚úÖ Deleted local tag"
              else
                echo "  ‚ö†Ô∏è  Local tag already deleted or doesn't exist"
              fi

              # Delete tag from remote
              if git push --delete origin "$LATEST_TAG" 2>/dev/null; then
                echo "  ‚úÖ Deleted remote tag"
                CLEANED_TAGS+=("$LATEST_TAG")
              else
                echo "  ‚ö†Ô∏è  Remote tag already deleted or doesn't exist"
              fi

              echo ""
            fi
          done

          # Summary
          echo "=========================================="
          echo "Orphaned Tag Cleanup Summary"
          echo "=========================================="
          if [ ${#CLEANED_TAGS[@]} -gt 0 ]; then
            echo "Cleaned up ${#CLEANED_TAGS[@]} orphaned tag(s):"
            for tag in "${CLEANED_TAGS[@]}"; do
              echo "  üßπ $tag"
            done
            echo ""
            echo "‚úÖ These tags will be recreated during versioning and"
            echo "   associated with the successful npm publish in this run."
          else
            echo "‚úÖ No orphaned tags found - all existing tags have"
            echo "   corresponding published npm versions."
          fi
          echo ""
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}

      - name: Version and publish packages (dry run)
        if: github.event.inputs.dryRun == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          echo "Running dry-run for affected packages with tag: ${{ steps.npm-tag.outputs.tag }}"
          if [[ "${{ github.ref_name }}" == "next" ]]; then
            echo "Using prerelease versioning for next branch"
            npx nx release version prerelease --preid=next --dry-run
          else
            echo "Using standard versioning for main branch"
            npx nx release version --specifier=patch --dry-run
          fi
          npx nx release publish --dry-run --tag=${{ steps.npm-tag.outputs.tag }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Version affected packages
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.affected.outputs.has_affected == 'true'
        id: version
        run: |
          AFFECTED_PROJECTS="${{ steps.affected.outputs.projects }}"
          echo "Versioning affected packages: $AFFECTED_PROJECTS"

          if [[ "${{ github.ref_name }}" == "next" ]]; then
            echo "Using prerelease versioning for next branch"
            npx nx release version prerelease --preid=next --projects="$AFFECTED_PROJECTS"
          else
            echo "Using standard versioning for main branch"
            npx nx release version --specifier=patch --projects="$AFFECTED_PROJECTS"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish affected packages to NPM
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.affected.outputs.has_affected == 'true'
        run: |
          AFFECTED_PROJECTS="${{ steps.affected.outputs.projects }}"
          AFFECTED_PACKAGES="${{ steps.affected.outputs.packages }}"
          echo "Publishing affected packages with tag: ${{ steps.npm-tag.outputs.tag }} to NPM"
          echo "Nx projects: $AFFECTED_PROJECTS"
          echo "npm packages: $AFFECTED_PACKAGES"
          echo ""

          # Convert comma-separated lists to arrays
          IFS=',' read -ra PROJECTS <<< "$AFFECTED_PROJECTS"
          IFS=',' read -ra PACKAGES <<< "$AFFECTED_PACKAGES"

          # Track publishing results
          FAILED_PACKAGES=()
          SUCCESS_PACKAGES=()

          # Publish each package individually with appropriate flags
          # Loop through both arrays using indices
          for i in "${!PROJECTS[@]}"; do
            project="${PROJECTS[$i]}"
            package="${PACKAGES[$i]}"

            if [ -z "$project" ] || [ -z "$package" ]; then
              continue
            fi

            echo "=========================================="
            echo "Processing: $project ‚Üí $package"
            echo "=========================================="

            # Extract the package name without scope for debugging
            PACKAGE_NAME=$(echo "$package" | sed 's/@[^/]*\///')

            # Check if package exists on npm registry (not just Git tags)
            # Git tags can exist even if npm publishing failed, so we need to check npm directly
            echo "Checking if package exists on npm registry..."

            # Query npm registry to check if package exists
            # Returns 0 if package exists, non-zero if it doesn't
            if npm view "$package" version --registry=https://registry.npmjs.org &>/dev/null; then
              # Package exists on npm
              NPM_VERSION=$(npm view "$package" version --registry=https://registry.npmjs.org 2>/dev/null || echo "unknown")
              echo "üì¶ Status: EXISTING package on npm (current version: $NPM_VERSION)"
              echo "Publishing without --first-release flag..."

              # Use Nx PROJECT NAME for the --projects flag
              if npx nx release publish --projects="$project" --tag=${{ steps.npm-tag.outputs.tag }} --registry=https://registry.npmjs.org; then
                echo "‚úÖ Successfully published $package"
                SUCCESS_PACKAGES+=("$package")
              else
                echo "‚ùå Failed to publish $package"
                FAILED_PACKAGES+=("$package")
              fi
            else
              # Package does NOT exist on npm (truly a first release)
              echo "üÜï Status: NEW package (not found on npm registry)"

              # Show Git tags if they exist (for debugging orphaned tags)
              FOUND_TAGS=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -u || echo "")
              if [ -n "$FOUND_TAGS" ]; then
                echo "‚ö†Ô∏è  Note: Git tags exist but package not on npm (likely from failed previous publish)"
                echo "Git tags found:"
                echo "$FOUND_TAGS" | head -n 3
                echo ""
              fi

              echo "Publishing with --first-release flag..."

              # Use Nx PROJECT NAME for the --projects flag
              if npx nx release publish --projects="$project" --first-release --tag=${{ steps.npm-tag.outputs.tag }} --registry=https://registry.npmjs.org; then
                echo "‚úÖ Successfully published $package (first release)"
                SUCCESS_PACKAGES+=("$package")
              else
                echo "‚ùå Failed to publish $package (first release)"
                FAILED_PACKAGES+=("$package")
              fi
            fi

            echo ""
          done

          # Report results
          echo "=========================================="
          echo "Publishing Summary"
          echo "=========================================="
          echo "Successful: ${#SUCCESS_PACKAGES[@]} package(s)"
          for pkg in "${SUCCESS_PACKAGES[@]}"; do
            echo "  ‚úÖ $pkg"
          done

          if [ ${#FAILED_PACKAGES[@]} -gt 0 ]; then
            echo ""
            echo "Failed: ${#FAILED_PACKAGES[@]} package(s)"
            for pkg in "${FAILED_PACKAGES[@]}"; do
              echo "  ‚ùå $pkg"
            done
            echo ""
            echo "‚ùå Some packages failed to publish. Check the logs above for details."
            exit 1
          else
            echo ""
            echo "‚úÖ All packages published successfully!"
          fi

      - name: Push version commits and tags
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.affected.outputs.has_affected == 'true'
        run: |
          # Push commits and tags created by Nx
          git push origin ${{ github.ref_name }} --follow-tags
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}

      - name: Create GitHub releases
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.affected.outputs.has_affected == 'true'
        run: |
          # Get the tags that were just pushed (created by Nx release version)
          # These are the tags created since the previous commit
          AFFECTED_PACKAGES="${{ steps.affected.outputs.packages }}"

          echo "Creating GitHub releases for affected packages..."
          echo "npm packages: $AFFECTED_PACKAGES"
          echo ""

          # Convert comma-separated list to array
          IFS=',' read -ra PACKAGES <<< "$AFFECTED_PACKAGES"

          for package in "${PACKAGES[@]}"; do
            if [ -z "$package" ]; then
              continue
            fi

            echo "Processing package: $package"

            # Extract the package name without scope for tag checking
            PACKAGE_NAME=$(echo "$package" | sed 's/@[^/]*\///')

            # Get the latest tag for this package
            # Nx creates tags in the format: package-name@version or @scope/package-name@version
            # Use git tag glob patterns for precise matching without escaping issues
            LATEST_TAG=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -V | tail -n 1)

            if [ -n "$LATEST_TAG" ]; then
              # Extract version from tag
              VERSION="${LATEST_TAG##*@}"

              # Check if release already exists
              if gh release view "$LATEST_TAG" &>/dev/null; then
                echo "‚úì Release $LATEST_TAG already exists, skipping"
              else
                echo "Creating GitHub release for $LATEST_TAG"

                # Create the release with a basic changelog
                # The AI-generated changelog will be added to Slack/Notion notifications
                gh release create "$LATEST_TAG" \
                  --title "$package $VERSION" \
                  --notes "Release $VERSION of $package. See [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details." \
                  --verify-tag

                echo "‚úÖ Created release for $LATEST_TAG"
              fi
            else
              echo "‚ö†Ô∏è No tag found for $package (this might indicate the package was not versioned)"
            fi

            echo ""
          done

          echo "GitHub releases creation complete."
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}

  generate-changelog:
    name: Generate AI-powered changelog
    needs: publish
    if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && needs.publish.outputs.has_affected == 'true'
    uses: ./.github/workflows/_generate-changelog.yml
    with:
      from_ref: ${{ github.event.before }}
      to_ref: ${{ github.sha }}
      output_formats: 'slack,markdown'
      custom_prompt_file: '.github/prompts/release-changelog.md'
      max_tokens: 1024
    secrets:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

  notify-release:
    name: Notify release via Slack
    needs: [publish, generate-changelog]
    if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && needs.publish.outputs.has_affected == 'true'
    uses: ./.github/workflows/_notify-release.yml
    with:
      changelog_slack: ${{ needs.generate-changelog.outputs.changelog_slack }}
      changelog_markdown: ${{ needs.generate-changelog.outputs.changelog_markdown }}
      destinations: 'slack'
      from_ref: ${{ github.event.before }}
      to_ref: ${{ github.sha }}
      branch: ${{ github.ref_name }}
    secrets:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  sync-next:
    name: Sync next branch with main
    runs-on: ubuntu-24.04
    needs: publish
    # Only run when main branch is updated (not on next branch pushes)
    if: github.ref_name == 'main' && github.event_name == 'push'
    permissions:
      contents: write

    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - name: Checkout repository
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: Install Graphite CLI
        run: |
          # Install Graphite CLI using npm (faster than installing Homebrew)
          npm install -g @withgraphite/graphite-cli

          # Verify installation
          gt --version

      - name: Configure Git
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

      - name: Sync next branch with main
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
        run: |
          echo "Starting sync of next branch with main..."

          # Fetch all remote branches
          git fetch origin

          # Check if next branch exists on remote
          if ! git show-ref --verify --quiet refs/remotes/origin/next; then
            echo "Next branch does not exist on remote. Skipping sync."
            exit 0
          fi

          # Switch to next branch (tracking origin/next)
          git checkout -B next origin/next

          # Attempt to rebase next onto main
          echo "Rebasing next onto main..."

          # Try to rebase onto origin/main
          if git rebase origin/main; then
            echo "‚úÖ Rebase successful!"

            # Create an empty commit to mark this as a sync operation
            # This prevents the publish workflow from triggering on the next branch
            git commit --allow-empty -m "chore(sync): [skip ci] sync next with main"

            # Force push the rebased next branch
            git push origin next --force-with-lease

            echo "‚úÖ Successfully synced next branch with main"

            # Create summary
            echo "## üîÑ Branch Sync Complete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The \`next\` branch has been successfully rebased onto \`main\`." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Main branch**: $(git rev-parse --short origin/main)" >> $GITHUB_STEP_SUMMARY
            echo "- **Next branch**: $(git rev-parse --short next)" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Rebase failed due to conflicts"

            # Abort the rebase
            git rebase --abort

            # Create an issue for manual intervention
            gh issue create \
              --title "Manual intervention required: next branch sync failed" \
              --body "The automatic sync of the \`next\` branch with \`main\` has failed due to conflicts.

              ## Action Required
              Please manually resolve the conflicts by:
              1. Checking out the \`next\` branch locally
              2. Rebasing it onto \`main\`
              3. Resolving any conflicts
              4. Force pushing the resolved branch

              ## Commands
              \`\`\`bash
              git checkout next
              git fetch origin
              git rebase origin/main
              # Resolve conflicts
              git push origin next --force-with-lease
              \`\`\`

              This issue was automatically created by the publish-packages workflow." \
              --label "automated,needs-attention"

            echo "## ‚ö†Ô∏è Branch Sync Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The \`next\` branch could not be automatically rebased onto \`main\` due to conflicts." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "An issue has been created for manual intervention." >> $GITHUB_STEP_SUMMARY

            exit 1
          fi

      - name: Alternative sync with Graphite (if available)
        if: failure()
        continue-on-error: true
        run: |
          echo "Attempting alternative sync method with Graphite CLI..."

          # Initialize Graphite if needed
          gt init --trunk main --no-interactive || true

          # Try to sync using Graphite
          if gt sync --force --no-interactive; then
            echo "‚úÖ Successfully synced using Graphite CLI"
          else
            echo "‚ö†Ô∏è Graphite sync also failed. Manual intervention required."
          fi
