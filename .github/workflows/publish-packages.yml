name: Publish Packages

on:
  push:
    branches:
      - main
      - next
  workflow_dispatch:
    inputs:
      dryRun:
        description: 'Perform a dry run without publishing'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

jobs:
  publish:
    runs-on: ubuntu-24.04
    permissions:
      contents: write
      packages: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@1e60f620b9541d16bece96c5465dc8ee9832be0b
        with:
          node-version: '22.13.1'
          registry-url: 'https://npm.pkg.github.com'
          scope: '@ai-toolkit'

      - name: Setup Bun
        uses: oven-sh/setup-bun@735343b667d3e6f658f44d0eca948eb6282f2b76
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Configure Git
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

      - name: Determine npm tag
        id: npm-tag
        run: |
          if [[ "${{ github.ref_name }}" == "next" ]]; then
            echo "tag=next" >> $GITHUB_OUTPUT
            echo "Using 'next' tag for npm publish"
          else
            echo "tag=latest" >> $GITHUB_OUTPUT
            echo "Using 'latest' tag for npm publish"
          fi

      - name: Build packages
        run: bunx nx run-many --target=build

      - name: Version and publish packages (dry run)
        if: github.event.inputs.dryRun == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          echo "Running dry-run for affected packages with tag: ${{ steps.npm-tag.outputs.tag }}"
          if [[ "${{ github.ref_name }}" == "next" ]]; then
            echo "Using prerelease versioning for next branch"
            bunx nx release version prerelease --preid=next --dry-run
          else
            echo "Using standard versioning for main branch"
            bunx nx release version --dry-run
          fi
          npx nx release publish --dry-run --tag=${{ steps.npm-tag.outputs.tag }} --registry=https://npm.pkg.github.com
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NODE_AUTH_TOKEN }}

      - name: Version affected packages
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push'
        id: version
        run: |
          echo "Versioning affected packages"
          if [[ "${{ github.ref_name }}" == "next" ]]; then
            echo "Checking for stable versions that need to be converted to prerelease"

            # Get list of publishable packages from nx.json release projects
            RELEASE_PROJECTS=$(node -p "JSON.stringify(require('./nx.json').release.projects || [])" 2>/dev/null || echo "[]")
            echo "Release projects: $RELEASE_PROJECTS"

            # Check if any package has a stable version (no prerelease suffix)
            NEEDS_BUMP=false

            for PROJECT in $(echo "$RELEASE_PROJECTS" | node -p "JSON.parse(fs.readFileSync(0)).join(' ')"); do
              # Find the package.json for this project
              PACKAGE_PATH=""
              if [[ -f "packages/${PROJECT#@*/}/package.json" ]]; then
                PACKAGE_PATH="packages/${PROJECT#@*/}/package.json"
              elif [[ -f "${PROJECT}/package.json" ]]; then
                PACKAGE_PATH="${PROJECT}/package.json"
              else
                PACKAGE_PATH=$(find . -name "package.json" -path "*/packages/*" | xargs grep -l "\"name\": \"$PROJECT\"" | head -1)
              fi

              if [[ -n "$PACKAGE_PATH" ]]; then
                PACKAGE_VERSION=$(node -p "require('./$PACKAGE_PATH').version" 2>/dev/null || echo "")
                echo "Checking $PROJECT: version $PACKAGE_VERSION"

                # Check if it's a stable version (no prerelease suffix)
                if [[ "$PACKAGE_VERSION" != *"-"* && -n "$PACKAGE_VERSION" ]]; then
                  echo "  ‚Üí Found stable version, will bump to next prerelease"
                  NEEDS_BUMP=true
                  break
                fi
              fi
            done

            if [[ "$NEEDS_BUMP" == "true" ]]; then
              echo "Bumping stable versions to new prerelease versions"

              # Build a list of all packages that need bumping with their new versions
              PROJECTS_TO_BUMP=""
              VERSION_MAP=""

              for PROJECT in $(echo "$RELEASE_PROJECTS" | node -p "JSON.parse(fs.readFileSync(0)).join(' ')"); do
                # Find the package.json for this project
                PACKAGE_PATH=""
                if [[ -f "packages/${PROJECT#@*/}/package.json" ]]; then
                  PACKAGE_PATH="packages/${PROJECT#@*/}/package.json"
                elif [[ -f "${PROJECT}/package.json" ]]; then
                  PACKAGE_PATH="${PROJECT}/package.json"
                else
                  PACKAGE_PATH=$(find . -name "package.json" -path "*/packages/*" | xargs grep -l "\"name\": \"$PROJECT\"" | head -1)
                fi

                if [[ -n "$PACKAGE_PATH" ]]; then
                  PACKAGE_VERSION=$(node -p "require('./$PACKAGE_PATH').version" 2>/dev/null || echo "")

                  # If it's a stable version, calculate the next minor prerelease
                  if [[ "$PACKAGE_VERSION" != *"-"* && -n "$PACKAGE_VERSION" ]]; then
                    # Parse version and bump minor for next branch development
                    IFS='.' read -r MAJOR MINOR PATCH <<< "$PACKAGE_VERSION"
                    NEW_MINOR=$((MINOR + 1))
                    NEW_VERSION="${MAJOR}.${NEW_MINOR}.0-next.0"

                    echo "Will set $PROJECT from $PACKAGE_VERSION to $NEW_VERSION"

                    # Add to the list of projects to bump
                    if [[ -n "$PROJECTS_TO_BUMP" ]]; then
                      PROJECTS_TO_BUMP="$PROJECTS_TO_BUMP,$PROJECT"
                    else
                      PROJECTS_TO_BUMP="$PROJECT"
                    fi

                    # Store the version mapping
                    VERSION_MAP="${VERSION_MAP}${PROJECT}:${NEW_VERSION}\n"
                  fi
                fi
              done

              if [[ -n "$PROJECTS_TO_BUMP" ]]; then
                echo "Bumping all stable packages together..."

                # Create a temporary file with version updates
                echo -e "$VERSION_MAP" > /tmp/version_map.txt

                # Apply all version updates in a single command to avoid dependency conflicts
                while IFS=: read -r PROJECT VERSION; do
                  if [[ -n "$PROJECT" && -n "$VERSION" ]]; then
                    echo "Applying version $VERSION to $PROJECT"

                    # Find and update the package.json directly
                    PACKAGE_PATH=""
                    if [[ -f "packages/${PROJECT#@*/}/package.json" ]]; then
                      PACKAGE_PATH="packages/${PROJECT#@*/}/package.json"
                    elif [[ -f "${PROJECT}/package.json" ]]; then
                      PACKAGE_PATH="${PROJECT}/package.json"
                    else
                      PACKAGE_PATH=$(find . -name "package.json" -path "*/packages/*" | xargs grep -l "\"name\": \"$PROJECT\"" | head -1)
                    fi

                    if [[ -n "$PACKAGE_PATH" ]]; then
                      # Update version in package.json
                      node -e "
                        const fs = require('fs');
                        const pkg = JSON.parse(fs.readFileSync('$PACKAGE_PATH', 'utf8'));
                        pkg.version = '$VERSION';
                        fs.writeFileSync('$PACKAGE_PATH', JSON.stringify(pkg, null, 2) + '\\n');
                      "
                    fi
                  fi
                done < /tmp/version_map.txt

                # Update bun lockfile
                bun install

                # Commit and tag (only if there are changes)
                git add .
                if git diff --staged --quiet; then
                  echo "No changes to commit after version bump"
                else
                  git commit -m "chore(release): bump stable versions to next prerelease [skip ci]"
                fi

                # Create tags for each package
                while IFS=: read -r PROJECT VERSION; do
                  if [[ -n "$PROJECT" && -n "$VERSION" ]]; then
                    TAG="${PROJECT}@${VERSION}"
                    # Check if tag already exists
                    if git rev-parse "$TAG" >/dev/null 2>&1; then
                      echo "Tag $TAG already exists, skipping"
                    else
                      git tag "$TAG"
                      echo "Tagged: $TAG"
                    fi
                  fi
                done < /tmp/version_map.txt

                # Clean up
                rm -f /tmp/version_map.txt
              fi
            else
              echo "Using standard prerelease versioning for next branch"
              bunx nx release version prerelease --preid=next
            fi
          else
            echo "Checking for version graduation on main branch"

            # Get list of publishable packages from nx.json release projects
            RELEASE_PROJECTS=$(node -p "JSON.stringify(require('./nx.json').release.projects || [])" 2>/dev/null || echo "[]")
            echo "Release projects: $RELEASE_PROJECTS"

            # Check if any publishable package has a prerelease version
            HAS_PRERELEASE=false
            GRADUATE_COMMANDS=""

            # Parse the JSON array and check each project
            for PROJECT in $(echo "$RELEASE_PROJECTS" | node -p "JSON.parse(fs.readFileSync(0)).join(' ')"); do
              # Skip non-package projects (like 'utils' which might not have a package.json)
              if [[ ! -f "packages/${PROJECT#@*/}/package.json" ]] && [[ ! -f "${PROJECT}/package.json" ]]; then
                echo "Skipping $PROJECT (no package.json found)"
                continue
              fi

              # Try to find the package.json (handle both scoped and unscoped names)
              PACKAGE_PATH=""
              if [[ -f "packages/${PROJECT#@*/}/package.json" ]]; then
                PACKAGE_PATH="packages/${PROJECT#@*/}/package.json"
              elif [[ -f "${PROJECT}/package.json" ]]; then
                PACKAGE_PATH="${PROJECT}/package.json"
              else
                # Try to find it using the project name directly
                PACKAGE_PATH=$(find . -name "package.json" -path "*/packages/*" | xargs grep -l "\"name\": \"$PROJECT\"" | head -1)
              fi

              if [[ -n "$PACKAGE_PATH" ]]; then
                PACKAGE_VERSION=$(node -p "require('./$PACKAGE_PATH').version" 2>/dev/null || echo "")
                echo "Checking $PROJECT: version $PACKAGE_VERSION"

                if [[ "$PACKAGE_VERSION" == *"-next."* ]]; then
                  # Extract base version without prerelease suffix
                  BASE_VERSION=${PACKAGE_VERSION%-next.*}
                  echo "  ‚Üí Will graduate from $PACKAGE_VERSION to $BASE_VERSION"
                  HAS_PRERELEASE=true

                  # Build the graduation command for this package
                  if [[ -n "$GRADUATE_COMMANDS" ]]; then
                    GRADUATE_COMMANDS="$GRADUATE_COMMANDS && "
                  fi
                  GRADUATE_COMMANDS="${GRADUATE_COMMANDS}bunx nx release version $BASE_VERSION --projects=$PROJECT"
                fi
              fi
            done

            if [[ "$HAS_PRERELEASE" == "true" ]]; then
              echo "Graduating prerelease versions to stable"
              eval "$GRADUATE_COMMANDS"
            else
              echo "No prerelease versions found, using standard versioning for main branch"
              bunx nx release version
            fi
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish affected packages
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push'
        run: |
          echo "Publishing affected packages with tag: ${{ steps.npm-tag.outputs.tag }}"
          # Use npm for publishing to ensure compatibility with GitHub Packages
          npx nx release publish --tag=${{ steps.npm-tag.outputs.tag }} --registry=https://npm.pkg.github.com
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NODE_AUTH_TOKEN }}

      - name: Push version commits and tags
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push'
        run: |
          # Check if there are commits to push
          if git diff origin/${{ github.ref_name }}..HEAD --quiet 2>/dev/null; then
            echo "No new commits to push"
          else
            echo "Pushing commits to origin/${{ github.ref_name }}"
            git push origin ${{ github.ref_name }}
          fi

          # Check if there are tags to push
          UNPUSHED_TAGS=$(git push --tags --dry-run 2>&1 | grep -c "new tag" || true)
          if [[ "$UNPUSHED_TAGS" -gt 0 ]]; then
            echo "Pushing $UNPUSHED_TAGS new tags to origin"
            git push origin --tags
          else
            echo "No new tags to push"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create GitHub releases
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push'
        run: |
          # Nx Release will create GitHub releases based on changelog configuration
          echo "GitHub releases will be created by Nx Release based on the changelog configuration"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  sync-next:
    name: Sync next branch with main
    runs-on: ubuntu-24.04
    needs: publish
    # Only run when main branch is updated (not on next branch pushes)
    if: github.ref_name == 'main' && github.event_name == 'push'
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@735343b667d3e6f658f44d0eca948eb6282f2b76
        with:
          bun-version: latest

      - name: Install Graphite CLI
        run: |
          # Install Graphite CLI using npm (faster than installing Homebrew)
          npm install -g @withgraphite/graphite-cli

          # Verify installation
          gt --version

      - name: Configure Git
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

      - name: Sync next branch with main
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Starting sync of next branch with main..."

          # Fetch all remote branches
          git fetch origin

          # Check if next branch exists on remote
          if ! git show-ref --verify --quiet refs/remotes/origin/next; then
            echo "Next branch does not exist on remote. Skipping sync."
            exit 0
          fi

          # Switch to next branch (tracking origin/next)
          git checkout -B next origin/next

          # Attempt to rebase next onto main
          echo "Rebasing next onto main..."

          # Try to rebase onto origin/main
          if git rebase origin/main; then
            echo "‚úÖ Rebase successful!"

            # Force push the rebased next branch
            git push origin next --force-with-lease

            echo "‚úÖ Successfully synced next branch with main"

            # Create summary
            echo "## üîÑ Branch Sync Complete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The \`next\` branch has been successfully rebased onto \`main\`." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Main branch**: $(git rev-parse --short origin/main)" >> $GITHUB_STEP_SUMMARY
            echo "- **Next branch**: $(git rev-parse --short next)" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Rebase failed due to conflicts"

            # Abort the rebase
            git rebase --abort

            # Create an issue for manual intervention
            gh issue create \
              --title "Manual intervention required: next branch sync failed" \
              --body "The automatic sync of the \`next\` branch with \`main\` has failed due to conflicts.

              ## Action Required
              Please manually resolve the conflicts by:
              1. Checking out the \`next\` branch locally
              2. Rebasing it onto \`main\`
              3. Resolving any conflicts
              4. Force pushing the resolved branch

              ## Commands
              \`\`\`bash
              git checkout next
              git fetch origin
              git rebase origin/main
              # Resolve conflicts
              git push origin next --force-with-lease
              \`\`\`

              This issue was automatically created by the publish-packages workflow." \
              --label "automated,needs-attention"

            echo "## ‚ö†Ô∏è Branch Sync Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The \`next\` branch could not be automatically rebased onto \`main\` due to conflicts." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "An issue has been created for manual intervention." >> $GITHUB_STEP_SUMMARY

            exit 1
          fi

      - name: Alternative sync with Graphite (if available)
        if: failure()
        continue-on-error: true
        run: |
          echo "Attempting alternative sync method with Graphite CLI..."

          # Initialize Graphite if needed
          gt init --trunk main --no-interactive || true

          # Try to sync using Graphite
          if gt sync --force --no-interactive; then
            echo "‚úÖ Successfully synced using Graphite CLI"
          else
            echo "‚ö†Ô∏è Graphite sync also failed. Manual intervention required."
          fi
