name: Publish Packages

# This workflow handles versioning, building, and publishing packages to NPM for both
# production (main branch) and pre-release (next branch) deployments.
#
# REQUIRED SECRETS:
# 1. WORKFLOW_PAT: Personal Access Token with 'repo' and 'workflow' scopes
#    - Required to push version commits and tags back to the repository
#    - Create at: GitHub Settings > Developer settings > Personal access tokens
# 2. ANTHROPIC_API_KEY: API key for AI-powered changelog generation
#    - Required to generate intelligent release changelogs
#    - Create at: https://console.anthropic.com/settings/keys
# 3. SLACK_WEBHOOK_URL: Incoming webhook URL for release notifications
#    - Required to send notifications to #ai-internal Slack channel
#    - Create at: https://api.slack.com/apps > Incoming Webhooks
# 4. NODE_AUTH_TOKEN: NPM authentication token
#    - Required to publish packages to NPM registry
#    - Create at: https://www.npmjs.com/settings/your-username/tokens
#
# WORKFLOW BEHAVIOR:
# - Triggered on push to 'main' or 'next' branches
# - Can be manually triggered with optional dry-run mode
# - Versions packages based on conventional commits
# - Publishes to NPM with appropriate tags (latest for main, next for next branch)
# - Generates AI-powered changelog for release notes
# - Sends Slack notification with changelog
# - Syncs 'next' branch with 'main' after production releases
#
# ARCHITECTURE:
# This workflow uses a multi-job orchestration pattern:
# 1. publish: Builds, versions, and publishes packages to NPM
# 2. generate-changelog: Generates AI-powered changelog using reusable workflow
# 3. notify-release: Sends Slack notification with changelog using reusable workflow
# 4. sync-next: Syncs 'next' branch with 'main' after production releases
#
# The changelog generation and notification are separated into reusable workflows
# for better maintainability and reusability across different workflows.

on:
  push:
    branches:
      - main
      - next
  workflow_dispatch:
    inputs:
      dryRun:
        description: 'Perform a dry run without publishing'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

# Ensure only one publish workflow runs at a time per branch
# If a new run is triggered while one is in progress, it will be queued
# Setting cancel-in-progress to false ensures queued runs execute sequentially
concurrency:
  group: publish-${{ github.ref }}
  cancel-in-progress: false

jobs:
  publish:
    runs-on:
      group: npm-deploy
    environment: ${{ github.event_name == 'push' && 'Production' || null }}
    permissions:
      id-token: write
      contents: write
      packages: write
      pull-requests: write
      issues: write
    outputs:
      has_affected: ${{ steps.affected.outputs.has_affected }}
      successful_packages: ${{ steps.publish.outputs.successful_packages }}
      failed_packages: ${{ steps.publish.outputs.failed_packages }}
      successful_count: ${{ steps.publish.outputs.successful_count }}
      failed_count: ${{ steps.publish.outputs.failed_count }}
      has_failures: ${{ steps.publish.outputs.has_failures }}
      has_successes: ${{ steps.publish.outputs.has_successes }}
    # Skip the workflow if the commit is a version bump (to prevent loops)
    # Allow workflow to run for merge commits from update-production workflow
    # Skip workflow for branch sync commits
    if: ${{ !startsWith(github.event.head_commit.message, 'chore(release):') && !startsWith(github.event.head_commit.message, 'chore(sync):') }}

    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec # v6
        with:
          gpg_private_key: ${{ secrets.SERVICE_ACCOUNT_GPG_PRIVATE_KEY }}
          git_user_signingkey: true
          git_commit_gpgsign: true
          git_tag_gpgsign: true
          git_config_global: true

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: Setup Node.js
        uses: actions/setup-node@2028fbc5c25fe9cf00d9f06a71cc4710d4507903 # v6.0.0
        with:
          node-version: '22.21.1'
          registry-url: 'https://registry.npmjs.org'
          scope: '@uniswap'

      - name: Install npm
        run: npm install -g npm@11.6.2
        # IMPORTANT: Pinning to npm 11.6.2 for two reasons:
        # 1. OIDC trusted publishing requires npm >= 11.5.1
        # 2. Using a pinned version prevents lockfile format changes in CI
        # Local developers should use: npm install -g npm@11.6.2
      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Verify package-lock.json unchanged
        run: |
          if ! git diff --exit-code package-lock.json; then
            echo "‚ùå ERROR: npm ci modified package-lock.json!"
            echo "This should not happen. Please investigate why npm ci is modifying the lock file."
            git diff package-lock.json
            exit 1
          fi
          echo "‚úÖ package-lock.json unchanged after npm ci"

      - name: Configure Git identity for service account
        run: |
          git config user.name "Uniswap Labs Service Account"
          git config user.email "hello-happy-puppy@uniswap.org"

      - name: Verify GPG configuration
        run: |
          echo "GPG signing enabled: $(git config commit.gpgsign)"
          echo "GPG signing key: $(git config user.signingkey)"
          echo "Git user name: $(git config user.name)"
          echo "Git user email: $(git config user.email)"

      - name: Determine npm tag
        id: npm-tag
        run: |
          if [[ "${{ github.ref_name }}" == "next" ]]; then
            echo "tag=next" >> $GITHUB_OUTPUT
            echo "Using 'next' tag for npm publish"
          else
            echo "tag=latest" >> $GITHUB_OUTPUT
            echo "Using 'latest' tag for npm publish"
          fi

      - name: Determine base SHA for affected detection
        id: base-sha
        run: |
          # For push events, use the commit before the push
          # For manual triggers, fall back to HEAD~1
          if [[ "${{ github.event_name }}" == "push" ]]; then
            BASE_SHA="${{ github.event.before }}"

            # Handle edge case: first push to a new branch (null SHA)
            if [[ "$BASE_SHA" == "0000000000000000000000000000000000000000" ]]; then
              echo "First push to branch - using HEAD~1 as base"
              echo "base=HEAD~1" >> $GITHUB_OUTPUT
            else
              echo "Using commit before push: $BASE_SHA"
              echo "base=$BASE_SHA" >> $GITHUB_OUTPUT
            fi
          else
            # Manual workflow dispatch - use previous commit
            echo "Manual trigger - using HEAD~1 as base"
            echo "base=HEAD~1" >> $GITHUB_OUTPUT
          fi

      - name: Determine affected packages
        id: affected
        run: |
          # Get affected projects using Nx
          echo "Running: npx nx show projects --affected --base=${{ steps.base-sha.outputs.base }} --head=HEAD --type=lib --json"

          # Capture output and check if it's valid JSON
          # Suppress Node.js deprecation warnings and npm warnings to avoid polluting JSON output
          RAW_OUTPUT=$(NODE_NO_WARNINGS=1 npx nx show projects --affected --base=${{ steps.base-sha.outputs.base }} --head=HEAD --type=lib --json 2>&1 || echo "[]")

          # Filter out npm warnings (lines starting with "npm warn")
          AFFECTED_OUTPUT=$(echo "$RAW_OUTPUT" | grep -v '^npm warn' || echo "[]")

          echo "AFFECTED_OUTPUT: $AFFECTED_OUTPUT"

          # Check if output is valid JSON
          if echo "$AFFECTED_OUTPUT" | jq empty 2>/dev/null; then
            AFFECTED_JSON="$AFFECTED_OUTPUT"
          else
            echo "‚ö†Ô∏è  Nx output is not valid JSON. Output:"
            echo "$AFFECTED_OUTPUT"
            echo "Using empty array as fallback"
            AFFECTED_JSON="[]"
          fi

          # Extract project names and filter out private packages
          # Read each project and check if it has "private": true in package.json
          echo "Filtering out private packages..."
          PUBLISHABLE_PROJECTS=()
          PACKAGE_NAMES=()

          for project in $(echo "$AFFECTED_JSON" | jq -r '.[]'); do
            # Find the package.json for this project
            # Use nx show project to get the project root
            PROJECT_ROOT=$(npx nx show project "$project" --json 2>/dev/null | jq -r '.root' || echo "")

            if [ -n "$PROJECT_ROOT" ] && [ -f "$PROJECT_ROOT/package.json" ]; then
              # Check if package is private
              IS_PRIVATE=$(jq -r '.private // false' "$PROJECT_ROOT/package.json")

              if [ "$IS_PRIVATE" = "true" ]; then
                echo "  ‚è≠Ô∏è  Skipping $project (private: true)"
              else
                PACKAGE_NAME=$(jq -r '.name // ""' "$PROJECT_ROOT/package.json")
                if [ -n "$PACKAGE_NAME" ]; then
                  echo "  ‚úÖ Including $project ‚Üí $PACKAGE_NAME (publishable)"
                  PUBLISHABLE_PROJECTS+=("$project")  # Store Nx project name
                  PACKAGE_NAMES+=("$PACKAGE_NAME")    # Store npm package name
                else
                  echo "  ‚ö†Ô∏è  Skipping $project (no package name found)"
                fi
              fi
            else
              echo "  ‚ö†Ô∏è  Skipping $project (no package.json found)"
            fi
          done

          # Join arrays with commas
          AFFECTED_PROJECTS=$(IFS=,; echo "${PUBLISHABLE_PROJECTS[*]}")
          AFFECTED_PACKAGES=$(IFS=,; echo "${PACKAGE_NAMES[*]}")

          echo "Publishable affected projects (Nx names): $AFFECTED_PROJECTS"
          echo "Publishable affected packages (npm names): $AFFECTED_PACKAGES"

          echo "projects=$AFFECTED_PROJECTS" >> $GITHUB_OUTPUT
          echo "packages=$AFFECTED_PACKAGES" >> $GITHUB_OUTPUT

          # Set a flag indicating if any packages are affected
          if [ -z "$AFFECTED_PROJECTS" ] || [ "$AFFECTED_PROJECTS" = "null" ]; then
            echo "has_affected=false" >> $GITHUB_OUTPUT
            echo "No publishable affected packages found - skipping release"
          else
            echo "has_affected=true" >> $GITHUB_OUTPUT
            echo "Found ${#PUBLISHABLE_PROJECTS[@]} publishable package(s)"
          fi

      - name: Build affected packages
        if: steps.affected.outputs.has_affected == 'true'
        run: |
          echo "Building affected packages: ${{ steps.affected.outputs.projects }}"
          npx nx affected --target=build --base=${{ steps.base-sha.outputs.base }} --head=HEAD

      - name: Clean up orphaned tags
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.affected.outputs.has_affected == 'true'
        run: |
          # Configure npm authentication for viewing restricted packages
          # The @uniswap packages are restricted and require authentication even for read operations
          echo "//registry.npmjs.org/:_authToken=${NODE_AUTH_TOKEN}" > ~/.npmrc
          echo "Configured npm authentication for restricted package queries"
          echo ""

          AFFECTED_PACKAGES="${{ steps.affected.outputs.packages }}"

          echo "=========================================="
          echo "Checking for orphaned Git tags"
          echo "=========================================="
          echo ""
          echo "Orphaned tags are Git tags that exist but their corresponding"
          echo "npm package version was never successfully published."
          echo "These must be cleaned up before versioning can proceed."
          echo ""

          # Convert comma-separated list to array
          IFS=',' read -ra PACKAGES <<< "$AFFECTED_PACKAGES"

          CLEANED_TAGS=()

          for package in "${PACKAGES[@]}"; do
            if [ -z "$package" ]; then
              continue
            fi

            echo "Checking package: $package"

            # Extract the package name without scope for tag checking
            PACKAGE_NAME=$(echo "$package" | sed 's/@[^/]*\///')

            # Get the latest tag for this package
            LATEST_TAG=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -V | tail -n 1)

            if [ -z "$LATEST_TAG" ]; then
              echo "  ‚ÑπÔ∏è  No tags found - will create first tag during versioning"
              echo ""
              continue
            fi

            # Extract version from tag
            VERSION="${LATEST_TAG##*@}"
            echo "  Latest tag: $LATEST_TAG (version: $VERSION)"

            # Check if this specific version exists on npm
            if npm view "${package}@${VERSION}" version --registry=https://registry.npmjs.org &>/dev/null; then
              echo "  ‚úÖ Version $VERSION exists on npm - tag is valid"
              echo ""
            else
              echo "  ‚ö†Ô∏è  Version $VERSION NOT found on npm - tag is orphaned!"
              echo "  üßπ Deleting orphaned tag: $LATEST_TAG"

              # Delete tag locally
              if git tag -d "$LATEST_TAG" 2>/dev/null; then
                echo "  ‚úÖ Deleted local tag"
              else
                echo "  ‚ö†Ô∏è  Local tag already deleted or doesn't exist"
              fi

              # Delete tag from remote
              if git push --delete origin "$LATEST_TAG" 2>/dev/null; then
                echo "  ‚úÖ Deleted remote tag"
                CLEANED_TAGS+=("$LATEST_TAG")
              else
                echo "  ‚ö†Ô∏è  Remote tag already deleted or doesn't exist"
              fi

              echo ""
            fi
          done

          echo ""
          echo "=========================================="
          echo "Checking for missing Git tags"
          echo "=========================================="
          echo ""
          echo "Missing tags are npm versions that were successfully"
          echo "published but their Git tags were never pushed to remote."
          echo "These must be created so Nx can properly version from them."
          echo ""

          CREATED_TAGS=()

          for package in "${PACKAGES[@]}"; do
            if [ -z "$package" ]; then
              continue
            fi

            echo "Checking package: $package"

            # Get latest version from npm for the appropriate dist-tag
            if [[ "${{ github.ref_name }}" == "next" ]]; then
              LATEST_NPM=$(npm view "$package" dist-tags.next --registry=https://registry.npmjs.org 2>/dev/null || echo "")
              echo "  Querying npm dist-tag 'next'..."
            else
              LATEST_NPM=$(npm view "$package" version --registry=https://registry.npmjs.org 2>/dev/null || echo "")
              echo "  Querying npm version (latest)..."
            fi

            if [ -z "$LATEST_NPM" ]; then
              echo "  ‚ÑπÔ∏è  Package not on npm yet (will be first release)"
              echo ""
              continue
            fi

            EXPECTED_TAG="${package}@${LATEST_NPM}"
            echo "  Latest npm version: $LATEST_NPM"

            # Check if Git tag exists for this version
            if git rev-parse "$EXPECTED_TAG" >/dev/null 2>&1; then
              echo "  ‚úÖ Git tag exists: $EXPECTED_TAG (in sync)"
            else
              echo "  üîß Git tag missing for npm version $LATEST_NPM"
              echo "  üè∑Ô∏è  Creating tag: $EXPECTED_TAG"

              # Create tag at current HEAD
              # (Assumes HEAD is at or past the commit where this version was published)
              if git tag "$EXPECTED_TAG" HEAD 2>/dev/null; then
                echo "  ‚úÖ Created local tag at HEAD"
                CREATED_TAGS+=("$EXPECTED_TAG")
              else
                echo "  ‚ö†Ô∏è  Failed to create tag (may already exist locally)"
              fi
            fi

            echo ""
          done

          # Push any newly created tags to remote
          PUSHED_TAGS=()
          FAILED_PUSH_TAGS=()

          if [ ${#CREATED_TAGS[@]} -gt 0 ]; then
            echo "=========================================="
            echo "Pushing missing tags to remote"
            echo "=========================================="
            echo ""

            for tag in "${CREATED_TAGS[@]}"; do
              echo "  üè∑Ô∏è  Pushing tag: $tag"
              if git push origin "$tag" 2>/dev/null; then
                echo "  ‚úÖ Successfully pushed $tag"
                PUSHED_TAGS+=("$tag")
              else
                # Check if tag already exists on remote (not a real failure)
                if git ls-remote --tags origin | grep -q "refs/tags/$tag$"; then
                  echo "  ‚úÖ Tag $tag already exists on remote"
                  PUSHED_TAGS+=("$tag")
                else
                  echo "  ‚ùå Failed to push $tag"
                  FAILED_PUSH_TAGS+=("$tag")
                fi
              fi
            done

            echo ""
          fi

          # Summary
          echo "=========================================="
          echo "Git/npm Sync Summary"
          echo "=========================================="

          if [ ${#CLEANED_TAGS[@]} -gt 0 ]; then
            echo "Orphaned Tags Cleaned (deleted): ${#CLEANED_TAGS[@]}"
            for tag in "${CLEANED_TAGS[@]}"; do
              echo "  üßπ $tag"
            done
            echo "  ‚Üí These will be recreated with correct associations"
          else
            echo "Orphaned Tags Cleaned: 0"
            echo "  ‚úÖ No orphaned tags found"
          fi

          echo ""

          if [ ${#PUSHED_TAGS[@]} -gt 0 ]; then
            echo "Missing Tags Created and Pushed: ${#PUSHED_TAGS[@]}"
            for tag in "${PUSHED_TAGS[@]}"; do
              echo "  ‚úÖ $tag"
            done
            echo "  ‚Üí Nx will now use these as base for version bumps"
          else
            echo "Missing Tags Synced: 0"
            echo "  ‚úÖ Git tags already in sync with npm versions"
          fi

          if [ ${#FAILED_PUSH_TAGS[@]} -gt 0 ]; then
            echo ""
            echo "‚ö†Ô∏è  Failed to Push Tags: ${#FAILED_PUSH_TAGS[@]}"
            for tag in "${FAILED_PUSH_TAGS[@]}"; do
              echo "  ‚ùå $tag"
            done
            echo "  ‚Üí These tags exist locally but not on remote. Manual push may be required."
          fi

          echo ""
          echo "‚úÖ Git/npm synchronization complete."
          echo "   Nx versioning will now use accurate base versions."
          echo ""
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
          NODE_AUTH_TOKEN: ${{ secrets.NODE_AUTH_TOKEN }}

      - name: Version and publish packages (dry run)
        if: github.event.inputs.dryRun == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          echo "Running dry-run for affected packages with tag: ${{ steps.npm-tag.outputs.tag }}"
          if [[ "${{ github.ref_name }}" == "next" ]]; then
            echo "Using prerelease versioning for next branch"
            npx nx release version prerelease --preid=next --dry-run
          else
            echo "Using graduate versioning for main branch (prerelease ‚Üí stable)"
            npx nx release version --specifier=graduate --dry-run
          fi
          npx nx release publish --dry-run --tag=${{ steps.npm-tag.outputs.tag }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Version, publish, and push packages (atomic per package)
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.affected.outputs.has_affected == 'true'
        id: publish
        run: |
          # Configure npm authentication for viewing restricted packages
          # The @uniswap packages are restricted and require authentication even for read operations
          echo "//registry.npmjs.org/:_authToken=${NODE_AUTH_TOKEN}" > ~/.npmrc
          echo "Configured npm authentication for restricted package queries"
          echo ""

          AFFECTED_PROJECTS="${{ steps.affected.outputs.projects }}"
          AFFECTED_PACKAGES="${{ steps.affected.outputs.packages }}"
          echo "Processing affected packages with tag: ${{ steps.npm-tag.outputs.tag }}"
          echo "Nx projects: $AFFECTED_PROJECTS"
          echo "npm packages: $AFFECTED_PACKAGES"
          echo ""
          echo "=========================================="
          echo "ATOMIC PUBLISH STRATEGY"
          echo "=========================================="
          echo "For each package, we will:"
          echo "  1. Version the package (update package.json, create commit + tag)"
          echo "  2. Publish to npm"
          echo "  3. If successful: immediately push commit + tag to remote"
          echo "  4. If failed: revert local changes and continue"
          echo ""
          echo "This ensures git and npm stay in sync after each publish."
          echo ""

          # Convert comma-separated lists to arrays
          IFS=',' read -ra PROJECTS <<< "$AFFECTED_PROJECTS"
          IFS=',' read -ra PACKAGES <<< "$AFFECTED_PACKAGES"

          # Track publishing results
          FAILED_PACKAGES=()
          SUCCESS_PACKAGES=()

          # Process each package atomically: version ‚Üí publish ‚Üí push
          for i in "${!PROJECTS[@]}"; do
            project="${PROJECTS[$i]}"
            package="${PACKAGES[$i]}"

            if [ -z "$project" ] || [ -z "$package" ]; then
              continue
            fi

            echo "=========================================="
            echo "Processing: $project ‚Üí $package"
            echo "=========================================="

            # Extract the package name without scope
            PACKAGE_NAME=$(echo "$package" | sed 's/@[^/]*\///')

            # Step 1: Version this specific package
            echo ""
            echo "Step 1: Versioning package..."
            if [[ "${{ github.ref_name }}" == "next" ]]; then
              echo "Using prerelease versioning for next branch"
              if ! npx nx release version prerelease --preid=next --projects="$project"; then
                echo "‚ùå Failed to version $package"
                FAILED_PACKAGES+=("$package")
                echo ""
                continue
              fi
            else
              echo "Using graduate versioning for main branch (prerelease ‚Üí stable)"
              if ! npx nx release version --specifier=graduate --projects="$project"; then
                echo "‚ùå Failed to version $package"
                FAILED_PACKAGES+=("$package")
                echo ""
                continue
              fi
            fi
            echo "‚úÖ Versioning complete"

            # Get the new version from package.json
            PROJECT_ROOT=$(npx nx show project "$project" --json 2>/dev/null | jq -r '.root' || echo "")
            NEW_VERSION=$(jq -r '.version' "$PROJECT_ROOT/package.json")
            echo "New version: $NEW_VERSION"

            # Step 2: Check if package exists on npm and publish
            echo ""
            echo "Step 2: Publishing to npm..."

            # Check if package exists on npm registry
            if npm view "$package" version --registry=https://registry.npmjs.org &>/dev/null; then
              # Package exists on npm
              NPM_VERSION=$(npm view "$package" version --registry=https://registry.npmjs.org 2>/dev/null || echo "unknown")
              echo "üì¶ Status: EXISTING package on npm (current version: $NPM_VERSION)"
              echo "Publishing without --first-release flag..."

              if npx nx release publish --projects="$project" --tag=${{ steps.npm-tag.outputs.tag }} --registry=https://registry.npmjs.org; then
                PUBLISH_SUCCESS=true
              else
                PUBLISH_SUCCESS=false
              fi
            else
              # Package does NOT exist on npm (truly a first release)
              echo "üÜï Status: NEW package (not found on npm registry)"

              # Show Git tags if they exist (for debugging orphaned tags)
              FOUND_TAGS=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -u || echo "")
              if [ -n "$FOUND_TAGS" ]; then
                echo "‚ö†Ô∏è  Note: Git tags exist but package not on npm (likely from failed previous publish)"
                echo "Git tags found:"
                echo "$FOUND_TAGS" | head -n 3
                echo ""
              fi

              echo "Publishing with --first-release flag..."

              if npx nx release publish --projects="$project" --first-release --tag=${{ steps.npm-tag.outputs.tag }} --registry=https://registry.npmjs.org; then
                PUBLISH_SUCCESS=true
              else
                PUBLISH_SUCCESS=false
              fi
            fi

            if [ "$PUBLISH_SUCCESS" = true ]; then
              echo "‚úÖ Successfully published $package@$NEW_VERSION to npm"

              # Step 3: Immediately push commit AND tag to remote
              # CRITICAL: This must succeed to keep git in sync with npm
              echo ""
              echo "Step 3: Pushing commit and tag to remote..."

              PUSH_FAILED=false

              # Push the version commit first
              echo "üì§ Pushing version commit to ${{ github.ref_name }}..."
              if git push origin ${{ github.ref_name }}; then
                echo "‚úÖ Successfully pushed version commit"
              else
                # Check if the failure is because we're already up to date (not a real failure)
                if git fetch origin ${{ github.ref_name }} && git diff --quiet HEAD origin/${{ github.ref_name }}; then
                  echo "‚úÖ Branch already up to date (no push needed)"
                else
                  echo "‚ùå CRITICAL: Failed to push version commit after npm publish!"
                  echo "   npm has $package@$NEW_VERSION but git doesn't have the commit."
                  echo "   This requires manual intervention to sync git with npm."
                  PUSH_FAILED=true
                fi
              fi

              # Push the git tag
              PACKAGE_TAG=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -V | tail -n 1)
              if [ -n "$PACKAGE_TAG" ]; then
                echo "üè∑Ô∏è  Pushing tag: $PACKAGE_TAG"
                if git push origin "$PACKAGE_TAG"; then
                  echo "‚úÖ Successfully pushed tag $PACKAGE_TAG"
                else
                  # Check if tag already exists on remote (not a real failure)
                  if git ls-remote --tags origin | grep -q "refs/tags/$PACKAGE_TAG$"; then
                    echo "‚úÖ Tag $PACKAGE_TAG already exists on remote"
                  else
                    echo "‚ùå CRITICAL: Failed to push tag $PACKAGE_TAG after npm publish!"
                    echo "   npm has $package@$NEW_VERSION but git doesn't have the tag."
                    PUSH_FAILED=true
                  fi
                fi
              fi

              if [ "$PUSH_FAILED" = true ]; then
                echo ""
                echo "‚ö†Ô∏è  Package $package was published to npm but git sync failed!"
                echo "    Manual intervention required to push commit/tag to git."
                # Still count as success for npm purposes, but note the git sync issue
                SUCCESS_PACKAGES+=("$package")
                echo ""
                echo "‚ö†Ô∏è  Package $package published to npm (git sync incomplete)"
              else
                SUCCESS_PACKAGES+=("$package")
                echo ""
                echo "‚úÖ Package $package fully published and synced!"
              fi
            else
              echo "‚ùå Failed to publish $package"

              # Step 3 (failure): Revert local changes
              echo ""
              echo "Step 3: Reverting local changes..."

              # Delete the local git tag for this unpublished version
              TAG_TO_DELETE=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | grep "@${NEW_VERSION}$" | head -n 1)
              if [ -n "$TAG_TO_DELETE" ]; then
                echo "  Deleting local tag: $TAG_TO_DELETE"
                git tag -d "$TAG_TO_DELETE" 2>/dev/null || echo "  ‚ö†Ô∏è  Tag already deleted"
              fi

              # Reset to before the version commit
              echo "  Resetting to previous commit..."
              git reset --hard HEAD~1

              FAILED_PACKAGES+=("$package")
              echo "‚èÆÔ∏è  Reverted local changes for $package"
            fi

            echo ""
          done

          # Convert arrays to JSON for outputs
          SUCCESS_JSON=$(printf '%s\n' "${SUCCESS_PACKAGES[@]}" | jq -R . | jq -s -c .)
          FAILED_JSON=$(printf '%s\n' "${FAILED_PACKAGES[@]}" | jq -R . | jq -s -c .)

          # Set step outputs
          echo "successful_packages=$SUCCESS_JSON" >> $GITHUB_OUTPUT
          echo "failed_packages=$FAILED_JSON" >> $GITHUB_OUTPUT
          echo "successful_count=${#SUCCESS_PACKAGES[@]}" >> $GITHUB_OUTPUT
          echo "failed_count=${#FAILED_PACKAGES[@]}" >> $GITHUB_OUTPUT
          echo "has_failures=$( [ ${#FAILED_PACKAGES[@]} -gt 0 ] && echo 'true' || echo 'false' )" >> $GITHUB_OUTPUT
          echo "has_successes=$( [ ${#SUCCESS_PACKAGES[@]} -gt 0 ] && echo 'true' || echo 'false' )" >> $GITHUB_OUTPUT

          # Report results
          echo "=========================================="
          echo "Publishing Summary"
          echo "=========================================="
          echo "Successful: ${#SUCCESS_PACKAGES[@]} package(s)"
          for pkg in "${SUCCESS_PACKAGES[@]}"; do
            echo "  ‚úÖ $pkg"
          done

          if [ ${#FAILED_PACKAGES[@]} -gt 0 ]; then
            echo ""
            echo "Failed: ${#FAILED_PACKAGES[@]} package(s)"
            for pkg in "${FAILED_PACKAGES[@]}"; do
              echo "  ‚ùå $pkg"
            done
            echo ""
            echo "‚ö†Ô∏è  Some packages failed to publish."
            echo "    Successfully published packages are fully synced to git."
            echo "    Failed packages have been reverted locally (no orphaned state)."
          else
            echo ""
            echo "‚úÖ All packages published and synced successfully!"
          fi

          # Exit successfully even if some packages failed (as long as at least one succeeded)
          if [ ${#SUCCESS_PACKAGES[@]} -eq 0 ]; then
            echo ""
            echo "‚ùå No packages were successfully published. Failing workflow."
            exit 1
          fi
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NODE_AUTH_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}

      - name: Create GitHub releases
        if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && steps.publish.outputs.has_successes == 'true'
        run: |
          # Get only the successfully published packages from the publish step
          # Parse the JSON array of successful packages
          SUCCESSFUL_PACKAGES='${{ steps.publish.outputs.successful_packages }}'

          echo "Creating GitHub releases for successfully published packages..."
          echo "Successful packages JSON: $SUCCESSFUL_PACKAGES"
          echo ""

          # Parse JSON array into bash array
          readarray -t PACKAGES < <(echo "$SUCCESSFUL_PACKAGES" | jq -r '.[]')

          if [ ${#PACKAGES[@]} -eq 0 ]; then
            echo "‚ö†Ô∏è  No successfully published packages to create releases for."
            exit 0
          fi

          for package in "${PACKAGES[@]}"; do
            if [ -z "$package" ]; then
              continue
            fi

            echo "Processing package: $package"

            # Extract the package name without scope for tag checking
            PACKAGE_NAME=$(echo "$package" | sed 's/@[^/]*\///')

            # Get the latest tag for this package
            # Nx creates tags in the format: package-name@version or @scope/package-name@version
            # Use git tag glob patterns for precise matching without escaping issues
            LATEST_TAG=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -V | tail -n 1)

            if [ -n "$LATEST_TAG" ]; then
              # Extract version from tag
              VERSION="${LATEST_TAG##*@}"

              # Check if release already exists
              if gh release view "$LATEST_TAG" &>/dev/null; then
                echo "‚úì Release $LATEST_TAG already exists, skipping"
              else
                echo "Creating GitHub release for $LATEST_TAG"

                # Create the release with a basic changelog
                # The AI-generated changelog will be added to Slack/Notion notifications
                gh release create "$LATEST_TAG" \
                  --title "$package $VERSION" \
                  --notes "Release $VERSION of $package. See [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details." \
                  --verify-tag

                echo "‚úÖ Created release for $LATEST_TAG"
              fi
            else
              echo "‚ö†Ô∏è No tag found for $package (this might indicate the package was not versioned)"
            fi

            echo ""
          done

          echo "GitHub releases creation complete."
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}

  generate-changelog:
    name: Generate AI-powered changelog
    needs: publish
    if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && needs.publish.outputs.has_successes == 'true'
    uses: ./.github/workflows/_generate-changelog.yml
    with:
      from_ref: ${{ github.event.before }}
      to_ref: ${{ github.sha }}
      output_formats: 'slack,markdown'
      custom_prompt_text: |
        # Release Changelog Generation Prompt

        You are a changelog generator. Based on the following git changes, create a concise, human-readable changelog summary.

        ${{ needs.publish.outputs.has_failures == 'true' && format('**IMPORTANT**: This is a PARTIAL release. Some packages failed to publish.

        **Successfully published packages**:
        {0}

        **Failed packages** (not published):
        {1}

        Focus your changelog ONLY on the successfully published packages. Add a note at the end about which packages failed to publish.

        ', join(fromJSON(needs.publish.outputs.successful_packages), ', '), join(fromJSON(needs.publish.outputs.failed_packages), ', ')) || format('All packages were successfully published.

        **Published packages**:
        {0}

        ', join(fromJSON(needs.publish.outputs.successful_packages), ', ')) }}

        Focus on:
        - What features were added
        - What bugs were fixed
        - What was changed or improved

        Format requirements:
        - Use bullet points (‚Ä¢ or -) for each item, separated by a newline character
        - Keep it to 3-10 items max
        - Be concise and clear
        - Do NOT include commit hashes unless specifically requested
        - Group related changes together

        Slack formatting requirements (IMPORTANT):
        - DO NOT use markdown headers (no #, ##, ###)
        - Use plain text for section titles followed by a colon (e.g., "Features:")
        - Use _single asterisks_ for bold text (NOT double asterisks)
        - Use _underscores_ for italic text
        - Use simple bullet lists with ‚Ä¢ or - characters
        - Keep formatting minimal and clean
        - DO NOT use standard markdown links [text](url) - just use plain URLs or omit them
      max_tokens: 1024
    secrets:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

  notify-release:
    name: Notify release via Slack
    needs: [publish, generate-changelog]
    if: github.event.inputs.dryRun != 'true' && github.event_name == 'push' && needs.publish.outputs.has_successes == 'true'
    uses: ./.github/workflows/_notify-release.yml
    with:
      changelog_slack: ${{ needs.generate-changelog.outputs.changelog_slack }}
      changelog_markdown: ${{ needs.generate-changelog.outputs.changelog_markdown }}
      destinations: 'slack,notion'
      from_ref: ${{ github.event.before }}
      to_ref: ${{ github.sha }}
      branch: ${{ github.ref_name }}
      release_title: ${{ needs.publish.outputs.has_failures == 'true' && format('‚ö†Ô∏è Partial Release - {0} ({1} succeeded, {2} failed)', github.ref_name, needs.publish.outputs.successful_count, needs.publish.outputs.failed_count) || '' }}
    secrets:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      NOTION_API_KEY: ${{ secrets.NOTION_API_KEY }}
      RELEASE_NOTES_NOTION_DATABASE_ID: ${{ secrets.RELEASE_NOTES_NOTION_DATABASE_ID }}
      NODE_AUTH_TOKEN: ${{ secrets.NODE_AUTH_TOKEN }}

  sync-next:
    name: Sync next branch with main
    runs-on: ubuntu-24.04
    needs: publish
    # Only run when main branch is updated (not on next branch pushes)
    if: github.ref_name == 'main' && github.event_name == 'push'
    permissions:
      contents: write

    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec # v6
        with:
          gpg_private_key: ${{ secrets.SERVICE_ACCOUNT_GPG_PRIVATE_KEY }}
          git_user_signingkey: true
          git_commit_gpgsign: true
          git_tag_gpgsign: true
          git_config_global: true

      - name: Configure Git identity for service account
        run: |
          git config user.name "Uniswap Labs Service Account"
          git config user.email "hello-happy-puppy@uniswap.org"

      - name: Verify GPG configuration
        run: |
          echo "GPG signing enabled: $(git config commit.gpgsign)"
          echo "GPG signing key: $(git config user.signingkey)"
          echo "Git user name: $(git config user.name)"
          echo "Git user email: $(git config user.email)"

      - name: Install Graphite CLI
        run: |
          # Install Graphite CLI using npm (faster than installing Homebrew)
          npm install -g @withgraphite/graphite-cli

          # Verify installation
          gt --version

      - name: Sync next branch with main
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
        run: |
          echo "Starting sync of next branch with main..."

          # Fetch all remote branches
          git fetch origin

          # Check if next branch exists on remote
          if ! git show-ref --verify --quiet refs/remotes/origin/next; then
            echo "Next branch does not exist on remote. Skipping sync."
            exit 0
          fi

          # Switch to next branch (tracking origin/next)
          git checkout -B next origin/next

          # Attempt to rebase next onto main
          echo "Rebasing next onto main..."

          # Try to rebase onto origin/main
          if git rebase origin/main; then
            echo "‚úÖ Rebase successful!"

            # Create an empty commit to mark this as a sync operation
            # This prevents the publish workflow from triggering on the next branch
            git commit --allow-empty -m "chore(sync): [skip ci] sync next with main"

            # Force push the rebased next branch
            git push origin next --force-with-lease

            echo "‚úÖ Successfully synced next branch with main"

            # Create summary
            echo "## üîÑ Branch Sync Complete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The \`next\` branch has been successfully rebased onto \`main\`." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Main branch**: $(git rev-parse --short origin/main)" >> $GITHUB_STEP_SUMMARY
            echo "- **Next branch**: $(git rev-parse --short next)" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Rebase failed due to conflicts"

            # Abort the rebase
            git rebase --abort

            # Create an issue for manual intervention
            gh issue create \
              --title "Manual intervention required: next branch sync failed" \
              --body "The automatic sync of the \`next\` branch with \`main\` has failed due to conflicts.

              ## Action Required
              Please manually resolve the conflicts by:
              1. Checking out the \`next\` branch locally
              2. Rebasing it onto \`main\`
              3. Resolving any conflicts
              4. Force pushing the resolved branch

              ## Commands
              \`\`\`bash
              git checkout next
              git fetch origin
              git rebase origin/main
              # Resolve conflicts
              git push origin next --force-with-lease
              \`\`\`

              This issue was automatically created by the publish-packages workflow." \
              --label "automated,needs-attention"

            echo "## ‚ö†Ô∏è Branch Sync Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The \`next\` branch could not be automatically rebased onto \`main\` due to conflicts." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "An issue has been created for manual intervention." >> $GITHUB_STEP_SUMMARY

            exit 1
          fi

      - name: Alternative sync with Graphite (if available)
        if: failure()
        continue-on-error: true
        run: |
          echo "Attempting alternative sync method with Graphite CLI..."

          # Initialize Graphite if needed
          gt init --trunk main --no-interactive || true

          # Try to sync using Graphite
          if gt sync --force --no-interactive; then
            echo "‚úÖ Successfully synced using Graphite CLI"
          else
            echo "‚ö†Ô∏è Graphite sync also failed. Manual intervention required."
          fi
