name: Publish Packages

# Reusable workflow that handles the core package publishing logic.
# This workflow is called by both __publish-packages.yml and force-publish-packages.yml
# to avoid code duplication.
#
# RESPONSIBILITIES:
# - Building specified packages
# - Cleaning up orphaned git tags (optional)
# - Versioning packages (conventional commits or prerelease)
# - Publishing to npm with specified tag
# - Pushing version commits and tags to remote
# - Creating GitHub releases
#
# REQUIRED SECRETS (passed from caller):
# - WORKFLOW_PAT: For pushing commits/tags
# - NODE_AUTH_TOKEN: For npm publishing
# - SERVICE_ACCOUNT_GPG_PRIVATE_KEY: For signing commits/tags

on:
  workflow_call:
    inputs:
      projects:
        description: "Comma-separated list of Nx project names to publish"
        required: true
        type: string
      packages:
        description: "Comma-separated list of npm package names (must match projects order)"
        required: true
        type: string
      npm_tag:
        description: "npm tag to publish with (latest or next)"
        required: true
        type: string
      version_strategy:
        description: 'Version strategy: "conventional" (uses commit history) or "prerelease" (bumps prerelease)'
        required: true
        type: string
      preid:
        description: 'Prerelease identifier (e.g., "next"). Only used when version_strategy is "prerelease"'
        required: false
        type: string
        default: "next"
      branch:
        description: "Branch to push commits/tags to"
        required: true
        type: string
      dry_run:
        description: "If true, only simulate publishing without making changes"
        required: false
        type: boolean
        default: false
      clean_orphaned_tags:
        description: "If true, clean up orphaned git tags before publishing"
        required: false
        type: boolean
        default: false
      base_sha:
        description: "Base SHA for affected detection (used for building). If empty, builds all specified projects."
        required: false
        type: string
        default: ""
      is_prerelease:
        description: "If true, GitHub releases are marked as prereleases"
        required: false
        type: boolean
        default: false
    outputs:
      successful_packages:
        description: "JSON array of successfully published package names"
        value: ${{ jobs.publish.outputs.successful_packages }}
      failed_packages:
        description: "JSON array of failed package names"
        value: ${{ jobs.publish.outputs.failed_packages }}
      successful_count:
        description: "Number of successfully published packages"
        value: ${{ jobs.publish.outputs.successful_count }}
      failed_count:
        description: "Number of failed packages"
        value: ${{ jobs.publish.outputs.failed_count }}
      has_failures:
        description: "true if any packages failed to publish"
        value: ${{ jobs.publish.outputs.has_failures }}
      has_successes:
        description: "true if any packages were successfully published"
        value: ${{ jobs.publish.outputs.has_successes }}
    secrets:
      WORKFLOW_PAT:
        required: true
      NODE_AUTH_TOKEN:
        required: true
      SERVICE_ACCOUNT_GPG_PRIVATE_KEY:
        required: true

jobs:
  publish:
    runs-on:
      group: npm-deploy
    environment: Production
    permissions:
      id-token: write
      contents: write
      packages: write
      pull-requests: write
      issues: write
    outputs:
      successful_packages: ${{ steps.publish.outputs.successful_packages }}
      failed_packages: ${{ steps.publish.outputs.failed_packages }}
      successful_count: ${{ steps.publish.outputs.successful_count }}
      failed_count: ${{ steps.publish.outputs.failed_count }}
      has_failures: ${{ steps.publish.outputs.has_failures }}
      has_successes: ${{ steps.publish.outputs.has_successes }}

    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec # v6
        with:
          gpg_private_key: ${{ secrets.SERVICE_ACCOUNT_GPG_PRIVATE_KEY }}
          git_user_signingkey: true
          git_commit_gpgsign: true
          git_tag_gpgsign: true
          git_config_global: true

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: Setup Node.js
        uses: actions/setup-node@2028fbc5c25fe9cf00d9f06a71cc4710d4507903 # v6.0.0
        with:
          node-version: ${{ vars.NODE_VERSION }}
          registry-url: "https://registry.npmjs.org"
          scope: "@uniswap"

      - name: Install npm
        # IMPORTANT: Pinning npm version for two reasons:
        # 1. OIDC trusted publishing requires npm >= 11.5.1
        # 2. Using a pinned version prevents lockfile format changes in CI
        run: npm install -g npm@${{ vars.NPM_VERSION }}

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Verify package-lock.json unchanged
        run: |
          if ! git diff --exit-code package-lock.json; then
            echo "‚ùå ERROR: npm ci modified package-lock.json!"
            echo "This should not happen. Please investigate why npm ci is modifying the lock file."
            git diff package-lock.json
            exit 1
          fi
          echo "‚úÖ package-lock.json unchanged after npm ci"

      - name: Configure Git identity for service account
        run: |
          git config user.name "Uniswap Labs Service Account"
          git config user.email "hello-happy-puppy@uniswap.org"

      - name: Verify GPG configuration
        run: |
          echo "GPG signing enabled: $(git config commit.gpgsign)"
          echo "GPG signing key: $(git config user.signingkey)"
          echo "Git user name: $(git config user.name)"
          echo "Git user email: $(git config user.email)"

      - name: Build packages
        env:
          INPUT_PROJECTS: ${{ inputs.projects }}
          INPUT_BASE_SHA: ${{ inputs.base_sha }}
        run: |
          echo "Building packages: $INPUT_PROJECTS"

          if [ -n "$INPUT_BASE_SHA" ]; then
            # Use affected build if base SHA is provided
            echo "Using affected build with base: $INPUT_BASE_SHA"
            npx nx affected --target=build --base="$INPUT_BASE_SHA" --head=HEAD
          else
            # Build each project individually
            IFS=',' read -ra PROJECT_ARRAY <<< "$INPUT_PROJECTS"
            for project in "${PROJECT_ARRAY[@]}"; do
              echo "Building $project..."
              npx nx build "$project"
            done
          fi

      - name: Clean up orphaned tags
        if: inputs.clean_orphaned_tags && !inputs.dry_run
        env:
          INPUT_PACKAGES: ${{ inputs.packages }}
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
          NODE_AUTH_TOKEN: ${{ secrets.NODE_AUTH_TOKEN }}
          INPUT_BRANCH: ${{ inputs.branch }}
          INPUT_NPM_TAG: ${{ inputs.npm_tag }}
        run: |
          # Configure npm authentication for viewing restricted packages
          echo "//registry.npmjs.org/:_authToken=${NODE_AUTH_TOKEN}" > ~/.npmrc
          echo "Configured npm authentication for restricted package queries"
          echo ""

          echo "=========================================="
          echo "Checking for orphaned Git tags"
          echo "=========================================="
          echo ""
          echo "Orphaned tags are Git tags that exist but their corresponding"
          echo "npm package version was never successfully published."
          echo "These must be cleaned up before versioning can proceed."
          echo ""

          # Convert comma-separated list to array
          IFS=',' read -ra PACKAGES <<< "$INPUT_PACKAGES"

          CLEANED_TAGS=()

          for package in "${PACKAGES[@]}"; do
            if [ -z "$package" ]; then
              continue
            fi

            echo "Checking package: $package"

            # Extract the package name without scope for tag checking
            PACKAGE_NAME=$(echo "$package" | sed 's/@[^/]*\///')

            # Get the latest tag for this package
            LATEST_TAG=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -V | tail -n 1)

            if [ -z "$LATEST_TAG" ]; then
              echo "  ‚ÑπÔ∏è  No tags found - will create first tag during versioning"
              echo ""
              continue
            fi

            # Extract version from tag
            VERSION="${LATEST_TAG##*@}"
            echo "  Latest tag: $LATEST_TAG (version: $VERSION)"

            # Check if this specific version exists on npm
            if npm view "${package}@${VERSION}" version --registry=https://registry.npmjs.org &>/dev/null; then
              echo "  ‚úÖ Version $VERSION exists on npm - tag is valid"
              echo ""
            else
              echo "  ‚ö†Ô∏è  Version $VERSION NOT found on npm - tag is orphaned!"
              echo "  üßπ Deleting orphaned tag: $LATEST_TAG"

              # Delete tag locally
              if git tag -d "$LATEST_TAG" 2>/dev/null; then
                echo "  ‚úÖ Deleted local tag"
              else
                echo "  ‚ö†Ô∏è  Local tag already deleted or doesn't exist"
              fi

              # Delete tag from remote
              if git push --delete origin "$LATEST_TAG" 2>/dev/null; then
                echo "  ‚úÖ Deleted remote tag"
                CLEANED_TAGS+=("$LATEST_TAG")
              else
                echo "  ‚ö†Ô∏è  Remote tag already deleted or doesn't exist"
              fi

              echo ""
            fi
          done

          echo ""
          echo "=========================================="
          echo "Checking for missing Git tags"
          echo "=========================================="
          echo ""
          echo "Missing tags are npm versions that were successfully"
          echo "published but their Git tags were never pushed to remote."
          echo "These must be created so Nx can properly version from them."
          echo ""

          CREATED_TAGS=()

          for package in "${PACKAGES[@]}"; do
            if [ -z "$package" ]; then
              continue
            fi

            echo "Checking package: $package"

            # Get latest version from npm for the appropriate dist-tag
            if [[ "$INPUT_NPM_TAG" == "next" ]]; then
              LATEST_NPM=$(npm view "$package" dist-tags.next --registry=https://registry.npmjs.org 2>/dev/null || echo "")
              echo "  Querying npm dist-tag 'next'..."
            else
              LATEST_NPM=$(npm view "$package" version --registry=https://registry.npmjs.org 2>/dev/null || echo "")
              echo "  Querying npm version (latest)..."
            fi

            if [ -z "$LATEST_NPM" ]; then
              echo "  ‚ÑπÔ∏è  Package not on npm yet (will be first release)"
              echo ""
              continue
            fi

            EXPECTED_TAG="${package}@${LATEST_NPM}"
            echo "  Latest npm version: $LATEST_NPM"

            # Check if Git tag exists for this version
            if git rev-parse "$EXPECTED_TAG" >/dev/null 2>&1; then
              echo "  ‚úÖ Git tag exists: $EXPECTED_TAG (in sync)"
            else
              echo "  üîß Git tag missing for npm version $LATEST_NPM"
              echo "  üè∑Ô∏è  Creating tag: $EXPECTED_TAG"

              # Create tag at current HEAD
              if git tag "$EXPECTED_TAG" HEAD 2>/dev/null; then
                echo "  ‚úÖ Created local tag at HEAD"
                CREATED_TAGS+=("$EXPECTED_TAG")
              else
                echo "  ‚ö†Ô∏è  Failed to create tag (may already exist locally)"
              fi
            fi

            echo ""
          done

          # Push any newly created tags to remote
          PUSHED_TAGS=()
          FAILED_PUSH_TAGS=()

          if [ ${#CREATED_TAGS[@]} -gt 0 ]; then
            echo "=========================================="
            echo "Pushing missing tags to remote"
            echo "=========================================="
            echo ""

            for tag in "${CREATED_TAGS[@]}"; do
              echo "  üè∑Ô∏è  Pushing tag: $tag"
              if git push origin "$tag" 2>/dev/null; then
                echo "  ‚úÖ Successfully pushed $tag"
                PUSHED_TAGS+=("$tag")
              else
                # Check if tag already exists on remote (not a real failure)
                if git ls-remote --tags origin | grep -q "refs/tags/$tag$"; then
                  echo "  ‚úÖ Tag $tag already exists on remote"
                  PUSHED_TAGS+=("$tag")
                else
                  echo "  ‚ùå Failed to push $tag"
                  FAILED_PUSH_TAGS+=("$tag")
                fi
              fi
            done

            echo ""
          fi

          # Summary
          echo "=========================================="
          echo "Git/npm Sync Summary"
          echo "=========================================="

          if [ ${#CLEANED_TAGS[@]} -gt 0 ]; then
            echo "Orphaned Tags Cleaned (deleted): ${#CLEANED_TAGS[@]}"
            for tag in "${CLEANED_TAGS[@]}"; do
              echo "  üßπ $tag"
            done
            echo "  ‚Üí These will be recreated with correct associations"
          else
            echo "Orphaned Tags Cleaned: 0"
            echo "  ‚úÖ No orphaned tags found"
          fi

          echo ""

          if [ ${#PUSHED_TAGS[@]} -gt 0 ]; then
            echo "Missing Tags Created and Pushed: ${#PUSHED_TAGS[@]}"
            for tag in "${PUSHED_TAGS[@]}"; do
              echo "  ‚úÖ $tag"
            done
            echo "  ‚Üí Nx will now use these as base for version bumps"
          else
            echo "Missing Tags Synced: 0"
            echo "  ‚úÖ Git tags already in sync with npm versions"
          fi

          if [ ${#FAILED_PUSH_TAGS[@]} -gt 0 ]; then
            echo ""
            echo "‚ö†Ô∏è  Failed to Push Tags: ${#FAILED_PUSH_TAGS[@]}"
            for tag in "${FAILED_PUSH_TAGS[@]}"; do
              echo "  ‚ùå $tag"
            done
            echo "  ‚Üí These tags exist locally but not on remote. Manual push may be required."
          fi

          echo ""
          echo "‚úÖ Git/npm synchronization complete."
          echo "   Nx versioning will now use accurate base versions."
          echo ""

      - name: Version and publish packages (dry run)
        if: inputs.dry_run
        env:
          INPUT_PROJECTS: ${{ inputs.projects }}
          INPUT_PACKAGES: ${{ inputs.packages }}
          INPUT_NPM_TAG: ${{ inputs.npm_tag }}
          INPUT_VERSION_STRATEGY: ${{ inputs.version_strategy }}
          INPUT_PREID: ${{ inputs.preid }}
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
          NODE_AUTH_TOKEN: ${{ secrets.NODE_AUTH_TOKEN }}
        run: |
          # Configure npm authentication for viewing restricted packages
          echo "//registry.npmjs.org/:_authToken=${NODE_AUTH_TOKEN}" > ~/.npmrc

          echo "=========================================="
          echo "DRY RUN - Publishing Preview"
          echo "=========================================="
          echo "Projects: $INPUT_PROJECTS"
          echo "npm tag: $INPUT_NPM_TAG"
          echo "Version strategy: $INPUT_VERSION_STRATEGY"
          echo ""

          # Helper function for smart prerelease version calculation (same as live)
          calculate_prerelease_version() {
            local package="$1"
            local preid="$2"

            echo "  Calculating prerelease version for $package with preid '$preid'..." >&2

            local latest_version
            latest_version=$(npm view "$package" dist-tags.latest --registry=https://registry.npmjs.org 2>/dev/null || echo "")

            if [ -z "$latest_version" ]; then
              latest_version="0.0.0"
              echo "  üì¶ Package not yet published to npm, using base 0.0.0" >&2
            else
              echo "  üì¶ Latest version on npm: $latest_version" >&2
            fi

            local major minor patch
            IFS='.' read -r major minor patch <<< "$latest_version"
            patch="${patch%%-*}"
            local base_version="${major}.${minor}.$((patch + 1))"
            echo "  üìê Base version for prerelease: $base_version" >&2

            local npm_prerelease=-1
            local npm_versions
            npm_versions=$(npm view "$package" versions --json --registry=https://registry.npmjs.org 2>/dev/null || echo "[]")

            if [ "$npm_versions" != "[]" ]; then
              local highest_npm
              highest_npm=$(echo "$npm_versions" | jq -r --arg base "$base_version" --arg preid "$preid" '
                .[] |
                select(startswith($base + "-" + $preid + ".")) |
                split("-" + $preid + ".")[1] |
                tonumber
              ' 2>/dev/null | sort -n | tail -1)

              if [ -n "$highest_npm" ]; then
                npm_prerelease=$highest_npm
                echo "  üîç Highest prerelease on npm: ${base_version}-${preid}.${npm_prerelease}" >&2
              else
                echo "  üîç No existing prereleases on npm for ${base_version}-${preid}.*" >&2
              fi
            fi

            local git_prerelease=-1
            local git_tags
            git_tags=$(git tag -l "${package}@${base_version}-${preid}.*" 2>/dev/null || echo "")

            if [ -n "$git_tags" ]; then
              local highest_git
              highest_git=$(echo "$git_tags" | sed "s|${package}@${base_version}-${preid}\.||" | sort -n | tail -1)
              if [ -n "$highest_git" ] && [[ "$highest_git" =~ ^[0-9]+$ ]]; then
                git_prerelease=$highest_git
                echo "  üè∑Ô∏è  Highest prerelease in git tags: ${base_version}-${preid}.${git_prerelease}" >&2
              fi
            else
              echo "  üè∑Ô∏è  No existing git tags for ${package}@${base_version}-${preid}.*" >&2
            fi

            local max_prerelease
            if [ "$npm_prerelease" -gt "$git_prerelease" ]; then
              max_prerelease=$npm_prerelease
            else
              max_prerelease=$git_prerelease
            fi

            local new_prerelease=$((max_prerelease + 1))
            local new_version="${base_version}-${preid}.${new_prerelease}"

            echo "  ‚ú® Calculated new version: $new_version" >&2
            echo "$new_version"
          }

          IFS=',' read -ra PROJECT_ARRAY <<< "$INPUT_PROJECTS"
          IFS=',' read -ra PACKAGE_ARRAY <<< "$INPUT_PACKAGES"

          for i in "${!PROJECT_ARRAY[@]}"; do
            project="${PROJECT_ARRAY[$i]}"
            package="${PACKAGE_ARRAY[$i]}"

            echo "-------------------------------------------"
            echo "Processing: $project ‚Üí $package"
            echo "-------------------------------------------"

            echo "Versioning (dry run)..."
            if [[ "$INPUT_VERSION_STRATEGY" == "prerelease" ]]; then
              echo "Using smart prerelease versioning (Option A: base = latest + 0.0.1)"
              CALCULATED_VERSION=$(calculate_prerelease_version "$package" "$INPUT_PREID")
              echo ""
              echo "üìã WOULD SET VERSION TO: $CALCULATED_VERSION"
              echo "üìã WOULD CREATE TAG: ${package}@${CALCULATED_VERSION}"
            else
              npx nx release version --projects="$project" --dry-run
            fi

            echo ""
            echo "Publishing (dry run)..."
            echo "üìã WOULD PUBLISH: $package with tag '$INPUT_NPM_TAG'"

            echo ""
          done

          echo "=========================================="
          echo "DRY RUN COMPLETE - No changes made"
          echo "=========================================="

      - name: Version, publish, and push packages
        if: "!inputs.dry_run"
        id: publish
        env:
          INPUT_PROJECTS: ${{ inputs.projects }}
          INPUT_PACKAGES: ${{ inputs.packages }}
          INPUT_NPM_TAG: ${{ inputs.npm_tag }}
          INPUT_VERSION_STRATEGY: ${{ inputs.version_strategy }}
          INPUT_PREID: ${{ inputs.preid }}
          INPUT_BRANCH: ${{ inputs.branch }}
          NODE_AUTH_TOKEN: ${{ secrets.NODE_AUTH_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
        run: |
          # Configure npm authentication for viewing restricted packages
          echo "//registry.npmjs.org/:_authToken=${NODE_AUTH_TOKEN}" > ~/.npmrc
          echo "Configured npm authentication for restricted package queries"
          echo ""

          echo "Processing packages with tag: $INPUT_NPM_TAG"
          echo "Nx projects: $INPUT_PROJECTS"
          echo "npm packages: $INPUT_PACKAGES"
          echo ""
          echo "=========================================="
          echo "ATOMIC PUBLISH STRATEGY"
          echo "=========================================="
          echo "For each package, we will:"
          echo "  1. Version the package (update package.json, create commit + tag)"
          echo "  2. Publish to npm"
          echo "  3. If successful: immediately push commit + tag to remote"
          echo "  4. If failed: revert local changes and continue"
          echo ""
          echo "This ensures git and npm stay in sync after each publish."
          echo ""

          # ============================================================
          # Helper function: Calculate correct prerelease version
          # ============================================================
          # Algorithm (Option A):
          # 1. Get 'latest' from npm (default 0.0.1 if not published)
          # 2. Calculate base = latest + 0.0.1 (bump patch)
          # 3. Find highest base-{preid}.* on npm
          # 4. Find highest base-{preid}.* git tag
          # 5. Use MAX(npm_prerelease, git_tag_prerelease) + 1 as new prerelease number
          # ============================================================
          calculate_prerelease_version() {
            local package="$1"
            local preid="$2"

            echo "  Calculating prerelease version for $package with preid '$preid'..." >&2

            # Step 1: Get latest version from npm
            local latest_version
            latest_version=$(npm view "$package" dist-tags.latest --registry=https://registry.npmjs.org 2>/dev/null || echo "")

            if [ -z "$latest_version" ]; then
              latest_version="0.0.0"
              echo "  üì¶ Package not yet published to npm, using base 0.0.0" >&2
            else
              echo "  üì¶ Latest version on npm: $latest_version" >&2
            fi

            # Step 2: Calculate base version (latest + 0.0.1 = bump patch)
            local major minor patch
            IFS='.' read -r major minor patch <<< "$latest_version"
            # Remove any prerelease suffix from patch if present
            patch="${patch%%-*}"
            local base_version="${major}.${minor}.$((patch + 1))"
            echo "  üìê Base version for prerelease: $base_version" >&2

            # Step 3: Find highest prerelease number on npm for this base
            local npm_prerelease=-1
            local npm_versions
            npm_versions=$(npm view "$package" versions --json --registry=https://registry.npmjs.org 2>/dev/null || echo "[]")

            if [ "$npm_versions" != "[]" ]; then
              # Extract prerelease numbers matching base-preid.N pattern
              local highest_npm
              highest_npm=$(echo "$npm_versions" | jq -r --arg base "$base_version" --arg preid "$preid" '
                .[] |
                select(startswith($base + "-" + $preid + ".")) |
                split("-" + $preid + ".")[1] |
                tonumber
              ' 2>/dev/null | sort -n | tail -1)

              if [ -n "$highest_npm" ]; then
                npm_prerelease=$highest_npm
                echo "  üîç Highest prerelease on npm: ${base_version}-${preid}.${npm_prerelease}" >&2
              else
                echo "  üîç No existing prereleases on npm for ${base_version}-${preid}.*" >&2
              fi
            fi

            # Step 4: Find highest prerelease number in git tags for this base
            local git_prerelease=-1
            local git_tags
            git_tags=$(git tag -l "${package}@${base_version}-${preid}.*" 2>/dev/null || echo "")

            if [ -n "$git_tags" ]; then
              local highest_git
              highest_git=$(echo "$git_tags" | sed "s|${package}@${base_version}-${preid}\.||" | sort -n | tail -1)
              if [ -n "$highest_git" ] && [[ "$highest_git" =~ ^[0-9]+$ ]]; then
                git_prerelease=$highest_git
                echo "  üè∑Ô∏è  Highest prerelease in git tags: ${base_version}-${preid}.${git_prerelease}" >&2
              fi
            else
              echo "  üè∑Ô∏è  No existing git tags for ${package}@${base_version}-${preid}.*" >&2
            fi

            # Step 5: Calculate new prerelease number as MAX + 1
            local max_prerelease
            if [ "$npm_prerelease" -gt "$git_prerelease" ]; then
              max_prerelease=$npm_prerelease
            else
              max_prerelease=$git_prerelease
            fi

            local new_prerelease=$((max_prerelease + 1))
            local new_version="${base_version}-${preid}.${new_prerelease}"

            echo "  ‚ú® Calculated new version: $new_version" >&2
            echo "$new_version"
          }

          # Convert comma-separated lists to arrays
          IFS=',' read -ra PROJECTS <<< "$INPUT_PROJECTS"
          IFS=',' read -ra PACKAGES <<< "$INPUT_PACKAGES"

          # Track publishing results
          FAILED_PACKAGES=()
          SUCCESS_PACKAGES=()

          # Process each package atomically: version ‚Üí publish ‚Üí push
          for i in "${!PROJECTS[@]}"; do
            project="${PROJECTS[$i]}"
            package="${PACKAGES[$i]}"

            if [ -z "$project" ] || [ -z "$package" ]; then
              continue
            fi

            echo "=========================================="
            echo "Processing: $project ‚Üí $package"
            echo "=========================================="

            # Extract the package name without scope
            PACKAGE_NAME=$(echo "$package" | sed 's/@[^/]*\///')

            # Get project root for package.json updates
            PROJECT_ROOT=$(npx nx show project "$project" --json 2>/dev/null | jq -r '.root' || echo "")
            if [ -z "$PROJECT_ROOT" ] || [ ! -f "$PROJECT_ROOT/package.json" ]; then
              echo "‚ùå Could not find package.json for $project"
              FAILED_PACKAGES+=("$package")
              continue
            fi

            # Step 1: Version this specific package
            echo ""
            echo "Step 1: Versioning package..."
            if [[ "$INPUT_VERSION_STRATEGY" == "prerelease" ]]; then
              echo "Using smart prerelease versioning (Option A: base = latest + 0.0.1)"

              # Calculate the correct version using our custom algorithm
              NEW_VERSION=$(calculate_prerelease_version "$package" "$INPUT_PREID")

              if [ -z "$NEW_VERSION" ]; then
                echo "‚ùå Failed to calculate version for $package"
                FAILED_PACKAGES+=("$package")
                echo ""
                continue
              fi

              echo "  Setting version to: $NEW_VERSION"

              # Update package.json with the new version
              jq --arg version "$NEW_VERSION" '.version = $version' "$PROJECT_ROOT/package.json" > "$PROJECT_ROOT/package.json.tmp"
              mv "$PROJECT_ROOT/package.json.tmp" "$PROJECT_ROOT/package.json"

              # Create git commit for the version bump
              git add "$PROJECT_ROOT/package.json"
              git commit -m "chore(release): $package@$NEW_VERSION"

              # Create git tag (must use -m flag since CI has no terminal for editor)
              git tag -m "Release ${package}@${NEW_VERSION}" "${package}@${NEW_VERSION}"

              echo "‚úÖ Versioning complete (version: $NEW_VERSION)"
            else
              echo "Using conventional commits to determine version bump"
              if ! npx nx release version --projects="$project"; then
                echo "‚ùå Failed to version $package"
                FAILED_PACKAGES+=("$package")
                echo ""
                continue
              fi
              # Get the new version from package.json (set by Nx)
              NEW_VERSION=$(jq -r '.version' "$PROJECT_ROOT/package.json")
              echo "‚úÖ Versioning complete"
            fi
            echo "New version: $NEW_VERSION"

            # Step 2: Check if package exists on npm and publish
            echo ""
            echo "Step 2: Publishing to npm..."

            # Check if package exists on npm registry
            if npm view "$package" version --registry=https://registry.npmjs.org &>/dev/null; then
              # Package exists on npm
              NPM_VERSION=$(npm view "$package" version --registry=https://registry.npmjs.org 2>/dev/null || echo "unknown")
              echo "üì¶ Status: EXISTING package on npm (current version: $NPM_VERSION)"
              echo "Publishing without --first-release flag..."

              if npx nx release publish --projects="$project" --tag="$INPUT_NPM_TAG" --registry=https://registry.npmjs.org; then
                PUBLISH_SUCCESS=true
              else
                PUBLISH_SUCCESS=false
              fi
            else
              # Package does NOT exist on npm (truly a first release)
              echo "üÜï Status: NEW package (not found on npm registry)"

              # Show Git tags if they exist (for debugging orphaned tags)
              FOUND_TAGS=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -u || echo "")
              if [ -n "$FOUND_TAGS" ]; then
                echo "‚ö†Ô∏è  Note: Git tags exist but package not on npm (likely from failed previous publish)"
                echo "Git tags found:"
                echo "$FOUND_TAGS" | head -n 3
                echo ""
              fi

              echo "Publishing with --first-release flag..."

              if npx nx release publish --projects="$project" --first-release --tag="$INPUT_NPM_TAG" --registry=https://registry.npmjs.org; then
                PUBLISH_SUCCESS=true
              else
                PUBLISH_SUCCESS=false
              fi
            fi

            if [ "$PUBLISH_SUCCESS" = true ]; then
              echo "‚úÖ Successfully published $package@$NEW_VERSION to npm"

              # Step 3: Immediately push commit AND tag to remote
              # CRITICAL: This must succeed to keep git in sync with npm
              echo ""
              echo "Step 3: Pushing commit and tag to remote..."

              PUSH_FAILED=false

              # Push the version commit first
              echo "üì§ Pushing version commit to $INPUT_BRANCH..."
              if git push origin "$INPUT_BRANCH"; then
                echo "‚úÖ Successfully pushed version commit"
              else
                # Check if the failure is because we're already up to date (not a real failure)
                if git fetch origin "$INPUT_BRANCH" && git diff --quiet HEAD "origin/$INPUT_BRANCH"; then
                  echo "‚úÖ Branch already up to date (no push needed)"
                else
                  echo "‚ùå CRITICAL: Failed to push version commit after npm publish!"
                  echo "   npm has $package@$NEW_VERSION but git doesn't have the commit."
                  echo "   This requires manual intervention to sync git with npm."
                  PUSH_FAILED=true
                fi
              fi

              # Push the git tag
              PACKAGE_TAG=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -V | tail -n 1)
              if [ -n "$PACKAGE_TAG" ]; then
                echo "üè∑Ô∏è  Pushing tag: $PACKAGE_TAG"
                if git push origin "$PACKAGE_TAG"; then
                  echo "‚úÖ Successfully pushed tag $PACKAGE_TAG"
                else
                  # Check if tag already exists on remote (not a real failure)
                  if git ls-remote --tags origin | grep -q "refs/tags/$PACKAGE_TAG$"; then
                    echo "‚úÖ Tag $PACKAGE_TAG already exists on remote"
                  else
                    echo "‚ùå CRITICAL: Failed to push tag $PACKAGE_TAG after npm publish!"
                    echo "   npm has $package@$NEW_VERSION but git doesn't have the tag."
                    PUSH_FAILED=true
                  fi
                fi
              fi

              if [ "$PUSH_FAILED" = true ]; then
                echo ""
                echo "‚ö†Ô∏è  Package $package was published to npm but git sync failed!"
                echo "    Manual intervention required to push commit/tag to git."
                # Still count as success for npm purposes, but note the git sync issue
                SUCCESS_PACKAGES+=("$package")
                echo ""
                echo "‚ö†Ô∏è  Package $package published to npm (git sync incomplete)"
              else
                SUCCESS_PACKAGES+=("$package")
                echo ""
                echo "‚úÖ Package $package fully published and synced!"
              fi
            else
              echo "‚ùå Failed to publish $package"

              # Step 3 (failure): Revert local changes
              echo ""
              echo "Step 3: Reverting local changes..."

              # Delete the local git tag for this unpublished version
              TAG_TO_DELETE=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | grep "@${NEW_VERSION}$" | head -n 1)
              if [ -n "$TAG_TO_DELETE" ]; then
                echo "  Deleting local tag: $TAG_TO_DELETE"
                git tag -d "$TAG_TO_DELETE" 2>/dev/null || echo "  ‚ö†Ô∏è  Tag already deleted"
              fi

              # Reset to before the version commit
              echo "  Resetting to previous commit..."
              git reset --hard HEAD~1

              FAILED_PACKAGES+=("$package")
              echo "‚èÆÔ∏è  Reverted local changes for $package"
            fi

            echo ""
          done

          # Convert arrays to JSON for outputs
          SUCCESS_JSON=$(printf '%s\n' "${SUCCESS_PACKAGES[@]}" | jq -R . | jq -s -c .)
          FAILED_JSON=$(printf '%s\n' "${FAILED_PACKAGES[@]}" | jq -R . | jq -s -c .)

          # Set step outputs
          echo "successful_packages=$SUCCESS_JSON" >> $GITHUB_OUTPUT
          echo "failed_packages=$FAILED_JSON" >> $GITHUB_OUTPUT
          echo "successful_count=${#SUCCESS_PACKAGES[@]}" >> $GITHUB_OUTPUT
          echo "failed_count=${#FAILED_PACKAGES[@]}" >> $GITHUB_OUTPUT
          echo "has_failures=$( [ ${#FAILED_PACKAGES[@]} -gt 0 ] && echo 'true' || echo 'false' )" >> $GITHUB_OUTPUT
          echo "has_successes=$( [ ${#SUCCESS_PACKAGES[@]} -gt 0 ] && echo 'true' || echo 'false' )" >> $GITHUB_OUTPUT

          # Report results
          echo "=========================================="
          echo "Publishing Summary"
          echo "=========================================="
          echo "Successful: ${#SUCCESS_PACKAGES[@]} package(s)"
          for pkg in "${SUCCESS_PACKAGES[@]}"; do
            echo "  ‚úÖ $pkg"
          done

          if [ ${#FAILED_PACKAGES[@]} -gt 0 ]; then
            echo ""
            echo "Failed: ${#FAILED_PACKAGES[@]} package(s)"
            for pkg in "${FAILED_PACKAGES[@]}"; do
              echo "  ‚ùå $pkg"
            done
            echo ""
            echo "‚ö†Ô∏è  Some packages failed to publish."
            echo "    Successfully published packages are fully synced to git."
            echo "    Failed packages have been reverted locally (no orphaned state)."
          else
            echo ""
            echo "‚úÖ All packages published and synced successfully!"
          fi

          # Exit successfully even if some packages failed (as long as at least one succeeded)
          if [ ${#SUCCESS_PACKAGES[@]} -eq 0 ]; then
            echo ""
            echo "‚ùå No packages were successfully published. Failing workflow."
            exit 1
          fi

      - name: Create GitHub releases
        if: "!inputs.dry_run && steps.publish.outputs.has_successes == 'true'"
        env:
          SUCCESSFUL_PACKAGES: ${{ steps.publish.outputs.successful_packages }}
          INPUT_IS_PRERELEASE: ${{ inputs.is_prerelease }}
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
        run: |
          echo "Creating GitHub releases for successfully published packages..."
          echo "Successful packages JSON: $SUCCESSFUL_PACKAGES"
          echo ""

          # Parse JSON array into bash array
          readarray -t PACKAGES < <(echo "$SUCCESSFUL_PACKAGES" | jq -r '.[]')

          if [ ${#PACKAGES[@]} -eq 0 ]; then
            echo "‚ö†Ô∏è  No successfully published packages to create releases for."
            exit 0
          fi

          for package in "${PACKAGES[@]}"; do
            if [ -z "$package" ]; then
              continue
            fi

            echo "Processing package: $package"

            # Extract the package name without scope for tag checking
            PACKAGE_NAME=$(echo "$package" | sed 's/@[^/]*\///')

            # Get the latest tag for this package
            LATEST_TAG=$(git tag -l "${PACKAGE_NAME}@*" "${package}@*" 2>/dev/null | sort -V | tail -n 1)

            if [ -n "$LATEST_TAG" ]; then
              # Extract version from tag
              VERSION="${LATEST_TAG##*@}"

              # Check if release already exists
              if gh release view "$LATEST_TAG" &>/dev/null; then
                echo "‚úì Release $LATEST_TAG already exists, skipping"
              else
                echo "Creating GitHub release for $LATEST_TAG"

                # Build release command
                RELEASE_CMD="gh release create \"$LATEST_TAG\" --title \"$package $VERSION\" --verify-tag"

                if [ "$INPUT_IS_PRERELEASE" = "true" ]; then
                  RELEASE_CMD="$RELEASE_CMD --prerelease --notes \"Prerelease $VERSION of $package.\""
                else
                  RELEASE_CMD="$RELEASE_CMD --notes \"Release $VERSION of $package. See workflow run for details.\""
                fi

                eval "$RELEASE_CMD"
                echo "‚úÖ Created release for $LATEST_TAG"
              fi
            else
              echo "‚ö†Ô∏è No tag found for $package (this might indicate the package was not versioned)"
            fi

            echo ""
          done

          echo "GitHub releases creation complete."
