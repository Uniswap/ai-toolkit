#!/usr/bin/env <%= shell %>

# Uniswap AI Toolkit Registry Proxy
# Automatically routes @uniswap/ai-toolkit* packages to GitHub registry
# This file is auto-generated by @uniswap/ai-toolkit-nx-claude
# Generated on: <%= generatedDate %>
#
# Note: If you manually specify --@uniswap:registry, this proxy will detect it
# and skip adding the registry flag to avoid conflicts

# Helper function to check if a string is a package that needs GitHub registry
_is_uniswap_ai_toolkit_package() {
    local arg="$1"
    # Remove version specifier if present
    local pkg="${arg%%@*}"
    # Check if it matches our patterns
    [[ "$pkg" =~ ^@uniswap/ai-toolkit ]] || \
    [[ "$arg" =~ ^@uniswap/ai-toolkit.*@.* ]] || \
    [[ "$pkg" = "@uniswap/spec-workflow-mcp" ]] || \
    [[ "$arg" =~ ^@uniswap/spec-workflow-mcp@.* ]]
}

# Main proxy function that processes arguments
_proxy_npm_command() {
    local original_cmd="$1"
    shift

    local needs_registry=false
    local has_registry=false

    # First pass: check if we need the registry and if it's already provided
    for arg in "$@"; do
        if _is_uniswap_ai_toolkit_package "$arg"; then
            needs_registry=true
        fi
        # Check if registry is already specified
        if [[ "$arg" =~ ^--@uniswap:registry= ]] || [[ "$arg" =~ ^--registry=.*github\.com ]]; then
            has_registry=true
        fi
    done

    # If we don't need the registry, or it's already provided, just run the original command
    if [ "$needs_registry" = false ] || [ "$has_registry" = true ]; then
        command "$original_cmd" "$@"
        return $?
    fi

    # Special handling for bun/bunx - they don't support --registry flag
    # Instead, we need to use npm/npx as fallback for GitHub packages
    if [ "$original_cmd" = "bunx" ]; then
        # Use npx instead of bunx for GitHub packages
        echo "ðŸ“¦ Using npx for GitHub package (bunx doesn't support custom registries)..." >&2
        npx --@uniswap:registry=https://npm.pkg.github.com "$@"
        return $?
    fi

    if [ "$original_cmd" = "bun" ]; then
        # Check if this is an install/add command
        local subcommand="${1}"
        case "$subcommand" in
            install|i|add)
                echo "âš ï¸  Warning: bun doesn't support --registry flag. Configure .npmrc or bunfig.toml for @uniswap scope instead." >&2
                echo "   See: https://bun.sh/docs/install/registries" >&2
                # Run the original command anyway
                command "$original_cmd" "$@"
                return $?
                ;;
        esac
        # For other bun commands, just pass through
        command "$original_cmd" "$@"
        return $?
    fi

    # For npx, we need special handling
    if [ "$original_cmd" = "npx" ]; then
        # Build the command with registry injected early (only if not already present)
        local new_args=("--@uniswap:registry=https://npm.pkg.github.com")
        new_args+=("$@")
        command "$original_cmd" "${new_args[@]}"
        return $?
    fi

    # For other commands (npm, yarn, pnpm), inject after subcommand
    local new_args=()
    local registry_added=false
    local skip_next=false
    local found_subcommand=false

    for arg in "$@"; do
        # Skip if we're processing a flag's value
        if [ "$skip_next" = true ]; then
            new_args+=("$arg")
            skip_next=false
            continue
        fi

        # Check if this is a flag that takes a value
        if [[ "$arg" =~ ^- ]]; then
            new_args+=("$arg")
            # Check if this flag expects a value
            case "$arg" in
                -y|--yes|-g|--global|--dry-run|--no-*|--silent|--verbose)
                    # These don't take values
                    ;;
                *)
                    # Most other flags take values, skip next arg
                    if [[ ! "$arg" =~ = ]]; then
                        skip_next=true
                    fi
                    ;;
            esac
            continue
        fi

        # Check if this is a subcommand
        if [ "$found_subcommand" = false ]; then
            case "$arg" in
                install|i|add|remove|rm|uninstall|update|upgrade|info|view|v|list|ls|link|unlink|publish|unpublish|run|exec|init|create)
                    new_args+=("$arg")
                    found_subcommand=true
                    # Add registry right after subcommand
                    if [ "$registry_added" = false ]; then
                        new_args+=("--@uniswap:registry=https://npm.pkg.github.com")
                        registry_added=true
                    fi
                    continue
                    ;;
            esac
        fi

        new_args+=("$arg")
    done

    # If we didn't add registry yet (no subcommand found), add it now
    if [ "$registry_added" = false ]; then
        new_args+=("--@uniswap:registry=https://npm.pkg.github.com")
    fi

    # Execute the command with modified arguments
    command "$original_cmd" "${new_args[@]}"
}

# Create proxy functions for each command
npm() {
    _proxy_npm_command npm "$@"
}

npx() {
    _proxy_npm_command npx "$@"
}

yarn() {
    _proxy_npm_command yarn "$@"
}

bun() {
    _proxy_npm_command bun "$@"
}

bunx() {
    _proxy_npm_command bunx "$@"
}

pnpm() {
    _proxy_npm_command pnpm "$@"
}

pnpx() {
    _proxy_npm_command pnpx "$@"
}

# Show message on first load (can be disabled by setting UNISWAP_AI_TOOLKIT_QUIET=1)
if [ -z "$UNISWAP_AI_TOOLKIT_QUIET" ] && [ -z "$UNISWAP_AI_TOOLKIT_LOADED" ]; then
    echo "ðŸ”§ Uniswap AI Toolkit registry proxy loaded - @uniswap packages will auto-route to GitHub registry"
    export UNISWAP_AI_TOOLKIT_LOADED=1
fi
