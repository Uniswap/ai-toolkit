#!/usr/bin/env node

import { readdir, readFile, writeFile, stat } from 'fs/promises';
import { join } from 'path';
import { execSync } from 'child_process';

interface SkillInfo {
  name: string;
  description: string;
  directoryPath: string;
}

export interface GenerateSkillIndexOptions {
  srcPath: string;
  outputPath: string;
  regenerateCommand: string;
}

/**
 * Parse a SKILL.md file to extract name and description from YAML frontmatter
 */
async function parseSkillFile(
  filePath: string
): Promise<{ name: string; description: string } | null> {
  try {
    const content = await readFile(filePath, 'utf-8');

    // Look for YAML frontmatter
    const yamlMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!yamlMatch) {
      console.warn(`No YAML frontmatter found in ${filePath}`);
      return null;
    }

    const yamlContent = yamlMatch[1];

    // Extract name (required for skills)
    const nameMatch = yamlContent.match(/^name:\s*(.+)$/m);
    if (!nameMatch) {
      console.warn(`Missing name in ${filePath}`);
      return null;
    }

    // Extract description (required for skills)
    const descriptionMatch = yamlContent.match(/^description:\s*(.+)$/m);
    if (!descriptionMatch) {
      console.warn(`Missing description in ${filePath}`);
      return null;
    }

    const name = nameMatch[1].trim().replace(/^["']|["']$/g, '');
    const description = descriptionMatch[1].trim().replace(/^["']|["']$/g, '');

    return { name, description };
  } catch (error) {
    console.error(`Error parsing ${filePath}:`, error);
    return null;
  }
}

/**
 * Generate the index.ts file for skills
 * Skills are directories containing a SKILL.md file
 */
export async function generateSkillIndex(
  options: GenerateSkillIndexOptions
): Promise<void> {
  const { srcPath, outputPath, regenerateCommand } = options;

  // Read all entries in src directory
  const entries = await readdir(srcPath);

  const skills: SkillInfo[] = [];

  // Check each entry to see if it's a skill directory
  for (const entry of entries) {
    const entryPath = join(srcPath, entry);
    const entryStat = await stat(entryPath);

    // Skip non-directories
    if (!entryStat.isDirectory()) {
      continue;
    }

    // Check if directory contains a SKILL.md file
    const skillFilePath = join(entryPath, 'SKILL.md');
    try {
      await stat(skillFilePath);
    } catch {
      // No SKILL.md file, skip this directory
      continue;
    }

    // Parse the SKILL.md file
    const parsed = await parseSkillFile(skillFilePath);
    if (parsed) {
      skills.push({
        name: parsed.name,
        description: parsed.description,
        directoryPath: `./${entry}`,
      });
    }
  }

  // Sort skills alphabetically by name
  skills.sort((a, b) => a.name.localeCompare(b.name));

  // Generate TypeScript content
  const typeUnion = skills.map((skill) => `  | '${skill.name}'`).join('\n');

  const skillsObject = skills
    .map((skill) => {
      const key = skill.name.includes('-') ? `'${skill.name}'` : skill.name;
      return `  ${key}: {
    description:
      '${skill.description.replace(/'/g, "\\'")}',
    directoryPath: '${skill.directoryPath}',
  }`;
    })
    .join(',\n');

  const indexContent = `// Auto-generated file - DO NOT EDIT
// Generated by @ai-toolkit/utils generate-skill-index
// To regenerate, run: ${regenerateCommand}

// Skill types
type SkillName =
${typeUnion || "  | never"};

export type Skills = {
  [key in SkillName]: {
    description: string;
    directoryPath: string;
  };
};

// Export skills with descriptions and directory paths
export const skills: Skills = {
${skillsObject}
} as const;

export type { SkillName };
`;

  // Write the generated index.ts
  await writeFile(outputPath, indexContent, 'utf-8');

  // Format the generated file using Prettier
  try {
    execSync(`npx prettier --write "${outputPath}"`, {
      stdio: 'pipe',
    });
  } catch (error) {
    console.warn('⚠️  Failed to format generated file:', error);
  }

  console.log(`✅ Generated index.ts with ${skills.length} skills`);
  skills.forEach((skill) => {
    console.log(`  - ${skill.name}`);
  });
}

// CLI support
if (import.meta.url === `file://${process.argv[1]}`) {
  const args = process.argv.slice(2);

  if (args.length < 2) {
    console.error(
      'Usage: generate-skill-index <srcPath> <outputPath> [regenerateCommand]'
    );
    process.exit(1);
  }

  const [
    srcPath,
    outputPath,
    regenerateCommand = 'npx nx run <project>:generate-index',
  ] = args;

  generateSkillIndex({
    srcPath,
    outputPath,
    regenerateCommand,
  }).catch((error) => {
    console.error('Failed to generate index:', error);
    process.exit(1);
  });
}
