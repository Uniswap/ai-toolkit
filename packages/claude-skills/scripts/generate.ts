#!/usr/bin/env node

import { readdir, readFile, writeFile, stat } from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { execSync } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

interface SkillInfo {
  name: string;
  description: string;
  allowedTools?: string;
  model?: string;
  dirPath: string;
  files: string[];
}

async function parseSkillFile(skillDir: string, skillFilePath: string): Promise<SkillInfo | null> {
  try {
    const content = await readFile(skillFilePath, 'utf-8');

    // Look for YAML frontmatter
    const yamlMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!yamlMatch) {
      console.warn(`No YAML frontmatter found in ${skillFilePath}`);
      return null;
    }

    const yamlContent = yamlMatch[1];

    // Extract name
    const nameMatch = yamlContent.match(/^name:\s*(.+)$/m);
    if (!nameMatch) {
      console.warn(`Missing name in ${skillFilePath}`);
      return null;
    }
    const name = nameMatch[1].trim();

    // Extract description
    const descriptionMatch = yamlContent.match(/^description:\s*(.+)$/m);
    if (!descriptionMatch) {
      console.warn(`Missing description in ${skillFilePath}`);
      return null;
    }
    const description = descriptionMatch[1].trim().replace(/^["']|["']$/g, '');

    // Extract allowed-tools (optional)
    const toolsMatch = yamlContent.match(/^allowed-tools:\s*(.+)$/m);
    const allowedTools = toolsMatch ? toolsMatch[1].trim() : undefined;

    // Extract model (optional)
    const modelMatch = yamlContent.match(/^model:\s*(.+)$/m);
    const model = modelMatch ? modelMatch[1].trim() : undefined;

    // Get all files in the skill directory
    const dirFiles = await readdir(skillDir);
    const files = dirFiles.filter((f) => f.endsWith('.md'));

    return {
      name,
      description,
      allowedTools,
      model,
      dirPath: `./${name}`,
      files,
    };
  } catch (error) {
    console.error(`Error parsing ${skillFilePath}:`, error);
    return null;
  }
}

async function generateSkillsIndex(): Promise<void> {
  const srcPath = join(__dirname, '..', 'src');
  const outputPath = join(srcPath, 'index.ts');

  // Read all directories in src
  const entries = await readdir(srcPath);
  const skills: SkillInfo[] = [];

  for (const entry of entries) {
    const entryPath = join(srcPath, entry);
    const entryStat = await stat(entryPath);

    if (entryStat.isDirectory()) {
      const skillFilePath = join(entryPath, 'SKILL.md');
      try {
        await stat(skillFilePath);
        const skillInfo = await parseSkillFile(entryPath, skillFilePath);
        if (skillInfo) {
          skills.push(skillInfo);
        }
      } catch {
        // No SKILL.md in this directory, skip
      }
    }
  }

  // Sort skills alphabetically by name
  skills.sort((a, b) => a.name.localeCompare(b.name));

  // Generate TypeScript content
  const typeUnion = skills.map((skill) => `  | '${skill.name}'`).join('\n');

  const skillsObject = skills
    .map((skill) => {
      const key = skill.name.includes('-') ? `'${skill.name}'` : skill.name;
      const escapedDescription = skill.description.replace(/\\/g, '\\\\').replace(/'/g, "\\'");

      let properties = `    description: '${escapedDescription}',
    dirPath: '${skill.dirPath}',
    files: [${skill.files.map((f) => `'${f}'`).join(', ')}]`;

      if (skill.allowedTools) {
        const escapedTools = skill.allowedTools.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
        properties += `,\n    allowedTools: '${escapedTools}'`;
      }
      if (skill.model) {
        properties += `,\n    model: '${skill.model}'`;
      }

      return `  ${key}: {\n${properties},\n  }`;
    })
    .join(',\n');

  const indexContent = `// Auto-generated file - DO NOT EDIT
// Generated by @ai-toolkit/claude-skills generate script
// To regenerate, run: npx nx run @ai-toolkit/claude-skills:generate-index

type SkillName =
${typeUnion};

export interface SkillDefinition {
  description: string;
  dirPath: string;
  files: string[];
  allowedTools?: string;
  model?: string;
}

export type Skills = {
  [key in SkillName]: SkillDefinition;
};

export const skills: Skills = {
${skillsObject},
} as const;

export type { SkillName };
export const skillNames = Object.keys(skills) as SkillName[];
`;

  // Write the generated index.ts
  await writeFile(outputPath, indexContent, 'utf-8');

  // Format the generated file using Prettier
  try {
    execSync(`npx prettier --write "${outputPath}"`, {
      stdio: 'pipe',
    });
  } catch (error) {
    console.warn('⚠️  Failed to format generated file:', error);
  }

  console.log(`✅ Generated index.ts with ${skills.length} skills`);
  skills.forEach((skill) => {
    console.log(`  - ${skill.name}`);
  });
}

generateSkillsIndex().catch((error) => {
  console.error('Failed to generate skills index:', error);
  process.exit(1);
});
